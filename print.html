<!DOCTYPE HTML>
<html lang="zh-CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust study</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom-f3fb0f0a.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-ba3b86ab.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-0a04486d.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust study</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/169li/rust-study" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<p>个人在学习Rust过程中的一些笔记记录:</p>
<ul>
<li>Rust语法基础</li>
<li>Rust算法刷题</li>
<li>…..</li>
</ul>
<p>参考的资料有：</p>
<p><a href="https://course.rs/about-book.html">Rust语言圣经(Rust Course)</a></p>
<p><a href="https://practice-zh.course.rs/why-exercise.html">练习实践</a></p>
<p><a href="https://rust-lang.github.io/api-guidelines/about.html">API编程指南</a></p>
<p><a href="https://rust.sui-book.com/01_basics/01_intro.html">Rust带学</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rust学习"><a class="header" href="#rust学习">Rust学习</a></h1>
<p>学习笔记中可能由于编译器的更新，一些地方可能与现在不一致。</p>
<p>2024年12月31日</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="基础语法"><a class="header" href="#基础语法">基础语法</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="变量"><a class="header" href="#变量">变量</a></h1>
<p>在 Rust 中，变量的处理方式与其他编程语言（如 Python 或 Java）有很大不同。其核心设计理念是<strong>安全性</strong>和<strong>内存管理</strong>。</p>
<p>以下是关于 Rust 变量的核心知识点：</p>
<h2 id="变量绑定"><a class="header" href="#变量绑定">变量绑定</a></h2>
<p>在很多编程语言中，我们会说“给变量赋值”。但在 Rust 中，官方术语通常是  <strong>“变量绑定” (Variable Binding)</strong> 。</p>
<ul>
<li><strong>语法</strong> ：<code>let x = 5;</code></li>
<li><strong>核心逻辑</strong> ：这个语句意味着我们将名字 <code>x</code> 与值 <code>5</code> <strong>绑定</strong>在一起。</li>
<li><strong>为什么叫“绑定”？</strong>
<ul>
<li><strong>模式匹配</strong> ：<code>let</code> 关键字后面跟着的实际上是一个 <strong>模式 (Pattern)</strong> 。例如，你可以这样写：<code>let (a, b) = (1, 2);</code>。这里 Rust 会把元组中的值分别绑定到 <code>a</code> 和 <code>b</code> 上。</li>
<li><strong>所有权控制</strong> ：绑定不仅仅是内存地址的赋值，它还涉及到 Rust 核心的<strong>所有权 (Ownership)</strong> 系统。当一个值绑定到一个变量名时，这个变量名就“拥有”了这个值。</li>
</ul>
</li>
</ul>
<h3 id="使用下划线忽略未使用的变量"><a class="header" href="#使用下划线忽略未使用的变量">使用下划线忽略未使用的变量</a></h3>
<p>Rust 编译器非常注重代码的整洁。如果声明了一个变量但从未使用过它，编译器会报出警告（Warning），认为这可能是代码逻辑上的疏忽。</p>
<h4 id="a-使用-_-纯下划线"><a class="header" href="#a-使用-_-纯下划线">A. 使用 <code>_</code> (纯下划线)</a></h4>
<p>如果你完全不关心某个值，可以使用 <code>_</code>。它会立即丢弃该值，不会进行任何绑定。</p>
<pre class="playground"><code class="language-rust editable edition2024"><span class="boring">fn main() {
</span>    let _ = 5; // 值被直接丢弃, 不绑定到任何名字, 你之后无法通过任何名字访问这个 5
    let _ = some_function_returns_result(); // 我调用了函数，但我不在乎返回值
}
fn some_function_returns_result() -&gt; i32 {
    42
}</code></pre>
<h4 id="b-使用下划线开头-如-_x"><a class="header" href="#b-使用下划线开头-如-_x">B. 使用下划线开头 (如 <code>_x</code>)</a></h4>
<p>如果你想保留这个变量（可能为了调试或者为了以后扩展），但现在暂时不用，又不希望看到编译器的警告，可以在变量名前加一个下划线。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 5;     // ⚠️ 编译器会警告：unused variable: `x`
    let _y = 10;   // ✅ 编译器会保持沉默，因为它看到了下划线前缀
}</code></pre>
<p>cargo run:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>warning: unused variable: `y`
 --&gt; src/main.rs:3:9
  |
3 |     let y = 10;
  |         ^ help: 如果 y 故意不被使用，请添加一个下划线前缀: `_y`
  |
  = note: `#[warn(unused_variables)]` on by default
<span class="boring">}</span></code></pre>
<hr>
<h2 id="不可变性"><a class="header" href="#不可变性">不可变性</a></h2>
<p>在 Rust 中，变量<strong>默认是不可变的</strong>。一旦你为一个变量绑定了值，就不能再修改它。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 5;
    x = 6; // ❌ 编译错误！不能对不可变变量二次赋值
}</code></pre>
<p><strong>为什么要这样做？</strong></p>
<p>通过默认不可变，Rust 保证了数据的安全性。在多线程环境下，你可以确信一个变量的值不会在你不注意的时候被其他代码修改。</p>
<hr>
<h2 id="可变变量"><a class="header" href="#可变变量">可变变量</a></h2>
<p>如果你需要修改某个变量，必须显式地加上 <code>mut</code> 关键字。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut x = 5;
    println!("x 的值是: {}", x);
    x = 6; // ✅ 允许修改
    println!("现在 x 的值是: {}", x);
}</code></pre>
<hr>
<h2 id="变量遮蔽"><a class="header" href="#变量遮蔽">变量遮蔽</a></h2>
<p>Rust 允许你声明一个与现有变量同名的新变量。这被称为“遮蔽”。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 5;
    let x = x + 1; // 遮蔽了之前的 x
  
    {
        let x = x * 2; // 在当前作用域内再次遮蔽
        println!("内部作用域中 x 的值: {}", x); // 12
    }

    println!("外部作用域中 x 的值: {}", x); // 6
}
</code></pre>
<p><strong>遮蔽与 <code>mut</code> 的区别：</strong></p>
<ol>
<li><strong>类型转换</strong>：使用 <code>let</code> 遮蔽时，你可以改变变量的类型（例如从字符串变为数字），而 <code>mut</code> 变量的类型是固定的。</li>
<li><strong>重新锁定</strong>：遮蔽后，新变量如果没有 <code>mut</code>，它依然是不可变的。</li>
</ol>
<hr>
<h2 id="常量"><a class="header" href="#常量">常量</a></h2>
<p>常量类似于不可变变量，但有严格的区别：</p>
<ul>
<li>使用 <code>const</code> 关键字。</li>
<li><strong>必须</strong>显式注明类型（例如 <code>i32</code>）。</li>
<li>可以在任何作用域声明（包括全局）。</li>
<li>只能赋值为“常量表达式”，不能是函数调用的结果或运行时计算的值。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
fn main() {
    println!("三小时的秒数: {}", THREE_HOURS_IN_SECONDS);
}</code></pre>
<h2 id="作用域"><a class="header" href="#作用域">作用域</a></h2>
<p>变量在 Rust 中是“块级作用域”的。变量在声明的大括号 <code>{}</code> 内有效，超出范围后，变量会被<strong>释放 (Drop)</strong>。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let s = "hello"; // s 进入作用域
    {
        let x = 10; // x 进入作用域
    } // x 在这里失效并释放
    println!("s 的值是: {}", s); // ✅ 可以访问 s
} // s 在这里失效并释放





</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h1>
<h2 id="1-标量类型scalar-types"><a class="header" href="#1-标量类型scalar-types">1. 标量类型(Scalar Types)</a></h2>
<p>标量类型代表一个单一的值。</p>
<h3 id="a-整数类型-integers"><a class="header" href="#a-整数类型-integers">A. 整数类型 (Integers)</a></h3>
<p>Rust 提供了非常精细的整数控制，分为有符号（<code>i</code>）和无符号（<code>u</code>）。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>长度</th><th>有符号 (Signed)</th><th>无符号 (Unsigned)</th><th>范围 (n 为位数)</th></tr>
</thead>
<tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td><td><code>i8: -(2^(8-1))</code> ~ <code>2^(8-1)-1</code>,<br /> <code>u8: 0</code> ~<code> 2^8-1</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td><td><code>i16: -(2^(16-1))</code> ~<code>2^(16-1)-1</code>,<br /><code>u16: 0</code> ~<code>2^16-1</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code> (默认)</td><td><code>u32</code></td><td><code>i32: -(2^(32-1))</code> ~<code>2^(32-1)-1</code>,<br /><code>u32: 0 </code> ~<code> 2^32-1</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td><td><code>i64: -(2^(64-1))</code> ~<code>2^(64-1)-1</code>,<br /><code>u64: 0 </code> ~<code> 2^64-1</code></td></tr>
<tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td><td><code>i128:-(2^(128-1))</code> ~<code>2^(128-1)-1</code>,<br /><code>u128: 0 </code> ~<code> 2^128-1</code></td></tr>
<tr><td>arch (平台相关)</td><td><code>isize</code></td><td><code>usize</code></td><td>取决于计算机架构 (64位或32位)</td></tr>
</tbody>
</table>
</div>
<ul>
<li>
<p><strong><code>usize</code> / <code>isize</code> 的用途</strong>：常用于集合索引、切片范围、长度（如 <code>len()</code>）、以及与内存地址大小相关的场景。</p>
</li>
<li>
<p><strong>整数字面值</strong>：可以使用 <code>_</code> 分隔增强可读性，如 <code>1_000_000</code>。支持 <code>0x</code>（十六进制）、<code>0o</code>（八进制）、<code>0b</code>（二进制）。</p>
</li>
<li>
<p><strong>类型后缀</strong>：可在字面量后加后缀明确类型，如 <code>10u8</code>、<code>20i64</code>。</p>
</li>
<li>
<p><strong>溢出行为</strong>：</p>
<ul>
<li>debug 构建：整数溢出会触发 <code>panic!</code></li>
<li>release 构建：默认按补码进行回绕（wrapping）</li>
<li>常见策略方法：<code>wrapping_add</code>、<code>checked_add</code>、<code>overflowing_add</code>、<code>saturating_add</code></li>
</ul>
</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let a: u8 = 250;
    assert_eq!(a.wrapping_add(10), 4);
    assert_eq!(a.checked_add(10), None);
}</code></pre>
<hr>
<h3 id="b-浮点类型-floating-point"><a class="header" href="#b-浮点类型-floating-point">B. 浮点类型 (Floating-Point)</a></h3>
<p>Rust 遵循 IEEE-754 标准：</p>
<ul>
<li><strong><code>f32</code></strong>：单精度。</li>
<li><strong><code>f64</code></strong>：双精度（默认，因为在现代 CPU 上速度几乎与 <code>f32</code> 一样快，但精度更高）。</li>
</ul>
<p>浮点数相关注意点：</p>
<ul>
<li><strong>精度误差</strong>：尽量避免直接用 <code>==</code> 比较业务浮点值，常用误差范围比较。</li>
<li><strong>NaN</strong>：<code>NaN != NaN</code>，这会影响比较与排序逻辑。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 0.1f64 + 0.2;
    assert!((x - 0.3).abs() &lt; 1e-10);
}</code></pre>
<hr>
<h3 id="c-布尔与字符"><a class="header" href="#c-布尔与字符">C. 布尔与字符</a></h3>
<ul>
<li><strong><code>bool</code></strong>：<code>true</code> 和 <code>false</code>。通常占用 1 个字节。</li>
<li><strong><code>char</code></strong>：占用 <strong>4 个字节</strong>，代表一个 <strong>Unicode 标量值</strong>，可以表示中文、日文、表情符号 (Emoji) 等。<code>char</code> 不是 UTF-8 的“一个字节”，也不等同于字符串的长度单位。</li>
</ul>
<hr>
<h2 id="2-复合类型-compound-types"><a class="header" href="#2-复合类型-compound-types">2. 复合类型 (Compound Types)</a></h2>
<p>将多个值组合成一个类型。</p>
<h3 id="a-元组-tuple"><a class="header" href="#a-元组-tuple">A. 元组 (Tuple)</a></h3>
<ul>
<li><strong>特点</strong>：长度固定，<strong>各元素类型可以不同</strong>。</li>
<li><strong>定义</strong>：<code>let tup: (i32, f64, u8) = (500, 6.4, 1);</code></li>
<li><strong>访问</strong>：使用点号，如 <code>tup.0</code>。</li>
<li><strong>解构</strong>：可用模式匹配直接拆开。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    let (x, y, z) = tup;
}</code></pre>
<ul>
<li><strong>单元类型 <code>()</code></strong>：不包含任何值的元组，常作为表达式的默认返回值或占位类型。</li>
</ul>
<hr>
<h3 id="b-数组-array"><a class="header" href="#b-数组-array">B. 数组 (Array)</a></h3>
<ul>
<li><strong>特点</strong>：长度固定，<strong>各元素类型必须相同</strong>。</li>
<li><strong>定义</strong>：<code>let a = [1, 2, 3, 4, 5];</code></li>
<li><strong>类型与长度声明</strong>：<code>let a: [i32; 5] = [1, 2, 3, 4, 5];</code></li>
<li><strong>重复初始化</strong>：<code>let a = [0u8; 1024];</code></li>
<li><strong>存储</strong>：数组是固定大小的值类型，作为局部变量时通常位于栈上；若被 <code>Box</code> 等包裹，则数据会位于堆上。</li>
</ul>
<p>数组访问与边界：</p>
<ul>
<li><code>a[i]</code>：越界会 <code>panic!</code></li>
<li><code>a.get(i)</code>：返回 <code>Option&lt;&amp;T&gt;</code>，更安全</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let a = [1, 2, 3];
    assert_eq!(a.get(10), None);
}</code></pre>
<hr>
<h2 id="3-序列与字符串-sequences--strings"><a class="header" href="#3-序列与字符串-sequences--strings">3. 序列与字符串 (Sequences &amp; Strings)</a></h2>
<p>这一部分常见困惑点集中在 UTF-8 与内存分配方式。</p>
<h3 id="a-字符串-strings"><a class="header" href="#a-字符串-strings">A. 字符串 (Strings)</a></h3>
<p>Rust 核心语言层面有 <code>str</code>（动态大小类型，通常以引用切片 <code>&amp;str</code> 出现），标准库提供可增长的 <code>String</code>。</p>
<ul>
<li><strong><code>String</code></strong>：拥有所有权，数据在堆上，可增长。内部包含指针、长度、容量等信息。</li>
<li><strong><code>&amp;str</code></strong>：字符串切片，是对一段 UTF-8 字节序列的借用视图。引用本身在栈上，实际数据可能来自只读区（字符串字面量）、栈或堆。</li>
</ul>
<p>常见转换：</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let s1: String = "hello".to_string();
    let s2: &amp;str = &amp;s1;           // &amp;String 自动解引用成 &amp;str
    let s3: String = s2.to_owned(); // 或 s2.to_string()
}</code></pre>
<p>字符串索引与切片规则：</p>
<ul>
<li>Rust 不支持 <code>s[0]</code> 直接索引字符，因为 UTF-8 下“字符边界”与字节下标不总一致。</li>
<li><code>&amp;s[a..b]</code> 必须落在 UTF-8 字符边界，否则运行时会 <code>panic!</code>。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let s = "中文";
    let ok = &amp;s[0..3]; // "中" 占 3 个字节
}</code></pre>
<hr>
<h3 id="b-切片-slices"><a class="header" href="#b-切片-slices">B. 切片 (Slices)</a></h3>
<p>切片引用连续的一段序列，而不是整个集合。</p>
<ul>
<li><strong>数组/向量切片</strong>：<code>&amp;[T]</code></li>
<li><strong>字符串切片</strong>：<code>&amp;str</code>（本质上也是切片）</li>
</ul>
<p>示例：</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let a = [10, 20, 30, 40, 50];
    let slice = &amp;a[1..3]; // &amp;[20, 30]
}</code></pre>
<p>切片是一种“胖指针”，通常包含地址与长度信息，因此可以安全地携带边界。</p>
<hr>
<h2 id="4-标准库集合-standard-collections"><a class="header" href="#4-标准库集合-standard-collections">4. 标准库集合 (Standard Collections)</a></h2>
<p>虽然属于标准库，但它们在实际开发中几乎被当作基础类型使用。</p>
<h3 id="a-vect-vector"><a class="header" href="#a-vect-vector">A. <code>Vec&lt;T&gt;</code> (Vector)</a></h3>
<ul>
<li>动态数组，在堆上分配，可扩容。</li>
<li>常见 API：<code>push</code>、<code>pop</code>、<code>len</code>、<code>capacity</code>、<code>get</code>、切片 <code>&amp;v[a..b]</code> 等。</li>
<li>预分配容量：<code>Vec::with_capacity(n)</code> 可减少扩容次数。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut v = Vec::new();
    v.push(1);
    v.extend([2, 3, 4]);
    println!("{:?}", v);

    let first = v.get(0);   // Option&lt;&amp;i32&gt;
    let part = &amp;v[1..3];    // &amp;[i32]
    println!("{:?}", part);
}</code></pre>
<hr>
<h3 id="b-hashmapk-v"><a class="header" href="#b-hashmapk-v">B. <code>HashMap&lt;K, V&gt;</code></a></h3>
<ul>
<li>键值对映射结构。</li>
<li>常用 <code>entry</code> 模式在“插入或更新”时更方便。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    use std::collections::HashMap;

    let mut m = HashMap::new();
    m.insert("a", 1);
    println!("{:?}", m);

    *m.entry("a").or_insert(0) += 1;
    println!("{:?}", m);
}</code></pre>
<hr>
<h2 id="5-特殊底层类型"><a class="header" href="#5-特殊底层类型">5. 特殊/底层类型</a></h2>
<h3 id="a-枚举-enums"><a class="header" href="#a-枚举-enums">A. 枚举 (Enums)</a></h3>
<p>枚举用于表示“一组有限的可能取值”。Rust 的枚举非常强大：每个变体（variant）不仅能表示不同分支，还能携带不同类型的数据，因此很适合用来建模状态机、协议消息、错误类型等。</p>
<ol>
<li>基本定义与使用</li>
</ol>
<pre class="playground"><code class="language-rust editable edition2024">enum Direction {
    Up,
    Down,
    Left,
    Right,
}
fn move_step(d: Direction) {
    match d {
        Direction::Up =&gt; println!("up"),
        Direction::Down =&gt; println!("down"),
        Direction::Left =&gt; println!("left"),
        Direction::Right =&gt; println!("right"),
    }
}

fn main() {
    let d = Direction::Up;
    move_step(d);
}</code></pre>
<p>2)变体携带数据</p>
<p>枚举变体可以携带数据，且不同变体携带的数据类型可以不同：</p>
<pre class="playground"><code class="language-rust editable edition2024">enum Message {
    Quit,
    Move { x: i32, y: i32 },  // 结构体风格
    Write(String),            // 元组风格
}
fn main() {
    let m1 = Message::Quit;
    let m2 = Message::Move { x: 3, y: 4 };
    let m3 = Message::Write("hi".to_string());
}
</code></pre>
<hr>
<h3 id="b-结构体-structs"><a class="header" href="#b-结构体-structs">B. 结构体 (Structs)</a></h3>
<p>结构体用于把多个字段组合成一个自定义类型，是“组织数据”的核心方式之一。</p>
<ol>
<li>具名字段结构体（最常用）</li>
</ol>
<pre class="playground"><code class="language-rust editable edition2024">struct User {
    name: String,
    age: u8,
    active: bool,
}
fn main() {
    let u = User {
        name: "Alice".to_string(),
        age: 18,
        active: true,
    };
    //访问字段用点号：
    println!("{:?}", u.name);
}</code></pre>
<p>2)结构体与所有权的直观规则</p>
<p>字段类型如果是 String、Vec <code>&lt;T&gt;</code> 等“拥有型”，把结构体赋值给新变量时默认会发生移动（move）。
想继续使用旧值通常需要借用（&amp;User）或让字段可复制（如 u32）或显式 clone()。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct User {
    name: String,
    age: u8,
    active: bool,
}
fn main() {
    let u1 = User { name: "A".to_string(), age: 1, active: true };
    let u2 = u1;          // u1 被 move
    // println!("{}", u1.age); // 不能用
    println!("{}", u2.age);
}</code></pre>
<hr>
<h3 id="c-指针类型pointer-types"><a class="header" href="#c-指针类型pointer-types">C. 指针类型（Pointer Types）</a></h3>
<p>根据底层的表现形式和抽象程度，可以将 Rust 的指针分为以下四大类：</p>
<h4 id="1-引用-references--最常用的指针"><a class="header" href="#1-引用-references--最常用的指针">1. 引用 (References) —— 最常用的指针</a></h4>
<p>引用是 Rust 中最常见的指针形式，它们在底层表现为指向某个内存地址的指针。</p>
<ul>
<li><strong><code>&amp;T</code>（不可变引用）</strong> ：指向类型为 <code>T</code> 的值，允许读取数据但不能修改。</li>
<li><strong><code>&amp;mut T</code>（可变引用）</strong> ：允许读取并修改指向的数据。</li>
<li><strong>内存表现</strong> ：
<ul>
<li><strong>普通引用</strong> ：对于已知大小的类型（如 <code>i32</code>），它是单字长的指针。</li>
<li><strong>切片引用（胖指针）</strong> ：对于动态大小类型（如 <code>&amp;str</code> 或 <code>&amp;[T]</code>），它由指针和长度组成，占用两个字长。</li>
</ul>
</li>
</ul>
<h4 id="2-原生指针-raw-pointers--绕过安全的底层指针"><a class="header" href="#2-原生指针-raw-pointers--绕过安全的底层指针">2. 原生指针 (Raw Pointers) —— 绕过安全的底层指针</a></h4>
<p>原生指针与 C 语言的指针非常相似。它们在语法上定义为 <code>*const T</code> 和 <code>*mut T</code>。</p>
<ul>
<li><strong>特点</strong> ：
<ul>
<li>允许忽略借用规则，可以同时拥有多个指向同一位置的可变和不可变指针。</li>
<li>不保证指向有效的内存，且允许为 <code>null</code>。</li>
<li><strong>安全性</strong> ：解引用原生指针是不安全的，必须放在 <code>unsafe</code> 块中执行。</li>
</ul>
</li>
<li><strong>用途</strong> ：主要用于与 C 语言交互（FFI）或编写底层高性能驱动。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut num = 5;

    // 1. 从引用创建原生指针
    // 虽然创建原生指针是安全的，但后续使用是不安全的
    let r1 = &amp;num as *const i32; // 不可变原生指针
    let r2 = &amp;mut num as *mut i32; // 可变原生指针

    // 2. 解引用原生指针
    // 必须放在 unsafe 块中，否则编译器会报错
    unsafe {
        println!("r1 指向的值: {}", *r1);

    // 修改原生指针指向的数据
        *r2 = 10;
        println!("修改后 r2 指向的值: {}", *r2);
    }

    // 3. 创建一个指向任意内存地址的指针（慎用！）
    let address = 0x012345usize;
    let _r3 = address as *const i32;
}</code></pre>
<h4 id="3-函数指针-fn-pointer--代码地址的载体"><a class="header" href="#3-函数指针-fn-pointer--代码地址的载体">3. 函数指针 (fn Pointer) —— 代码地址的载体</a></h4>
<p>函数指针指向的是代码段中的函数入口地址，而不是堆栈上的数据。</p>
<ul>
<li><strong>语法</strong> ：类型写作 <code>fn(参数类型) -&gt; 返回类型</code>。</li>
<li><strong>区别于闭包</strong> ：
<ul>
<li>函数指针不捕获环境变量。</li>
<li>它的长度始终是一个字长（存储地址）。</li>
<li>它可以作为参数传递给其他函数，或者存储在数据结构中。</li>
</ul>
</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    // 像正常函数一样通过指针调用
    f(arg) + f(arg)
}

fn main() {
    // 将函数名 add_one 隐式转换为函数指针类型
    let f: fn(i32) -&gt; i32 = add_one;

    let answer = do_twice(f, 5);

    println!("计算结果为: {}", answer); // 输出: 12

    // 函数指针的大小验证
    println!("函数指针的大小: {} 字节", std::mem::size_of_val(&amp;f));
}</code></pre>
<h4 id="4-智能指针-smart-pointers--携带元数据的指针"><a class="header" href="#4-智能指针-smart-pointers--携带元数据的指针">4. 智能指针 (Smart Pointers) —— 携带元数据的指针</a></h4>
<p>智能指针是拥有数据所有权的结构体，它们实现了 <code>Deref</code> 和 <code>Drop</code> 特性。</p>
<h5 id="a-boxt-堆空间分配"><a class="header" href="#a-boxt-堆空间分配">A. <code>Box&lt;T&gt;</code> (堆空间分配)</a></h5>
<ul>
<li><strong>功能</strong> ：在堆上分配空间存储类型为 <code>T</code> 的值，并在栈上保留指针。</li>
<li><strong>场景</strong> ：当数据大小在编译时未知（如递归类型），或数据量巨大不适合在栈上拷贝时使用。</li>
</ul>
<h5 id="b-rct-引用计数指针"><a class="header" href="#b-rct-引用计数指针">B. <code>Rc&lt;T&gt;</code> (引用计数指针)</a></h5>
<ul>
<li><strong>功能</strong> ：全称 Reference Counting，允许多个变量通过增加计数来共享同一个堆数据的所有权。</li>
<li><strong>场景</strong> ：用于单线程环境下，需要一个数据有多个所有者的复杂逻辑（如树或图的节点共享）。</li>
</ul>
<h5 id="c-arct-原子引用计数指针"><a class="header" href="#c-arct-原子引用计数指针">C. <code>Arc&lt;T&gt;</code> (原子引用计数指针)</a></h5>
<ul>
<li><strong>功能</strong> ：Atomic Reference Counting，是 <code>Rc&lt;T&gt;</code> 的线程安全版本。</li>
<li><strong>场景</strong> ：多线程并发环境下，安全地共享同一份数据的所有权。</li>
</ul>
<h5 id="总结对比表"><a class="header" href="#总结对比表">总结对比表</a></h5>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>指针类型</strong></th><th><strong>语法表示</strong></th><th><strong>内存位置</strong></th><th><strong>长度(64位)</strong></th><th><strong>核心特性</strong></th></tr>
</thead>
<tbody>
<tr><td><strong>引用</strong></td><td><code>&amp;T</code>/<code>&amp;mut T</code></td><td>栈/堆</td><td>8 或 16 字节</td><td>安全借用，编译器检查生命周期</td></tr>
<tr><td><strong>原生指针</strong></td><td><code>*const T</code>/<code>*mut T</code></td><td>栈/堆</td><td>8 字节</td><td>不安全，类似 C 指针</td></tr>
<tr><td><strong>函数指针</strong></td><td><code>fn(...) -&gt; ...</code></td><td>代码段</td><td>8 字节</td><td>指向函数地址</td></tr>
<tr><td><strong>智能指针</strong></td><td><code>Box&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code></td><td>堆</td><td>8 字节</td><td>管理堆内存，提供自动清理逻辑</td></tr>
</tbody>
</table>
</div>
<hr>
<h3 id="d-optiont-与-resultt-e"><a class="header" href="#d-optiont-与-resultt-e">D. <code>Option&lt;T&gt;</code> 与 <code>Result&lt;T, E&gt;</code></a></h3>
<p>Rust 不提供 <code>null</code>，用 <code>Option&lt;T&gt;</code> 表示“可能不存在”。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x: Option&lt;i32&gt; = Some(1);
    let y: Option&lt;i32&gt; = None;
}</code></pre>
<p>错误处理通常用 <code>Result&lt;T, E&gt;</code>：</p>
<pre class="playground"><code class="language-rust editable edition2024">fn parse(s: &amp;str) -&gt; Result&lt;i32, std::num::ParseIntError&gt; {
    s.parse()
}
fn main() {
    let result = parse("123");
    println!("{:?}", result);
}</code></pre>
<hr>
<h3 id="e-never-类型-"><a class="header" href="#e-never-类型-">E. <code>Never</code> 类型 (<code>!</code>)</a></h3>
<p><code>!</code> 表示永远不会返回的类型，常见于 <code>panic!</code>、无限循环等。</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn forever() -&gt; ! {
    loop {}
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="6-类型转换注意"><a class="header" href="#6-类型转换注意">6. 类型转换注意</a></h2>
<p>Rust <strong>不会</strong>进行隐式类型转换。不同整数类型之间的转换必须显式完成。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let a: u8 = 10;
    let b: u32 = a as u32;
}</code></pre>
<p><code>as</code> 转换在整数之间可能发生截断或符号变化。需要“转换失败就返回错误/None”时可用 <code>TryFrom/TryInto</code>。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    use std::convert::TryFrom;

    let x: i32 = 300;
    let y = u8::try_from(x); // Err(...)
}</code></pre>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="注释和打印"><a class="header" href="#注释和打印">注释和打印</a></h1>
<p>在 Rust 中，注释是写给程序员看的“备忘录”，而打印则是程序与外界沟通的最基本方式。理解这两者能极大地提升开发和调试效率。</p>
<hr>
<h2 id="一-注释-comments"><a class="header" href="#一-注释-comments">一、 注释 (Comments)</a></h2>
<p>Rust 支持多种注释风格，除了代码解释外，Rust 的注释还深度集成了文档生成工具 <code>cargo doc</code>。</p>
<h3 id="1-常规注释"><a class="header" href="#1-常规注释">1. 常规注释</a></h3>
<ul>
<li><strong>单行注释</strong> ：使用 <code>//</code>，这是最常用的注释方式。</li>
<li><strong>块注释 (多行)</strong> ：使用 <code>/* ... */</code>。虽然 Rust 支持，但社区更倾向于在多行也使用单行注释。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    // 这是一个单行注释
    let x = 5; // 也可以在代码行末尾

    /* 这是一个块注释
       它可以跨越多行 */
    let y = 10;
}</code></pre>
<h3 id="2-文档注释-doc-comments"><a class="header" href="#2-文档注释-doc-comments">2. 文档注释 (Doc Comments)</a></h3>
<p>这是 Rust 的特色，用于生成 HTML 格式的 API 文档。</p>
<ul>
<li><strong>三斜杠 <code>///</code></strong> ：为紧随其后的 <strong>项目</strong> （如函数、结构体）生成文档。支持 Markdown 语法。</li>
<li><strong>双斜杠感叹号 <code>//!</code></strong> ：为包含该注释的 <strong>条目</strong> （如整个 crate 或模块）生成文档。</li>
</ul>
<pre><code class="language-rust ignore">//! # 核心逻辑模块
//! 这个模块包含了一些数学运算函数。

/// 将两个数字相加。
/// 
/// # Examples
/// ```
/// let res = add(1, 2);
/// ```
fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}</code></pre>
<p>在<a href="#文档">文档</a>章节会详细介绍文档注释的使用方法和注意事项。</p>
<hr>
<h2 id="二-打印-printing"><a class="header" href="#二-打印-printing">二、 打印 (Printing)</a></h2>
<p>Rust 的打印是通过一组<strong>宏 (Macros)</strong> 来实现的。宏的显著特征是名称末尾带有感叹号 <code>!</code>。</p>
<h3 id="1-核心宏"><a class="header" href="#1-核心宏">1. 核心宏</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>宏名称</strong></th><th><strong>功能描述</strong></th></tr>
</thead>
<tbody>
<tr><td><strong><code>print!</code></strong></td><td>打印到标准输出，不换行。</td></tr>
<tr><td><strong><code>println!</code></strong></td><td>打印到标准输出，<strong>自动换行</strong> 。</td></tr>
<tr><td><strong><code>format!</code></strong></td><td>不打印，而是返回一个格式化后的 <code>String</code>。</td></tr>
<tr><td><strong><code>eprintln!</code></strong></td><td>打印到<strong>标准错误输出 (stderr)</strong> ，常用于打印错误信息。</td></tr>
</tbody>
</table>
</div>
<h3 id="2-占位符"><a class="header" href="#2-占位符">2. 占位符</a></h3>
<h4 id="参数位置与命名"><a class="header" href="#参数位置与命名">参数位置与命名</a></h4>
<p>除了按顺序匹配，你还可以通过索引或名称来复用变量。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let name = "Alice";
    let age = 30;

    // 按顺序匹配
    println!("{} is {} years old.", name, age); // Alice is 30 years old.

    // 索引匹配
    println!("{0} is {1} years old.", name, age); // Alice is 30 years old.

    // 具名匹配
    println!("{name} is {age} years old."); // Alice is 30 years old.
}</code></pre>
<h4 id="格式化占位符核心语法"><a class="header" href="#格式化占位符核心语法">格式化占位符核心语法</a></h4>
<p>下表总结了占位符 <code>{}</code> 内部可以使用的所有核心语法：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>类别</th><th>语法示例</th><th>效果描述</th><th>42或“Hi“为例</th></tr>
</thead>
<tbody>
<tr><td><strong>基础展示</strong></td><td><code>{}</code></td><td>调用 <code>Display</code> 特征，普通人类可读输出。</td><td><code>42</code></td></tr>
<tr><td></td><td><code>{:?}</code></td><td>调用 <code>Debug</code> 特征，程序员调试用输出。</td><td><code>42</code></td></tr>
<tr><td></td><td><code>{:#?}</code></td><td><strong>漂亮打印 (Pretty Print)</strong>，多行缩进展示复杂结构。</td><td>(分行显示的结构)</td></tr>
<tr><td><strong>参数索引</strong></td><td><code>{0}</code></td><td>使用第 1 个位置参数（索引从 0 开始）。</td><td><code>42</code></td></tr>
<tr><td></td><td><code>{name}</code></td><td>使用具名参数。</td><td><code>Hi</code></td></tr>
<tr><td><strong>对齐与填充</strong></td><td><code>{:10}</code></td><td>设置宽度为 10，默认左对齐（字符串）或右对齐（数字）。</td><td><code>"Hi        "</code></td></tr>
<tr><td></td><td><code>{:&lt;10}</code></td><td>强制<strong>左对齐</strong>。</td><td><code>"Hi        "</code></td></tr>
<tr><td></td><td><code>{:&gt;10}</code></td><td>强制<strong>右对齐</strong>。</td><td><code>"        Hi"</code></td></tr>
<tr><td></td><td><code>{:^10}</code></td><td>强制<strong>居中对齐</strong>。</td><td><code>"    Hi    "</code></td></tr>
<tr><td></td><td><code>{:*^10}</code></td><td>使用 <code>*</code> 进行填充（填充字符必须在对齐符号前）。</td><td><code>"****Hi****"</code></td></tr>
<tr><td><strong>数字进制</strong></td><td><code>{:b}</code></td><td>转换为二进制 (Binary)。</td><td><code>101010</code></td></tr>
<tr><td></td><td><code>{:o}</code></td><td>转换为八进制 (Octal)。</td><td><code>52</code></td></tr>
<tr><td></td><td><code>{:x}</code> / <code>{:X}</code></td><td>转换为十六进制 (Hex)，大小写决定字母大小写。</td><td><code>2a</code> / <code>2A</code></td></tr>
<tr><td></td><td><code>{:#x}</code></td><td>带有进制前缀的十六进制。</td><td><code>0x2a</code></td></tr>
<tr><td><strong>精度与正负</strong></td><td><code>{:.2}</code></td><td>浮点数保留 2 位小数。</td><td><code>3.14</code></td></tr>
<tr><td></td><td><code>{:+.2}</code></td><td>强制显示正负号。</td><td><code>+42.00</code></td></tr>
<tr><td></td><td><code>{:05}</code></td><td>宽度为 5，不足部分用 <strong>0 填充</strong>。</td><td><code>00042</code></td></tr>
<tr><td><strong>特殊指针</strong></td><td><code>{:p}</code></td><td><strong>打印内存地址</strong>（适用于引用或原生指针）。</td><td><code>0x7ffee1234567</code></td></tr>
<tr><td><strong>转义</strong></td><td><code>{{</code> / <code>}}</code></td><td>在格式化字符串中显示原始的大括号。</td><td><code>{</code> / <code>}</code></td></tr>
</tbody>
</table>
</div>
<p>为了更直观地理解如何组合这些选项，请看下面的综合实例：</p>
<pre class="playground"><code class="language-rust editable edition2024">use std::mem::size_of;

#[derive(Debug)]
struct Point { x: i32, y: i32 }

fn main() {
    let p = Point { x: 10, y: 20 };
    let pi = 3.14159;
    // 1. 组合：宽度、对齐、填充、精度
    // 效果：居中对齐，宽度10，用'-'填充，保留2位小数
    println!("数值展示: {:*^10.2}", pi); 

    // 2. 指针地址展示
    // 使用 :p 查看变量在栈上的地址
    let r = &amp;p;
    println!("结构体 p 的地址: {:p}", r); 

    // 3. 进制与前缀
    let val = 255;
    println!("十六进制: {:#X}, 二进制: {:b}", val, val);

    // 4. 调试复杂结构
    // 使用 {:#?} 实现易读的缩进输出
    println!("漂亮打印结构体: {:#?}", p);
}</code></pre>
<h4 id="-核心知识点补充"><a class="header" href="#-核心知识点补充">💡 核心知识点补充</a></h4>
<ul>
<li>**<code>Debug</code> vs <code>Display**</code>：几乎所有的 Rust 标准库类型都实现了 <code>Debug</code>（用于调试），但并非都实现了 <code>Display</code>（因为某些类型没有唯一的人类可读展示方式）。</li>
<li><strong>指针长度</strong>：在 64 位系统上，使用 <code>{:p}</code> 打印出的地址通常对应一个 8 字节（单字长）的内存位置。</li>
<li><strong>内存效率</strong>：所有的 <code>print!</code> 系列宏在编译时都会被检查。如果占位符数量与参数不匹配，编译器会直接报错，这保证了运行时的类型安全。</li>
</ul>
<h4 id="结构化调试打印"><a class="header" href="#结构化调试打印">结构化调试打印</a></h4>
<ul>
<li><strong>派生 Debug</strong>： 使用 <code>#[derive(Debug)]</code> 注解结构体或枚举，自动生成 Debug 实现。
<ul>
<li><strong><code>{:?}</code></strong> ：以调试模式打印（需要类型实现 <code>std::fmt::Debug</code>）。</li>
<li><strong><code>{:#?}</code></strong> ： <strong>美化打印</strong> ，会自动分行并添加缩进，适合查看大型结构体。</li>
</ul>
</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect = Rectangle { width: 30, height: 50 };
    println!("rect 是 {:?}", rect);  // 输出: rect 是 Rectangle { width: 30, height: 50 }
    println!("rect 是 {:#?}", rect);  // 美化输出，多行缩进
}</code></pre>
<ul>
<li><strong>手动实现 Debug</strong>： 如果需要自定义格式，实现 std::fmt::Debug trait</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">use std::fmt;
struct Point {
    x: i32,
    y: i32,
}
impl fmt::Debug for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        f.debug_struct("Point")
         .field("x", &amp;self.x)
         .field("y", &amp;self.y)
         .finish()
    }
}
fn main() {
    let p = Point { x: 1, y: 2 };
    println!("{:?}", p);  // 输出: Point { x: 1, y: 2 }
}</code></pre>
<ul>
<li><strong>Debug vs Display</strong>：
<ul>
<li>Debug：用于开发者，格式如 { x: 1, y: 2 }，通过 {:?}。</li>
<li>Display：用于用户友好输出，通过 {}。需手动实现 std::fmt::Display。</li>
</ul>
</li>
</ul>
<pre><code class="language-rust ignore">impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
println!("{}", p);  // 输出: (1, 2)</code></pre>
<hr>
<h2 id="3-dbg宏"><a class="header" href="#3-dbg宏">3. dbg宏</a></h2>
<p>dbg! 宏用于调试，它打印表达式的值和源代码位置，然后返回该值。适合插入代码中快速检查，而不中断流程。</p>
<ul>
<li><strong>语法</strong>：
<ul>
<li><strong>dbg!(表达式);</strong>：打印表达式的文件名、行号、列号和值，返回表达式本身。</li>
<li>支持借用（&amp;），避免所有权转移。</li>
</ul>
</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">#[derive(Debug)] // 使用 dbg! 要求类型必须实现 Debug 特征
struct Rectangle {
    width: u32,
    height: u32,
}
fn main() {
    let rect = Rectangle { width: 30, height: 50 };
    // 1. println! 的方式：必须单独写一行，且需要手动写描述
    println!("矩形的数据是: {:?}", rect); 
    // 2. dbg! 的方式：直接包裹表达式
    // 它会打印：[src\main.rs:12:5] rect = Rectangle { width: 30, height: 50 }
    dbg!(&amp;rect); 
    // 3. 嵌套使用（逻辑不中断）
    let area = dbg!(rect.width * rect.height); // 打印计算过程并把结果赋给 area
    println!("面积是: {}", area);
}</code></pre>
<ul>
<li>
<p><strong>与结构体结合</strong>： dbg! 使用 Debug trait，如果结构体未实现 Debug，会编译错误。</p>
</li>
<li>
<p><strong>注意</strong>：dbg! 只在调试构建中有效，在发布模式下可能被优化掉。输出到 stderr，便于区分正常输出。</p>
</li>
</ul>
<h3 id="dbg-与-println-的详细对比"><a class="header" href="#dbg-与-println-的详细对比"><code>dbg!</code> 与 <code>println!</code> 的详细对比</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>特性</th><th><code>println!</code></th><th><code>dbg!</code></th></tr>
</thead>
<tbody>
<tr><td><strong>输出目标</strong></td><td>标准输出 (stdout)</td><td><strong>标准错误 (stderr)</strong></td></tr>
<tr><td><strong>占位符要求</strong></td><td>必须手动写 <code>{}</code> 或 <code>{:?}</code></td><td><strong>自动调用 <code>{:?}</code></strong></td></tr>
<tr><td><strong>信息量</strong></td><td>仅打印你指定的内容</td><td>自动包含<strong>文件名、行号、表达式</strong></td></tr>
<tr><td><strong>返回值</strong></td><td>返回单元类型 <code>()</code></td><td><strong>返回表达式的值（所有权转移）</strong></td></tr>
<tr><td><strong>典型用途</strong></td><td>最终程序输出给用户看</td><td><strong>开发过程中快速排查问题</strong></td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="所有权和借用"><a class="header" href="#所有权和借用">所有权和借用</a></h1>
<p>所有权（Ownership）是 Rust 最为独特且核心的特性。它让 Rust 能够脱离垃圾回收（GC）机制，在编译期即确保内存安全。</p>
<hr>
<h2 id="一-内存管理的三大流派"><a class="header" href="#一-内存管理的三大流派">一、 内存管理的三大流派</a></h2>
<p>在计算机科学中，管理内存通常有三种方式：</p>
<ol>
<li><strong>垃圾回收 (GC)</strong> ：如 Java、Go、Python。程序运行时自动寻找不再使用的内存。优点是开发快，缺点是运行时开销大，可能出现“停顿”。</li>
<li><strong>手动管理</strong> ：如 C/C++。程序员手动调用 <code>malloc/free</code>。优点是极致性能，缺点是极其容易出现 <strong>悬空指针</strong> 、<strong>双重释放</strong>或 <strong>内存泄漏</strong> 。</li>
<li><strong>所有权系统</strong> ：Rust 的路径。通过编译器在编译时根据一套规则检查内存管理。 <strong>零运行时开销</strong> 。</li>
</ol>
<h3 id="预备知识栈-stack-与-堆-heap"><a class="header" href="#预备知识栈-stack-与-堆-heap">预备知识：栈 (Stack) 与 堆 (Heap)</a></h3>
<h4 id="栈"><a class="header" href="#栈">栈</a></h4>
<p>栈按照顺序存储值并以相反顺序取出值，这也被称作 <strong>后进先出</strong> 。想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，再从顶部拿走。不能从中间也不能从底部增加或拿走盘子！</p>
<p>增加数据叫做 <strong>进栈</strong> ，移出数据则叫做 <strong>出栈</strong> 。</p>
<p>因为上述的实现方式，栈中的所有数据都必须占用已知且固定大小的内存空间，假设数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据。</p>
<h4 id="堆"><a class="header" href="#堆">堆</a></h4>
<p>与栈不同，对于大小未知或者可能变化的数据，我们需要将它存储在堆上。</p>
<p>当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 <strong>指针</strong> ，该过程被称为 <strong>在堆上分配内存</strong> ，有时简称为 “分配”(allocating)。</p>
<p>接着，该指针会被推入<strong>栈</strong>中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的 <strong>指针</strong> ，来获取数据在堆上的实际内存位置，进而访问该数据。</p>
<p>由上可知，堆是一种缺乏组织的数据结构。想象一下去餐馆就座吃饭：进入餐馆，告知服务员有几个人，然后服务员找到一个够大的空桌子（堆上分配的内存空间）并领你们过去。如果有人来迟了，他们也可以通过桌号（栈上的指针）来找到你们坐在哪。</p>
<h4 id="性能区别"><a class="header" href="#性能区别">性能区别</a></h4>
<p>在栈上分配内存比在堆上分配内存要快，因为入栈时操作系统无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。 因此，处理器在栈上分配数据会比在堆上分配数据更加高效。</p>
<h4 id="所有权与堆栈"><a class="header" href="#所有权与堆栈">所有权与堆栈</a></h4>
<p>当你的代码调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。</p>
<p>因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收。这就是 Rust 所有权系统为我们提供的强大保障。</p>
<p>对于其他很多编程语言，你确实无需理解堆栈的原理，但是 <strong>在 Rust 中，明白堆栈的原理，对于我们理解所有权的工作原理会有很大的帮助</strong> 。</p>
<hr>
<h2 id="二-所有权"><a class="header" href="#二-所有权">二、 所有权</a></h2>
<ul>
<li><strong>什么是所有权？</strong> ：每个值都有一个“所有者”（owner），负责在值超出作用域时释放它。Rust 使用所有权来管理堆内存，而不依赖垃圾回收器。</li>
<li><strong>为什么重要？</strong> ：防止双重释放（double free）、使用后释放（use after free）和数据竞争。</li>
<li><strong>三条铁律构建</strong> ：</li>
</ul>
<h3 id="每一个值都有一个变量称为它的所有者"><a class="header" href="#每一个值都有一个变量称为它的所有者">每一个值都有一个变量，称为它的“所有者”</a></h3>
<p>在 Rust 中，内存中的数据（值）不能孤立存在，必须绑定到一个变量上。</p>
<pre class="playground"><code class="language-rust edition">fn main() {
    // 这个 String 字符串值在堆上创建
    // 变量 s 成了这个字符串的“所有者”
    let s = String::from("hello"); 

    println!("s 拥有这个值: {}", s);
} // 函数结束，s 超出作用域，值被丢弃</code></pre>
<h3 id="同一时间内一个值只能有一个所有者"><a class="header" href="#同一时间内一个值只能有一个所有者">同一时间内，一个值只能有一个所有者</a></h3>
<p>这是 Rust 安全性的核心。如果一个堆上的值有两个所有者，就会发生“二次释放”内存错误。因此，Rust 强制执行所有权移动（Move）。</p>
<pre class="playground"><code class="language-rust edition">fn main() {
    let s1 = String::from("hello");
    
    // 所有权从 s1 转移到了 s2
    // 此时内存中仍然只有一个 "hello"，但所有者变成了 s2
    let s2 = s1; 

    // println!("{}", s1); 
    // ❌ 编译报错！s1 不再拥有该值，它已经“失效”了。
    
    println!("现在所有权在 s2 手里: {}", s2); 
}</code></pre>
<h3 id="当所有者超出作用域时该值将被丢弃drop"><a class="header" href="#当所有者超出作用域时该值将被丢弃drop">当所有者超出作用域时，该值将被丢弃（<code>drop</code>）</a></h3>
<p>Rust 自动管理内存的秘诀就在这里：通过大括号 {} 定义作用域，一旦走出大括号，变量就会被销毁，内存立即回收。</p>
<pre class="playground"><code class="language-rust edition">fn main() {
    {
        // s 从这里开始有效
        let s = String::from("hello"); 
        println!("作用域内: {}", s);
    } 
    // 💡 执行到这里，作用域结束。
    // Rust 自动调用 `drop` 函数，释放 s 占用的堆内存。

    // println!("{}", s); 
    // ❌ 编译报错！s 已经不在这里了，内存已经还给系统了。
}</code></pre>
<hr>
<h2 id="三-变量交互移动克隆与复制"><a class="header" href="#三-变量交互移动克隆与复制">三、 变量交互：移动、克隆与复制</a></h2>
<h3 id="1-移动-move"><a class="header" href="#1-移动-move">1. 移动 (Move)</a></h3>
<p>对于存储在堆上的复杂类型（如 <code>String</code>），赋值操作默认是“移动”。为了防止 <strong>双重释放</strong> ，Rust 会使原变量失效。</p>
<pre class="playground"><code class="language-rust edition">fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // 所有权移动到了 s2，s1 此时已失效

    // println!("{s1}"); // ❌ 编译错误：使用了已移动的值
    println!("{s2}");    // ✅ 有效
}</code></pre>
<h3 id="2-克隆-clone--深拷贝"><a class="header" href="#2-克隆-clone--深拷贝">2. 克隆 (Clone) —— 深拷贝</a></h3>
<p>如果你确实需要复制堆上的数据，必须显式调用 <code>clone</code>。</p>
<pre class="playground"><code class="language-rust edition">fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone(); // 在堆上产生了一份完整副本

    println!("s1 = {s1}, s2 = {s2}"); // ✅ 两者均有效
}</code></pre>
<h3 id="3-复制-copy--栈数据拷贝"><a class="header" href="#3-复制-copy--栈数据拷贝">3. 复制 (Copy) —— 栈数据拷贝</a></h3>
<p>对于简单、固定大小且完全存储在栈上的类型，Rust 会执行自动拷贝，而不会使原变量失效。常见的 <code>Copy</code> 类型包括：所有的整数、浮点数、布尔值、字符，以及只包含这些类型的元组。</p>
<pre class="playground"><code class="language-rust edition">fn main() {
    let x = 5;
    let y = x; // 栈数据直接拷贝，不涉及所有权转移
    println!("x = {x}, y = {y}"); // ✅ 两者均有效
}</code></pre>
<hr>
<h2 id="四-引用与借用-references--borrowing"><a class="header" href="#四-引用与借用-references--borrowing">四、 引用与借用 (References &amp; Borrowing)</a></h2>
<p>如果你不想转移所有权，但又想使用数据，就需要“借用”。引用（<code>&amp;</code>）就像是现实中的借书：你可以看书，但书不属于你，看完得还。</p>
<h3 id="1-不可变借用-t"><a class="header" href="#1-不可变借用-t">1. 不可变借用 (<code>&amp;T</code>)</a></h3>
<p>你可以同时拥有多个不可变引用，因为“只读”不会引起数据竞争。</p>
<pre class="playground"><code class="language-rust edition">fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
} // s 离开作用域，但因为它只是引用，所以不会发生 drop

fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&amp;s1); // 传入引用
    println!("'{s1}' 的长度是 {len}"); // ✅ s1 依然有效
}</code></pre>
<h3 id="2-可变借用-mut-t"><a class="header" href="#2-可变借用-mut-t">2. 可变借用 (<code>&amp;mut T</code>)</a></h3>
<p>如果你需要修改借用的数据，必须使用可变引用。但它有极强的限制：<strong>在同一作用域内，特定数据只能有一个可变引用。</strong></p>
<pre class="playground"><code class="language-rust edition">fn change(some_string: &amp;mut String) {
    some_string.push_str(", world");
}

fn main() {
    let mut s = String::from("hello");
    change(&amp;mut s);
    println!("{s}");
}</code></pre>
<h3 id="3-借用规则总结"><a class="header" href="#3-借用规则总结">3. 借用规则总结</a></h3>
<p>为了彻底消除 <strong>数据竞争</strong> ，Rust 强制执行以下规则：</p>
<ul>
<li><strong>在任何给定时间，你要么只能有一个可变引用，要么可以有任意数量的不可变引用。</strong></li>
<li><strong>引用必须始终有效（防止悬垂引用）。</strong></li>
</ul>
<hr>
<h2 id="五-nll更智能的借用检查"><a class="header" href="#五-nll更智能的借用检查">五、 NLL：更智能的借用检查</a></h2>
<p>在旧版 Rust 中，引用的作用域持续到大括号结束。现代 Rust 使用了  <strong>NLL (Non-Lexical Lifetimes)</strong> ，引用的作用域在<strong>最后一次使用</strong>处结束。这解决了许多“本该通过但没通过”的编译问题。</p>
<pre class="playground"><code class="language-rust edition">fn main() {
    let mut s = String::from("hello");

    let r1 = &amp;s; 
    let r2 = &amp;s;
    println!("{r1} and {r2}"); 
    // r1 和 r2 在此处之后不再使用，其作用域结束

    let r3 = &amp;mut s; // ✅ 允许，因为之前的不可变借用已失效
    println!("{r3}");
}</code></pre>
<hr>
<h2 id="六-悬垂引用-dangling-references"><a class="header" href="#六-悬垂引用-dangling-references">六、 悬垂引用 (Dangling References)</a></h2>
<p>Rust 会在编译期阻止你返回局部变量的引用，因为局部变量在函数结束时会被释放。</p>
<pre class="playground"><code class="language-rust edition">// ❌ 无法通过编译
// fn dangle() -&gt; &amp;String {
//     let s = String::from("hello");
//     &amp;s // 返回了对局部变量 s 的引用
// } 

// ✅ 正确做法：直接返回 String (移动所有权)
fn no_dangle() -&gt; String {
    let s = String::from("hello");
    s 
}

fn main() {
    let s = no_dangle();
}</code></pre>
<hr>
<h2 id="七-自动释放drop-与-raii"><a class="header" href="#七-自动释放drop-与-raii">七、 自动释放：Drop 与 RAII</a></h2>
<p>Rust 通过 <code>Drop</code> trait 实现  <strong>RAII (资源获取即初始化)</strong> 。当变量超出作用域时，Rust 自动调用 <code>drop</code> 方法释放堆内存。</p>
<pre class="playground"><code class="language-rust edition">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!("正在清理数据: `{}`", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer { data: String::from("my stuff") };
    let d = CustomSmartPointer { data: String::from("other stuff") };
    println!("CustomSmartPointers 已创建。");
} // 此处 d 先被 drop，然后 c 被 drop</code></pre>
<hr>
<h3 id="如何写出符合所有权的代码"><a class="header" href="#如何写出符合所有权的代码">如何写出符合所有权的代码？</a></h3>
<ol>
<li><strong>优先借用</strong> ：除非你确实需要获取数据的所有权（例如要把数据存入结构体中），否则优先使用引用 <code>&amp;T</code>。</li>
<li><strong>减少 Clone</strong> ：如果发现代码里到处是 <code>.clone()</code>，通常说明所有权设计有误。</li>
<li><strong>利用作用域</strong> ：可以通过手动添加 <code>{ }</code> 来缩短变量或引用的生命周期，从而解决借用冲突。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="语句与表达式"><a class="header" href="#语句与表达式">语句与表达式</a></h1>
<p>在 Rust 的设计哲学中，<strong>一切皆表达式</strong>是一个核心概念。理解<strong>语句Statements</strong> 与 <strong>表达式Expressions</strong>的区别，是掌握 Rust 函数返回值、控制流赋值以及函数式编程风格的关键。</p>
<hr>
<h2 id="一基本定义"><a class="header" href="#一基本定义">一、基本定义</a></h2>
<h3 id="1-语句-statements"><a class="header" href="#1-语句-statements">1. 语句 (Statements)</a></h3>
<p>语句是<strong>执行某种操作但不返回值</strong>的指令。</p>
<ul>
<li>在 Rust 中，最常见的语句是变量声明 <code>let x = 5;</code>。</li>
<li>语句通常以分号 <code>;</code> 结尾。</li>
<li><strong>注意</strong> ：因为语句不返回值，所以你不能把 <code>let</code> 语句赋值给另一个变量（例如 <code>let x = (let y = 5);</code> 会报错）。</li>
</ul>
<h3 id="2-表达式-expressions"><a class="header" href="#2-表达式-expressions">2. 表达式 (Expressions)</a></h3>
<p>表达式会计算并产生一个 <strong>值</strong> 。</p>
<ul>
<li>数学运算（如 <code>5 + 6</code>）、函数调用、宏调用都是表达式。</li>
<li>甚至大括号包裹的代码块 <code>{}</code> 也是表达式。</li>
<li><strong>核心规则</strong> ：表达式的结尾 <strong>没有分号</strong> 。如果你在表达式末尾加上分号，它就会变成一条语句，返回值会变成单元类型 <code>()</code>。</li>
</ul>
<hr>
<h2 id="二块表达式-block-expressions"><a class="header" href="#二块表达式-block-expressions">二、块表达式 (Block Expressions)</a></h2>
<p>在 Rust 中，我们可以使用 <code>{}</code> 创建一个作用域，这个作用域本身就是一个表达式，它的值是其中<strong>最后一行表达式</strong>的值。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let y = {
        let x = 3;
        x + 1  // 注意：这里没有分号！
    };

    println!("y 的值是: {y}"); // 输出 4
}</code></pre>
<blockquote>
<p>深度解析：</p>
<p>如果你在 x + 1 后面加了分号，变成 x + 1;，那么这个块就不再返回 4，而是返回 ()（unit 类型），编译器会因此报错（如果 y 预期是整数类型的话）。</p>
</blockquote>
<hr>
<h2 id="三函数中的应用隐式返回"><a class="header" href="#三函数中的应用隐式返回">三、函数中的应用：隐式返回</a></h2>
<p>Rust 函数不需要显式写 <code>return</code> 关键字来返回值。只要函数体的最后一行是一个 <strong>表达式</strong> （没有分号），该表达式的值就会自动作为函数的返回值。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn add_one(x: i32) -&gt; i32 {
    x + 1 // 这是一个表达式，隐式返回其结果
}

fn main() {
    let result = add_one(10);
    println!("结果是: {result}");
}</code></pre>
<p><strong>显式 return 与隐式返回的区别：</strong></p>
<ul>
<li><strong>隐式返回</strong> （不带 <code>return</code> 和分号）：Rust 推荐的标准写法，代码更简洁。</li>
<li><strong>显式 return</strong> ：通常用于函数中途提前退出（提前返回）。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn check_number(n: i32) -&gt; String {
    if n &lt; 0 {
        return String::from("错误：负数"); // 提前退出
    }
  
    String::from("正常") // 隐式返回
}
fn main() {
    let result = check_number(-10);
    println!("检查结果: {result}");
}</code></pre>
<hr>
<h2 id="四常见陷阱分号的影响"><a class="header" href="#四常见陷阱分号的影响">四、常见陷阱：分号的影响</a></h2>
<p>分号在 Rust 中不仅仅是结束符，它是 <strong>类型的转换器</strong> 。它将一个“有值”的表达式转换成一个“无值”的语句。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>示例</strong></th><th><strong>类别</strong></th><th><strong>结果/值</strong></th></tr>
</thead>
<tbody>
<tr><td><code>5 + 6</code></td><td>表达式</td><td><code>11</code></td></tr>
<tr><td><code>5 + 6;</code></td><td>语句</td><td><code>()</code>(Unit)</td></tr>
<tr><td><code>let x = 5;</code></td><td>语句</td><td>无值（报错不能被赋值）</td></tr>
<tr><td><code>if true { 1 } else { 0 }</code></td><td>表达式</td><td><code>1</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="五综合示例在一个函数中观察"><a class="header" href="#五综合示例在一个函数中观察">五、综合示例：在一个函数中观察</a></h2>
<p>下面的代码展示了如何在实际逻辑中混合使用语句和表达式：</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 5;

    // 一个复杂的赋值表达式
    let result = if x &gt; 0 {
        let temp = x * 2; // 语句
        temp + 10         // 表达式：整个 if 块的值变为 20
    } else {
        0                 // 表达式
    };

    println!("最终计算结果: {result}");

    // 调用一个只有语句的函数
    print_unit();
}

// 该函数没有返回值，或者说隐式返回 ()
fn print_unit() {
    println!("我执行了一些操作，但我返回的是单元类型 ()");
    // 这里其实隐藏了一个没有分号的 ()
}</code></pre>
<hr>
<h2 id="六操作符优先级"><a class="header" href="#六操作符优先级">六、操作符优先级</a></h2>
<p>在Rust中，一切皆表达式，那么了解表达式的优先级就非常重要了，将Rust的操作符和表达式按优先级由高到低的顺序列了出来，具有相同优先级的操作符按相关性给定的顺序进行优先级计算。</p>
<img src="images/操作符优先级.png" alt="操作符优先级" style="zoom:70%;" />
<h3 id="总结对比"><a class="header" href="#总结对比">总结对比</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>特性</strong></th><th><strong>语句 (Statements)</strong></th><th><strong>表达式 (Expressions)</strong></th></tr>
</thead>
<tbody>
<tr><td><strong>是否有分号</strong></td><td><strong>是</strong> （通常以 <code>;</code>结尾）</td><td><strong>否</strong> （末尾无 <code>;</code>）</td></tr>
<tr><td><strong>是否有返回值</strong></td><td><strong>否</strong> （返回 <code>()</code>）</td><td><strong>是</strong></td></tr>
<tr><td><strong>典型例子</strong></td><td><code>let x = 5;</code></td><td><code>x + 5</code>/<code>my_func()</code></td></tr>
<tr><td><strong>函数末尾</strong></td><td>不会作为返回值</td><td><strong>会自动作为返回值</strong></td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="条件语句"><a class="header" href="#条件语句">条件语句</a></h1>
<p>在 Rust 中，控制流和模式匹配不仅仅是逻辑的分叉口，它们更是安全性的守护者。Rust 编译器通过严格的类型检查和“穷尽性检查”，确保你在处理各种逻辑情况时不会留下漏洞。</p>
<p>以下是整理的 Rust 控制流、循环流与 <code>match</code> 表达式的详细指南。</p>
<hr>
<h2 id="一控制流conditional-control-flow"><a class="header" href="#一控制流conditional-control-flow">一、控制流（Conditional Control Flow）</a></h2>
<p>控制流是程序根据特定条件执行不同代码的能力。Rust 的 <code>if</code> 分支结构非常严谨。</p>
<h3 id="1-if--else-if--else"><a class="header" href="#1-if--else-if--else">1. <code>if / else if / else</code></a></h3>
<p>Rust 要求条件表达式必须是严格的 <code>bool</code> 类型。这意味着你不能像在 C 或 JavaScript 中那样使用数字（如 <code>if (1)</code>）来代表逻辑真。这种设计避免了因隐式类型转换导致的逻辑错误。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 10;

    if x &gt; 0 {
        println!("positive");
    } else if x == 0 {
        println!("zero");
    } else {
        println!("negative");
    }
}</code></pre>
<h3 id="2-if-是表达式可以返回值"><a class="header" href="#2-if-是表达式可以返回值">2. <code>if</code> 是表达式：可以返回值</a></h3>
<p>在 Rust 中，if 是一个表达式而不是语句。这意味着它可以产生一个值，并将其直接赋值给变量。</p>
<p><strong>注意：所有分支返回的数据类型必须完全一致，且分支末尾不要写分号，否则该分支会返回单元类型 ()。</strong></p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 7;
    // if 表达式赋值
    let y = if x % 2 == 0 { 100 } else { 200 };
    // let y = if x % 2 == 0 { 100 } else { 200; };
    println!("y 的值是: {y}"); // 输出 200
}</code></pre>
<h3 id="3-if-let只关心某一种模式"><a class="header" href="#3-if-let只关心某一种模式">3. <code>if let</code>：只关心某一种模式</a></h3>
<p>当你只想处理某一种特定的模式（例如 <code>Option</code> 中的 <code>Some</code>），而对其他情况（如 <code>None</code>）不感兴趣时，<code>if let</code> 是比 <code>match</code> 更简洁的选择。它减少了样板代码的编写。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v: Option&lt;i32&gt; = Some(10);

    // 只解构 Some，忽略 None
    if let Some(n) = v {
        println!("解构成功，n = {n}");
    } else {
        println!("这里是 None 的情况");
    }
}</code></pre>
<h3 id="4-let-else模式不匹配就提前退出"><a class="header" href="#4-let-else模式不匹配就提前退出">4. <code>let else</code>：模式不匹配就提前退出</a></h3>
<p>这是 Rust 1.65 引入的新语法，非常适合编写“守护语句（Guard Statement）”。如果在解构时失败，必须在 <code>else</code> 块中通过 <code>return</code>、<code>break</code> 或 <code>panic!</code> 强制退出当前作用域。这使得后续代码可以放心地使用解构出来的变量。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn parse_first(v: Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    // 如果无法获取第一个元素，直接返回 None
    let Some(first) = v.get(0) else {
        return None; 
    };
    // 此时 first 已经成功绑定，且作用域在外面
    Some(*first)
}

fn main() {
    let numbers = vec![1, 2, 3];
    if let Some(val) = parse_first(numbers) {
        println!("第一个值是: {val}");
    }
}</code></pre>
<hr>
<h2 id="二循环流looping-control-flow"><a class="header" href="#二循环流looping-control-flow">二、循环流（Looping Control Flow）</a></h2>
<p>Rust 提供了三种循环原语，它们在底层性能上是一致的，但在语义表达上各有侧重。</p>
<h3 id="1-loop无限循环--break-返回值"><a class="header" href="#1-loop无限循环--break-返回值">1. <code>loop</code>：无限循环 + <code>break</code> 返回值</a></h3>
<p><code>loop</code> 常用于需要反复执行直到满足某个条件（如轮询任务或重试逻辑）的场景。由于 <code>loop</code> 保证一定会运行（直到被 break），它也可以作为表达式返回一个值。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut n = 0;

    let result = loop {
        n += 1;
        if n == 5 {
            break n * 2; // 带值跳出循环
        }
    };

    println!("结果是: {result}"); // 10
}</code></pre>
<h3 id="2-while条件循环"><a class="header" href="#2-while条件循环">2. <code>while</code>：条件循环</a></h3>
<p>这是最传统的循环方式，每次迭代开始前都会检查条件。适合处理那些依赖外部状态变化的逻辑。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut n = 3;
    while n &gt; 0 {
        println!("{n}...");
        n -= 1;
    }
    println!("发射！");
}</code></pre>
<h3 id="3-for遍历迭代器最常用"><a class="header" href="#3-for遍历迭代器最常用">3. <code>for</code>：遍历迭代器（最常用）</a></h3>
<p><code>for</code> 循环通过迭代器工作，是 Rust 中最安全的选择，因为它不会出现索引越界（Out of Bounds）的问题。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>使用方法</th><th>等价使用方式</th><th>所有权</th></tr>
</thead>
<tbody>
<tr><td><code>for item in collection</code></td><td><code>for item in IntoIterator::into_iter(collection)</code></td><td>转移所有权</td></tr>
<tr><td><code>for item in &amp;collection</code></td><td><code>for item in collection.iter()</code></td><td>不可变借用</td></tr>
<tr><td><code>for item in &amp;mut collection</code></td><td><code>for item in collection.iter_mut()</code></td><td>可变借用</td></tr>
</tbody>
</table>
</div>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    // 1. 范围遍历
    for i in 0..3 { println!("范围 A: {i}"); }    // 0, 1, 2
    for i in 0..=3 { println!("范围 B: {i}"); }   // 0, 1, 2, 3

    // 2. 遍历集合（借用与移动）
    let v = vec![10, 20, 30];
    for x in &amp;v { println!("借用元素: {x}"); }    // v 依然可用

    // 3. 可变借用遍历
    let mut nums = vec![1, 2, 3];
    for x in &amp;mut nums {
        *x *= 10; // 修改原始数据
    }

    // 4. 带索引遍历
    for (i, val) in nums.iter().enumerate() {
        println!("索引 {i} 的值是 {val}");
    }
}</code></pre>
<h3 id="4-循环控制与标签"><a class="header" href="#4-循环控制与标签">4. 循环控制与标签</a></h3>
<ul>
<li><code>continue</code>：结束当前迭代，立即开始下一次。</li>
<li><code>break</code>：立即退出当前循环。</li>
<li><strong>循环标签</strong> ：在处理多层嵌套循环时，你可以给循环起名字（以单引号开头），以便在内层直接退出外层, <strong>影响可读性</strong>。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    'outer: for i in 0..10 {
        'inner: for j in 0..10 {
            if i + j == 5 {
                println!("找到目标：i={}, j={}", i, j);
                break 'outer; // 跳出最外层循环
            }
        }
    }
}</code></pre>
<hr>
<h2 id="三match-表达式pattern-matching"><a class="header" href="#三match-表达式pattern-matching">三、<code>match</code> 表达式（Pattern Matching）</a></h2>
<p><code>match</code> 是 Rust 的“核心杀手锏”，它非常类似于多分支的 <code>switch</code>，但功能要强大得多。它强制要求 <strong>穷尽性检查</strong> ，即你必须处理所有可能的情况。</p>
<h3 id="1-基本用法与模式"><a class="header" href="#1-基本用法与模式">1. 基本用法与模式</a></h3>
<p><code>match</code> 的每个分支被称为一个“臂（Arm）”。<code>_</code> 是通配符，用于捕获所有未明确列出的情况。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let n = 3;
    match n {
        1 =&gt; println!("一"),
        2 =&gt; println!("二"),
        3 =&gt; println!("三"),
        _ =&gt; println!("其他数字"), // 必须有这一行，除非 n 的所有可能已被覆盖
    }
}</code></pre>
<h3 id="2-范围与多重匹配"><a class="header" href="#2-范围与多重匹配">2. 范围与多重匹配</a></h3>
<p>你可以使用 <code>|</code> 匹配多个值，或使用 <code>..=</code> 匹配一个闭区间。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let score = 85;
    match score {
        0..=59 =&gt; println!("不及格"),
        60..=80 =&gt; println!("合格"),
        81..=100 =&gt; println!("优秀"),
        _ =&gt; println!("无效分数"),
    }

    let day = 6;
    match day {
        1 | 2 | 3 | 4 | 5 =&gt; println!("工作日"),
        6 | 7 =&gt; println!("周末"),
        _ =&gt; println!("火星日?"),
    }
}</code></pre>
<h3 id="3-解构复合类型元组结构体枚举"><a class="header" href="#3-解构复合类型元组结构体枚举">3. 解构复合类型（元组/结构体/枚举）</a></h3>
<p><code>match</code> 最强大的地方在于它可以“拆解”数据结构。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct Point { x: i32, y: i32 }
enum Message { Quit, Write(String) }

fn main() {
    // 1. 解构元组
    let pair = (0, -2);
    match pair {
        (0, y) =&gt; println!("在 Y 轴上: {y}"),
        (x, 0) =&gt; println!("在 X 轴上: {x}"),
        _ =&gt; println!("在象限内"),
    }

    // 2. 解构结构体
    let p = Point { x: 10, y: 0 };
    match p {
        Point { x, y: 0 } =&gt; println!("X 轴上的点，x = {x}"),
        Point { x, y } =&gt; println!("普通点 ({x}, {y})"),
    }

    // 3. 解构枚举
    let msg = Message::Write(String::from("Hello"));
    match msg {
        Message::Quit =&gt; println!("退出"),
        Message::Write(s) =&gt; println!("消息内容: {s}"),
    }
}</code></pre>
<h3 id="4-进阶匹配守卫与--绑定"><a class="header" href="#4-进阶匹配守卫与--绑定">4. 进阶：匹配守卫与 <code>@</code> 绑定</a></h3>
<ul>
<li><strong>匹配守卫 (Match Guard)</strong> ：在模式匹配的基础上增加 <code>if</code> 条件，用于更细粒度的过滤。</li>
<li><strong><code>@</code> 绑定</strong> ：允许你在匹配一个值的同时，将其绑定到一个变量上，方便后续使用。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    // 匹配守卫
    let num = Some(10);
    match num {
        Some(x) if x &gt; 5 =&gt; println!("大于 5 的数字: {x}"),
        Some(x) =&gt; println!("普通数字: {x}"),
        None =&gt; (),
    }

    // @ 绑定
    let age = 7;
    match age {
        v @ 1..=12 =&gt; println!("小孩，年龄是: {v}"),
        v @ 13..=19 =&gt; println!("青少年，年龄是: {v}"),
        _ =&gt; println!("成年人"),
    }
}</code></pre>
<h3 id="5-核心应用option-和-result"><a class="header" href="#5-核心应用option-和-result">5. 核心应用：<code>Option</code> 和 <code>Result</code></a></h3>
<p>这是 <code>match</code> 在 Rust 中最高频的出现场景，用于安全地处理可能为空或可能出错的值。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let res: Result&lt;i32, &amp;str&gt; = Ok(200);
    match res {
        Ok(code) =&gt; println!("请求成功，状态码: {code}"),
        Err(msg) =&gt; println!("请求失败: {msg}"),
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="函数与闭包"><a class="header" href="#函数与闭包">函数与闭包</a></h1>
<h2 id="一-函数-functions"><a class="header" href="#一-函数-functions">一、 函数 (Functions)</a></h2>
<p>函数是 Rust 代码的静态骨架。它们必须在编译时拥有明确的签名。</p>
<h3 id="1-基础语法与显式返回"><a class="header" href="#1-基础语法与显式返回">1. 基础语法与显式返回</a></h3>
<p>Rust 的函数参数必须标注类型，返回类型使用 <code>-&gt;</code> 标注。</p>
<pre class="playground"><code class="language-rust editable edition2024">// 逻辑概括：参数必须显式注明类型，最后一行表达式作为返回值
fn calculate_score(points: i32, multiplier: i32) -&gt; i32 {
    if points &lt; 0 {
        return 0; // 使用 return 提前退出
    }
    points * multiplier // 隐式返回（无分号）
}
fn main() {
    let score = calculate_score(10, 3);
    println!("最终得分: {score}");
}</code></pre>
<h3 id="2-函数指针-fn-类型"><a class="header" href="#2-函数指针-fn-类型">2. 函数指针 (<code>fn</code> 类型)</a></h3>
<p>函数本身可以作为参数传递，也可以存储在变量中。它的类型是小写的 <code>fn</code>。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn add_one(x: i32) -&gt; i32 { x + 1 }

fn do_math(f: fn(i32) -&gt; i32, value: i32) -&gt; i32 {
    f(value)
}

fn main() {
    let result = do_math(add_one, 5);
    println!("函数指针调用结果: {result}"); // 6
}</code></pre>
<hr>
<h2 id="二-闭包-closures"><a class="header" href="#二-闭包-closures">二、 闭包 (Closures)</a></h2>
<p><code>Rust</code> 中的闭包（<code>closures</code>）是一种匿名函数，可以捕获其环境中的变量。闭包类似于其他语言中的 <code>lambda</code> 表达式，但 <code>Rust</code> 的闭包系统与所有权和借用紧密集成，确保内存安全。闭包可以作为函数参数、返回值，或存储在变量中，常用于迭代器、线程和回调。<code>Rust</code> 闭包实现了<code>Fn trait</code> 家族（<code>Fn、FnMut、FnOnce</code>），根据捕获方式决定其行为。最核心的特性是 <strong>捕获环境</strong> 。它们通常比函数更简洁，且支持类型推导。</p>
<h3 id="1-语法与自动推导"><a class="header" href="#1-语法与自动推导">1. 语法与自动推导</a></h3>
<p>闭包不强制写类型，编译器会根据第一次调用的上下文锁定类型。语法：<code>|params| expression</code> 或 <code>{ body }</code>。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    // 闭包标准语法
    let closure_annotated = |x: i32| -&gt; i32 { x + 1 };
  
    // 自动推导简写
    let closure_inferred = |x| x + 1;

    println!("{}", closure_annotated(1));
    println!("{}", closure_inferred(1));
}</code></pre>
<h3 id="2-捕获方式不可变可变移动"><a class="header" href="#2-捕获方式不可变可变移动">2. 捕获方式：不可变、可变、移动</a></h3>
<p>闭包通过三种方式从作用域捕获变量：</p>
<ul>
<li><strong>不可变借用 (<code>&amp;T</code>)</strong> ：默认方式。</li>
<li><strong>可变借用 (<code>&amp;mut T</code>)</strong> ：当闭包内部修改变量时。</li>
<li><strong>移动所有权 (<code>T</code>)</strong> ：使用 <code>move</code> 关键字，常用于异步或多线程。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 4;
    let equal_to_x = |z| z == x;  // 借用 x (&amp;x)
    println!("相等？{}", equal_to_x(4));  // 输出: 相等？true
    println!("x 仍有效: {}", x);  // x 未移动
    //可变借用
    let mut count = 0;
    let mut inc = || {
        count += 1; // 自动推导为 可变借用
        println!("当前计数: {count}");
    };
    inc();
    inc();
    // 强制移动所有权
    let text = String::from("hello");
    let print_text = move || println!("移动后的文本: {text}");
    print_text();
    // println!("{text}"); // ❌ 报错：text 已移动到闭包中
}</code></pre>
<hr>
<h2 id="三-闭包特征-fn-fnmut-fnonce"><a class="header" href="#三-闭包特征-fn-fnmut-fnonce">三、 闭包特征 (Fn, FnMut, FnOnce)</a></h2>
<p>当闭包作为参数传递时，我们需要使用这三个 Trait 来约束它：</p>
<ul>
<li><strong><code>FnOnce</code></strong> ：调用一次，消耗闭包（可能移动捕获）。</li>
<li><strong><code>FnMut</code></strong> ：可多次调用，可修改捕获。</li>
<li><strong><code>Fn</code></strong> ：可多次调用，只读捕获。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn run_once&lt;F&gt;(f: F) where F: FnOnce() {
    f();
}

fn main() {
    let s = String::from("once");
    let consume_s = || drop(s); // 该闭包消费了 s 的所有权
  
    run_once(consume_s);
    // run_once(consume_s); // ❌ 报错：闭包已被消费
}</code></pre>
<hr>
<h2 id="四-高级进阶函数与闭包作为返回值"><a class="header" href="#四-高级进阶函数与闭包作为返回值">四、 高级进阶：函数与闭包作为返回值</a></h2>
<p>这是 Rust 中最具灵活性的部分。由于闭包没有具体的名字，返回它们需要特殊的处理。</p>
<h3 id="1-返回普通函数指针-fn"><a class="header" href="#1-返回普通函数指针-fn">1. 返回普通函数指针 (<code>fn</code>)</a></h3>
<p>适用于逻辑固定、不捕获外部变量的情况。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn apply&lt;F&gt;(f: F, x: i32) -&gt; i32
where
    F: FnOnce(i32) -&gt; i32,  // bound FnOnce
{
    f(x)
}

fn main() {
    let double = |n| n * 2;
    println!("结果: {}", apply(double, 5));  // 输出: 结果: 10
}</code></pre>
<h3 id="2-返回闭包静态分发-impl-trait"><a class="header" href="#2-返回闭包静态分发-impl-trait">2. 返回闭包：静态分发 (<code>impl Trait</code>)</a></h3>
<p>这是返回闭包最常用的方式。它效率高（无堆分配），但要求所有分支返回<strong>同一种</strong>闭包。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn create_multiplier(factor: i32) -&gt; impl Fn(i32) -&gt; i32 {
    // 关键：必须使用 move，将 factor 移入闭包
    // 否则 factor 会在函数结束时释放，导致引用失效
    move |x| x * factor
}

fn main() {
    let double = create_multiplier(2);
    println!("3 的两倍是: {}", double(3));
}</code></pre>
<h3 id="3-返回闭包动态分发-boxdyn-trait"><a class="header" href="#3-返回闭包动态分发-boxdyn-trait">3. 返回闭包：动态分发 (<code>Box&lt;dyn Trait&gt;</code>)</a></h3>
<p>如果你需要根据逻辑返回不同的闭包（比如在 <code>if/else</code> 分支中返回不同的闭包代码块），必须使用 <code>Box</code>。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn get_closure(mode: bool) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    if mode {
        Box::new(|x| x + 1)
    } else {
        Box::new(|x| x * 2)
    }
}

fn main() {
    let f = get_closure(false);
    println!("执行结果: {}", f(5)); // 10
}</code></pre>
<hr>
<h2 id="总结对比-1"><a class="header" href="#总结对比-1">总结对比</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>特性</strong></th><th><strong>普通函数 (fn)</strong></th><th><strong>impl Trait 闭包</strong></th><th><strong><code>Box&lt;dyn Trait&gt;</code> 闭包</strong></th></tr>
</thead>
<tbody>
<tr><td><strong>捕获变量</strong></td><td>不支持</td><td>支持（需用 <code>move</code>）</td><td>支持（需用 <code>move</code>）</td></tr>
<tr><td><strong>返回类型</strong></td><td><code>fn(A) -&gt; B</code></td><td><code>impl Fn(A) -&gt; B</code></td><td><code>Box&lt;dyn Fn(A) -&gt; B&gt;</code></td></tr>
<tr><td><strong>内存位置</strong></td><td>代码段</td><td>栈</td><td>堆</td></tr>
<tr><td><strong>性能</strong></td><td>极高（静态）</td><td>高（静态）</td><td>略低（动态寻址）</td></tr>
<tr><td><strong>适用场景</strong></td><td>简单、纯粹的逻辑</td><td>性能敏感、单一返回路径</td><td>需要根据条件返回不同闭包</td></tr>
</tbody>
</table>
</div>
<hr>
<h3 id="-核心避坑指南"><a class="header" href="#-核心避坑指南">💡 核心避坑指南</a></h3>
<p>在返回闭包时，<strong>忘记写 <code>move</code></strong> 是新手最常见的错误。</p>
<blockquote>
<p><strong>记住</strong> ：闭包默认会尝试通过“引用”来捕获环境中的变量。但当函数结束时，这些变量会被销毁，所以闭包必须通过 <code>move</code> 把它们“打包带走”，否则你会得到一个“悬垂引用”的报错。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h1>
<p>Rust 的错误处理体系以其<strong>严谨性</strong>著称。它不使用传统的 <code>try-catch</code> 异常机制，而是通过类型系统将错误显式化，强制开发者在编译期就面对可能的失败。</p>
<hr>
<h2 id="一-不可恢复错误panic"><a class="header" href="#一-不可恢复错误panic">一、 不可恢复错误：<code>panic!</code></a></h2>
<p>当程序遇到无法恢复的错误时（如数组越界或断言失败），Rust 使用 panic! 宏来终止执行。这会 unwind 栈（清理资源）或直接 abort（不清理，适合嵌入式系统）。</p>
<h3 id="1-发生什么"><a class="header" href="#1-发生什么">1. 发生什么？</a></h3>
<ol>
<li>程序打印错误信息。</li>
<li><strong>展开（Unwinding）</strong> ：Rust 沿着栈往回走，清理每个函数的数据（释放所有权）。</li>
<li>程序退出。</li>
</ol>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    // 主动触发 panic
    // panic!("这里发生了不可预见的灾难！");

    let v = vec![1, 2, 3];
    v[99]; // ❌ 被动触发 panic：索引越界
}</code></pre>
<p>当你取到了一个不属于你的值，这在很多时候会导致程序上的逻辑 BUG！ 有编程经验的人都知道这种逻辑上的 BUG 是多么难被发现和修复！因此程序直接崩溃，然后告诉我们问题发生的位置，最后我们对此进行修复，这才是最合理的软件开发流程，而不是把问题藏着掖着：</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thread 'main' (12) panicked at src/main.rs:6:6:
index out of bounds: the len is 3 but the index is 99
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
<span class="boring">}</span></code></pre>
<p>好的，现在成功知道问题发生的位置，但是如果我们想知道该问题之前经过了哪些调用环节，该怎么办？那就按照提示使用 <code>RUST_BACKTRACE=1 cargo run</code> 或 <code>$env:RUST_BACKTRACE=1 ; cargo run</code> 来再一次运行程序</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:6:6
stack backtrace:
   0: rust_begin_unwind
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/std/src/panicking.rs:517:5
   1: core::panicking::panic_fmt
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:101:14
   2: core::panicking::panic_bounds_check
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:77:5
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:184:10
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:15:9
   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/alloc/src/vec/mod.rs:2465:9
   6: world_hello::main
             at ./src/main.rs:4:5
   7: core::ops::function::FnOnce::call_once
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/ops/function.rs:227:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
<span class="boring">}</span></code></pre>
<p>上面的代码就是一次栈展开（也称栈回溯），它包含了函数调用的顺序，当然按照逆序排列：最近调用的函数排在列表的最上方。因为咱们的 main 函数基本是最先调用的函数了，所以排在了倒数第二位，还有一个关注点，排在最顶部最后一个调用的函数是 rust_begin_unwind，该函数的目的就是进行栈展开，呈现这些列表信息给我们。</p>
<p>要获取到栈回溯信息，你还需要开启 debug 标志，该标志在使用 cargo run 或者 cargo build 时自动开启（这两个操作默认是 Debug 运行方式）。同时，栈展开信息在不同操作系统或者 Rust 版本上也有所不同。</p>
<h3 id="2-何时使用"><a class="header" href="#2-何时使用">2. 何时使用？</a></h3>
<ul>
<li><strong>示例代码或原型</strong> ：快速展示逻辑。</li>
<li><strong>测试代码</strong> ：断言失败。</li>
<li><strong>逻辑不可达</strong> ：你确信这段代码永远不会运行到，除非有严重的 Bug。</li>
</ul>
<hr>
<h2 id="二-可恢复错误option-与-result"><a class="header" href="#二-可恢复错误option-与-result">二、 可恢复错误：<code>Option</code> 与 <code>Result</code></a></h2>
<p>这是 Rust 错误处理的核心，通过两个枚举来包裹“可能不存在的值”或“可能失败的操作”。Rust 不使用异常，而是返回枚举类型：</p>
<ul>
<li><strong>Option</strong>：表示可能为空的值。<strong>Some(T) 或 None</strong>。</li>
<li><strong>Result&lt;T, E&gt;</strong>：表示成功或失败。<strong>Ok(T) 或 Err(E)</strong>。</li>
</ul>
<h3 id="1-optiont值可能不存在"><a class="header" href="#1-optiont值可能不存在">1. <code>Option&lt;T&gt;</code>：值可能不存在</a></h3>
<p>用于表示一个值要么有（<code>Some(T)</code>），要么没有（<code>None</code>）。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn find_index(target: i32, list: Vec&lt;i32&gt;) -&gt; Option&lt;usize&gt; {
    for (i, &amp;item) in list.iter().enumerate() {
        if item == target { return Some(i); }
    }
    None
}

fn main() {
    let list = vec![10, 20, 30];
    match find_index(20, list) {
        Some(index) =&gt; println!("找到索引: {index}"),
        None =&gt; println!("未找到"),
    }
}</code></pre>
<h3 id="2-resultt-e操作可能失败"><a class="header" href="#2-resultt-e操作可能失败">2. <code>Result&lt;T, E&gt;</code>：操作可能失败</a></h3>
<p>用于表示一个操作要么成功（<code>Ok(T)</code>），要么失败（<code>Err(E)</code>）。</p>
<pre class="playground"><code class="language-rust editable edition2024">use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let _file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!("打开文件失败: {:?}", error),
    };
}</code></pre>
<h3 id="模式匹配和-unwrap"><a class="header" href="#模式匹配和-unwrap">模式匹配和 unwrap</a></h3>
<ul>
<li><strong>match</strong>：最安全的方式。</li>
<li><strong>unwrap()</strong>：如果 Ok 返回值，否则 panic!（不推荐生产环境）。</li>
<li><strong>expect(“消息”)</strong>：类似 unwrap，但自定义 panic 消息。</li>
<li><strong>unwrap_or(default)</strong>：为 Option/Result 提供默认值。</li>
<li><strong>unwrap_or_else(closure)</strong>：懒惰计算默认值。</li>
</ul>
<hr>
<h2 id="三-常用组合器-combinators"><a class="header" href="#三-常用组合器-combinators">三、 常用组合器 (Combinators)</a></h2>
<p>组合器允许你以<strong>函数式</strong>的风格链式处理 <code>Option</code> 和 <code>Result</code>，避免层层嵌套的 <code>match</code>。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>组合器</strong></th><th><strong>作用描述</strong></th></tr>
</thead>
<tbody>
<tr><td><strong><code>.map()</code></strong></td><td>仅对成功（<code>Some</code>/<code>Ok</code>）的值进行转换</td></tr>
<tr><td><strong><code>.and_then()</code></strong></td><td>类似 <code>map</code>，但闭包也返回 <code>Result/Option</code>（自动平铺嵌套）</td></tr>
<tr><td><strong><code>.unwrap_or()</code></strong></td><td>如果失败/缺失，则返回一个默认值</td></tr>
<tr><td><strong><code>.unwrap_or_else()</code></strong></td><td>类似 <code>unwrap_or</code>，但默认值通过闭包计算（延迟求值）</td></tr>
<tr><td><strong><code>.map_err()</code></strong></td><td>仅对 <code>Err</code> 进行转换（通常用于转换错误类型）</td></tr>
</tbody>
</table>
</div>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    // --- 1. .map(): 只转换成功的值，忽略失败 ---
    let s = Some("5");
    let n = s.map(|val| val.parse::&lt;i32&gt;().unwrap_or(0)); 
    // n 现在是 Some(5)

    // --- 2. .and_then(): 展平嵌套（类似 flat_map） ---
    // 如果转换函数也返回 Option/Result，用 and_then 防止出现 Option&lt;Option&lt;T&gt;&gt;
    let get_val = |i: i32| if i &gt; 0 { Some(i * 2) } else { None };
    let result = Some(10).and_then(get_val); 
    // result 是 Some(20)，而不是 Some(Some(20))

    // --- 3. .unwrap_or() 与 .unwrap_or_else(): 兜底默认值 ---
    let x: Option&lt;i32&gt; = None;
    let val = x.unwrap_or(0); // 如果是 None，则返回 0
  
    // or_else 接受闭包，适合计算默认值开销较大的场景（延迟求值）
    let val_lazy = x.unwrap_or_else(|| {
        // 执行复杂的计算过程...
        100 
    });

    // --- 4. .map_err(): 只处理错误，不改动成功值 ---
    let res: Result&lt;i32, i32&gt; = Err(404);
    let updated_res = res.map_err(|e| format!("Error code: {}", e));
    // updated_res 是 Err("Error code: 404")

    println!("组合器处理结果: {:?}, {}, {:?}", n, val, updated_res);
}</code></pre>
<hr>
<h2 id="四--操作符错误传播的捷径"><a class="header" href="#四--操作符错误传播的捷径">四、 <code>?</code> 操作符：错误传播的捷径</a></h2>
<p><code>?</code> 操作符是 Rust 错误传播的语法糖。它可以极大地简化代码，让逻辑保持清晰。程序几乎不太可能只有 A-&gt;B 形式的函数调用，一个设计良好的程序，一个功能涉及十几层的函数调用都有可能。而错误处理也往往不是哪里调用出错，就在哪里处理，实际应用中，大概率会把错误层层上传然后交给调用链的上游函数进行处理，错误传播将极为常见</p>
<h3 id="1-工作原理"><a class="header" href="#1-工作原理">1. 工作原理</a></h3>
<p>当你在一个返回 <code>Result</code> 的表达式后面加 <code>?</code> 时：</p>
<ol>
<li>如果结果是 <code>Ok</code>，它会<strong>自动解包</strong>出里面的值，程序继续执行。</li>
<li>如果结果是 <code>Err</code>，它会立即 <strong>提前返回</strong> （Return）整个函数，并将错误传递给调用者。</li>
</ol>
<pre class="playground"><code class="language-rust editable edition2024">use std::fs::File;
use std::io::{self, Read};

fn read_username() -&gt; Result&lt;String, io::Error&gt; {
    // 如果 open 失败，直接返回 Err；如果成功，f 绑定为 File 对象
    let mut f = File::open("name.txt")?; 
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?; // 如果读取失败，直接返回 Err
    Ok(s)
}
fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let username = read_username()?;
    println!("用户名: {}", username);
    Ok(())
}</code></pre>
<ul>
<li>解释：? 等价于</li>
</ul>
<pre><code class="language-txt">let mut file = match File::open(filename) {
    Ok(f) =&gt; f,
    Err(e) =&gt; return Err(e),
};
</code></pre>
<ul>
<li>要求：函数必须返回 <code>Result/Option</code>。</li>
<li>链式使用：支持多个 ?，错误会向上传播。</li>
<li><code>From trait</code>：如果错误类型不同，? 会自动转换（如果实现了 From）。</li>
</ul>
<h3 id="2-使用限制"><a class="header" href="#2-使用限制">2. 使用限制</a></h3>
<ul>
<li><code>?</code> 只能在返回类型与 <code>?</code> 处理的类型<strong>相兼容</strong>的函数中使用（例如在返回 <code>Result</code> 的函数中处理 <code>Result</code>）。</li>
<li>在 <code>main</code> 函数中使用 <code>?</code> 需要将 <code>main</code> 的返回类型改为 <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>。</li>
</ul>
<hr>
<h2 id="五自定义错误类型"><a class="header" href="#五自定义错误类型">五、自定义错误类型</a></h2>
<p>对于复杂应用，定义自己的错误枚举，结合 <code>thiserror</code> 或 <code>anyhow</code> crate 更加方便。</p>
<h2 id="总结概括"><a class="header" href="#总结概括">总结概括</a></h2>
<ol>
<li><strong><code>panic!</code></strong> ：用于 <strong>程序 Bug</strong> 。当你无法预见错误或错误会导致程序状态不可靠时使用。</li>
<li><strong><code>Option</code></strong> ：用于 <strong>可能缺失</strong> 。不代表失败，只是“没有”。</li>
<li><strong><code>Result</code></strong> ：用于 <strong>可能失败</strong> 。明确区分成功数据和错误信息。</li>
<li><strong><code>?</code></strong> ：用于 <strong>传播错误</strong> 。让错误处理像写直线代码一样简单。</li>
<li><strong>组合器</strong> ：用于 <strong>优雅转换</strong> 。让数据在各种状态间流动而不需要嵌套判断。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="结构体"><a class="header" href="#结构体">结构体</a></h1>
<p>在 Rust 中，<strong>结构体Structs</strong>是构建复杂程序的基石。它允许你将相关联的数据组合在一起，创建出更有意义的自定义类型。相比于元组，结构体为每个数据片段命名，因此更加灵活且意图清晰。</p>
<hr>
<h2 id="一-结构体的三种类型"><a class="header" href="#一-结构体的三种类型">一、 结构体的三种类型</a></h2>
<p>Rust 支持三种不同风格的结构体，分别适用于不同的场景。</p>
<h3 id="1-具名结构体-classic-structs"><a class="header" href="#1-具名结构体-classic-structs">1. 具名结构体 (Classic Structs)</a></h3>
<p>最常用的类型，类似于其他语言中的类或对象，每个字段都有明确的名字。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    // 实例化结构体
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someuser123"),
        active: true,
        sign_in_count: 1,
    };

    println!("用户 {} 的邮箱是 {}", user1.username, user1.email);
}</code></pre>
<p><strong>关键点：</strong></p>
<ul>
<li>结构体通常拥有其数据，使用如 String 的拥有类型，以确保数据在结构体存在期间有效。</li>
<li>如果使用引用（如 &amp;str），需要指定生命周期（lifetime），以避免悬垂引用（dangling references）。</li>
<li>字段不能单独标记为可变，整个结构体实例必须是可变的才能修改字段。</li>
</ul>
<h3 id="2-元组结构体-tuple-structs"><a class="header" href="#2-元组结构体-tuple-structs">2. 元组结构体 (Tuple Structs)</a></h3>
<p>当你想给整个元组起个名字，但不需要为内部每个字段命名时使用。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
  
    // 注意：虽然内部类型一样，但 Color 和 Point 是不同的类型！
    println!("第一个颜色分量: {}", black.0);
}</code></pre>
<h3 id="3-单元结构体-unit-like-structs"><a class="header" href="#3-单元结构体-unit-like-structs">3. 单元结构体 (Unit-like Structs)</a></h3>
<p>没有任何字段。常用于需要在某个类型上实现 <code>Trait</code>但不需要存储数据的情况。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct AlwaysEqual;

fn main() {
    let _subject = AlwaysEqual;
}</code></pre>
<hr>
<h2 id="二-实例化"><a class="header" href="#二-实例化">二、 实例化</a></h2>
<h3 id="1-字段初始化简写-field-init-shorthand"><a class="header" href="#1-字段初始化简写-field-init-shorthand">1. 字段初始化简写 (Field Init Shorthand)</a></h3>
<p>当变量名与字段名完全相同时，可以简写。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username, // 等同于 username: username
        email,    // 等同于 email: email
        sign_in_count: 1,
    }
}

fn main() {
    let user1 = build_user(String::from("a@b.com"), String::from("user1"));
    println!("用户 {} 的邮箱是 {}", user1.username, user1.email);
}</code></pre>
<h3 id="2-结构体更新语法-struct-update-syntax"><a class="header" href="#2-结构体更新语法-struct-update-syntax">2. 结构体更新语法 (Struct Update Syntax)</a></h3>
<p>当你想要创建一个新实例，但大部分数据与旧实例相同时，使用 <code>..</code> 语法。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
fn main() {
    let user1 = User {
        email: String::from("a@b.com"),
        username: String::from("user1"),
        active: true,
        sign_in_count: 1,
    };

    // 使用 user1 的部分数据创建 user2
    let user2 = User {
        email: String::from("c@d.com"),
        ..user1 // 剩余字段直接拷贝/移动自 user1
    };
    println!("用户 {} 的邮箱是 {}", user2.username, user2.email);
    // println!("用户 {} 的邮箱是 {}", user1.username, user1.email);
    // 注意：由于 String 发生了所有权转移，user1.username 此时已失效！除非那些字段实现了 Copy trait
}</code></pre>
<h3 id="3-访问和更新字段"><a class="header" href="#3-访问和更新字段">3. 访问和更新字段</a></h3>
<p>使用点号 . 访问字段。要更新，需要可变实例（mut）。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
fn main() {
    let mut user1 = User {
        email: String::from("a@b.com"),
        username: String::from("user1"),
        active: true,
        sign_in_count: 1,
    };
    user1.email = String::from("newemail@example.com");
    println!("用户 {} 的邮箱是 {}", user1.username, user1.email);
}</code></pre>
<hr>
<h2 id="三-结构体方法impl-块"><a class="header" href="#三-结构体方法impl-块">三、 结构体方法：<code>impl</code> 块</a></h2>
<p>在 Rust 中，数据定义（<code>struct</code>）和行为定义（<code>impl</code>）是分开的。</p>
<ul>
<li><strong>方法 (Methods)</strong> ：第一个参数是 <code>self</code>，通过实例调用。</li>
<li><strong>关联函数 (Associated Functions)</strong> ：没有 <code>self</code> 参数，通过 <code>类型名::</code> 调用（类似静态方法）。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">#[derive(Debug)] // 允许通过 {:?} 打印结构体
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // 关联函数：通常用于构造函数
    fn square(size: u32) -&gt; Self {
        Self { width: size, height: size }
    }

    // 方法：计算面积
    // 使用 &amp;self 借用实例，而不是获取所有权
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    // 方法：判断当前矩形是否能容纳另一个矩形
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle::square(10); // 调用关联函数

    println!("矩形面积: {}", rect1.area());
    println!("rect1 能容纳 rect2 吗？ {}", rect1.can_hold(&amp;rect2));
    println!("打印结构体详情: {:?}", rect1);
}</code></pre>
<h3 id="关键差异与-oop"><a class="header" href="#关键差异与-oop">关键差异与 OOP</a></h3>
<ul>
<li>Rust 无自动 getter/setter，需要手动定义。</li>
<li>方法名可与字段名相同（基于语法区分）。</li>
<li>强调借用规则，与 OOP 的封装不同。</li>
<li>Rust 自动处理引用/解引用，无需 -&gt; 操作符。</li>
</ul>
<hr>
<h2 id="四-结构体与所有权"><a class="header" href="#四-结构体与所有权">四、 结构体与所有权</a></h2>
<p>这是新手最容易困惑的地方：</p>
<ol>
<li><strong>字段的所有权</strong> ：如果结构体拥有其字段的所有权（如 <code>String</code>），那么当结构体被销毁时，字段也会被销毁。结构体字段若为拥有类型（如 String），实例移动时会转移所有权。</li>
<li><strong>在结构体中存储引用</strong> ：如果你希望结构体存储一个指向外部数据的引用（如 <code>&amp;str</code>），你需要使用 <strong>生命周期（Lifetimes）</strong> 标注。</li>
</ol>
<blockquote>
<p><em>目前建议先使用拥有所有权的类型（如 <code>String</code> 而不是 <code>&amp;str</code>），直到学习到生命周期章节。</em>
<em>优先使用借用（&amp;）以避免不必要的移动</em></p>
</blockquote>
<hr>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>特性</strong></th><th><strong>具名结构体</strong></th><th><strong>元组结构体</strong></th><th><strong>单元结构体</strong></th></tr>
</thead>
<tbody>
<tr><td><strong>访问方式</strong></td><td><code>s.field_name</code></td><td><code>s.0</code>, <code>s.1</code></td><td>不可访问</td></tr>
<tr><td><strong>语义</strong></td><td>明确的数据对象</td><td>强类型化的元组</td><td>标签或特征实现</td></tr>
<tr><td><strong>典型案例</strong></td><td>用户信息、配置项</td><td>坐标 (x, y)、颜色 (r, g, b)</td><td>状态标记、Trait 对象</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="枚举"><a class="header" href="#枚举">枚举</a></h1>
<p>如果说结构体（Struct）是将多个相关数据“打包”在一起，那么<strong>枚举Enums</strong>则是让一个变量在“多种可能”中选择其一。</p>
<p>在 Rust 中，枚举不仅是其他语言中常见的整数常量列表，它还是功能极其强大的 <strong>代数数据类型（Algebraic Data Types）</strong> 。</p>
<hr>
<h2 id="一-基础枚举简单的分类"><a class="header" href="#一-基础枚举简单的分类">一、 基础枚举：简单的分类</a></h2>
<p>这是枚举最基础的用法，用于定义一组离散的选项。</p>
<pre class="playground"><code class="language-rust editable edition2024">enum IpAddrKind {
    V4,
    V6,
}

fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;

    // 枚举可以作为函数参数
    route(four);
    route(six);
}

fn route(ip_kind: IpAddrKind) {}</code></pre>
<p><strong>关键点：</strong></p>
<ul>
<li>枚举变体（如 V4、V6）是枚举类型的成员。</li>
<li>枚举可以作为参数传递给函数，也可以在函数中返回。</li>
<li>你可以在 <code>match</code> 表达式中匹配枚举的每个变体，处理不同的情况。</li>
</ul>
<hr>
<h2 id="二-枚举的真威力携带数据"><a class="header" href="#二-枚举的真威力携带数据">二、 枚举的真威力：携带数据</a></h2>
<p>在 Rust 中，每个枚举变体（Variant）都可以关联不同类型、不同数量的数据。这让你可以用一个类型表达多种结构完全不同的信息。</p>
<pre class="playground"><code class="language-rust editable edition2024">enum Message {
    Quit,                       // 无数据
    Move { x: i32, y: i32 },    // 匿名结构体
    Write(String),              // 单个 String
    ChangeColor(i32, i32, i32), // 元组
}

impl Message {
    fn call(&amp;self) {
        // 你也可以为枚举定义方法！
    }
}

fn main() {
    let m = Message::Write(String::from("hello"));
    m.call();
}</code></pre>
<p>为什么这比结构体好用？</p>
<p>如果你用结构体来实现上面的功能，你可能需要定义 4 个不同的结构体(Rust 是一种强静态类型语言，函数在编译时必须明确知道它接收的参数是什么类型，以及该类型占用的空间大小)。而使用枚举，它们都属于 Message 类型，方便在函数间统一传递。</p>
<hr>
<h2 id="三-核心中的核心option-枚举"><a class="header" href="#三-核心中的核心option-枚举">三、 核心中的核心：<code>Option</code> 枚举</a></h2>
<p>Rust  <strong>没有空值（Null）</strong> 。为了表达“一个值可能不存在”，Rust 使用了标准库中定义的 <code>Option&lt;T&gt;</code> 枚举：</p>
<pre class="playground"><code class="language-rust editable edition2024">enum Option&lt;T&gt; {
    None,
    Some(T),
}</code></pre>
<ul>
<li><strong><code>Some(T)</code></strong> ：代表有值，值为 <code>T</code> 类型。</li>
<li><strong><code>None</code></strong> ：代表没有值。</li>
</ul>
<p>意义何在？</p>
<p>在有 Null 的语言中，你随时可能忘记检查空指针而导致崩溃。在 Rust 中，如果你有一个 Option <code>&lt;i32&gt;</code>，你必须处理 None 的情况，否则代码编译不通过。这从根本上杜绝了空指针异常。</p>
<hr>
<h2 id="四-模式匹配枚举的完美搭档"><a class="header" href="#四-模式匹配枚举的完美搭档">四、 模式匹配：枚举的完美搭档</a></h2>
<p>要获取枚举内部的数据，最常用的工具就是 <code>match</code> 表达式。</p>
<h3 id="1-match穷尽式检查"><a class="header" href="#1-match穷尽式检查">1. <code>match</code>：穷尽式检查</a></h3>
<p><code>match</code> 强制你处理枚举的每一个变体。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!("来自 {:?} 州的 25 美分", state);
            25
        },
    }
}
fn main() {
    let coin = Coin::Quarter(UsState::Alaska);
    let cents = value_in_cents(coin);
    println!("{} 美分", cents);
}</code></pre>
<h3 id="2-if-let更简洁的匹配"><a class="header" href="#2-if-let更简洁的匹配">2. <code>if let</code>：更简洁的匹配</a></h3>
<p>如果你只关心其中的一种情况，<code>if let</code> 是比 <code>match</code> 更优雅的选择。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let some_u8_value = Some(3u8);

    // 仅在值为 Some 时处理
    if let Some(value) = some_u8_value {
        println!("找到了{}！", value);
    }else{
        println!("没有找到值！");
    }
}</code></pre>
<hr>
<h2 id="五-枚举的内存布局进阶"><a class="header" href="#五-枚举的内存布局进阶">五、 枚举的内存布局（进阶）</a></h2>
<p>枚举在内存中是如何存储的？</p>
<p>Rust 会为枚举分配足够的空间来容纳最大的那个变体，此外还需要一个小的<strong>标签Tag</strong>来记录当前存的是哪一个变体。</p>
<p>对于一个枚举 $E$，其占用内存大小大致为：</p>
<p>$$
Size(E) = Size(Tag) + \max(Size(Variant_1), Size(Variant_2), \dots)
$$</p>
<blockquote>
<p>小技巧：</p>
<p>对于 Option&lt;&amp;T&gt;，因为引用（指针）永远不会为 0，Rust 会非常聪明地用 0 来表示 None。这意味着 Option&lt;&amp;T&gt; 和 &amp;T 占用的空间是一样大的！</p>
</blockquote>
<hr>
<h2 id="总结结构体-vs-枚举"><a class="header" href="#总结结构体-vs-枚举">总结：结构体 vs 枚举</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>特性</strong></th><th><strong>结构体 (Struct)</strong></th><th><strong>枚举 (Enum)</strong></th></tr>
</thead>
<tbody>
<tr><td><strong>逻辑关系</strong></td><td><strong>“和”（And）</strong>：包含 A 且包含 B</td><td><strong>“或”（Or）</strong>：要么是 A 要么是 B</td></tr>
<tr><td><strong>数据访问</strong></td><td>通过 <code>.</code> 直接访问字段</td><td>必须通过 <code>match</code> 或 <code>if let</code> 解构</td></tr>
<tr><td><strong>主要用途</strong></td><td>定义具体的数据实体</td><td>定义状态机、分类、错误处理</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="切片"><a class="header" href="#切片">切片</a></h1>
<p>Rust 中的 slice（切片）是一种引用集合中连续元素的视图，而不拥有这些元素。它类似于数组或向量的子视图，使用 <code>&amp;[T]</code> 表示不可变切片，<code>&amp;mut [T]</code> 表示可变切片。Slice 是借用的一部分，遵守借用规则，确保内存安全。Slice 常用于字符串、数组和向量，帮助避免不必要的拷贝，提高效率。</p>
<h2 id="1-slice-简介"><a class="header" href="#1-slice-简介">1. Slice 简介</a></h2>
<ul>
<li><strong>什么是 slice？</strong> ：Slice 是对数据序列的引用视图，指向连续内存块。不拥有数据，只借用。长度在运行时确定。</li>
<li><strong>语法</strong> ：<code>&amp;[T]</code>（不可变）、<code>&amp;mut [T]</code>（可变）。T 是元素类型。</li>
<li><strong>优势</strong> ：零拷贝访问子集；函数参数通用（如接受 <code>&amp;[i32]</code> 而非 Vec 或 <code>[i32; N]</code>）。</li>
<li><strong>与数组/向量的关系</strong> ：数组是固定大小，向量是动态。Slice 可以从两者创建。</li>
<li><strong>字符串 slice</strong> ：<code>&amp;str</code> 是 <code>&amp;[u8]</code> 的特殊形式，处理 UTF-8。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let s = String::from("hello world");
    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
    println!("{}", hello);  // 输出: hello
    println!("{}", world);  // 输出: world
}</code></pre>
<ul>
<li><strong>解释</strong> ：<code>[start..end]</code> 是半开区间（包括 start，不包括 end）。<code>&amp;arr[..]</code> 是全切片。Slice 借用 arr，借用规则适用。</li>
</ul>
<p>对于字符串而言，切片就是对 String 类型中某一部分的引用，它看起来像这样：</p>
<img src="images/切片.jpg" alt="切片" class="center-img" width="50%" />
<h3 id="胖指针fat-pointer"><a class="header" href="#胖指针fat-pointer">胖指针(Fat Pointer)</a></h3>
<ul>
<li>数据结构：对比普通引用（1个字长指针）与切片引用（2个字长）。</li>
<li>组成部分：
<ul>
<li>Pointer：指向数据的起始位置。</li>
<li>Length：切片包含的元素个数。</li>
</ul>
</li>
<li>内存视图：在栈上存储元数据，在堆/静态区查看数据。</li>
</ul>
<h2 id="2-创建-slice"><a class="header" href="#2-创建-slice">2. 创建 Slice</a></h2>
<p>Slice 通过借用和范围运算符创建。</p>
<ul>
<li><strong>范围语法</strong> ：
<ul>
<li><code>[start..end]</code>：从 start 到 end-1。</li>
<li><code>[..end]</code>：从 0 到 end-1。</li>
<li><code>[start..]</code>：从 start 到结束。</li>
<li><code>[..]</code> ：整个集合。</li>
</ul>
</li>
<li><strong>从向量/数组</strong> ：直接 &amp;vec[start..end]。</li>
<li><strong>边界检查</strong> ：运行时检查，如果越界 panic!（安全）。</li>
</ul>
<h3 id="示例各种创建方式"><a class="header" href="#示例各种创建方式">示例：各种创建方式</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let vec = vec![10, 20, 30, 40, 50];
  
    let full = &amp;vec[..];      // 全切片: [10, 20, 30, 40, 50]
    let first_three = &amp;vec[0..3];  // [10, 20, 30]
    let last_two = &amp;vec[3..];     // [40, 50]
  
    println!("{:?}", first_three);
}</code></pre>
<ul>
<li><strong>解释</strong> ：Vec 和数组都支持。Slice 的 len() 返回元素数，get(i) 返回 Option&lt;&amp;T&gt;（安全访问）。</li>
</ul>
<h3 id="可变-slice"><a class="header" href="#可变-slice">可变 slice</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut vec = vec![1, 2, 3];
    let slice = &amp;mut vec[1..3];  // 可变借用
  
    slice[0] = 20;  // 修改 vec[1]
    println!("{:?}", vec);  // 输出: [1, 20, 3]
}</code></pre>
<ul>
<li><strong>解释</strong> ：可变 slice 允许修改元素，但遵守独占借用规则。</li>
</ul>
<h2 id="3-字符串-slice-str"><a class="header" href="#3-字符串-slice-str">3. 字符串 Slice (&amp;str)</a></h2>
<p>字符串 slice 是常见的，处理 String 或 str。</p>
<h3 id="示例字符串-slice"><a class="header" href="#示例字符串-slice">示例：字符串 slice</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">fn first_word(s: &amp;str) -&gt; &amp;str {  // 既能接受 String 的切片，也能接受字符串字面量
    let bytes = s.as_bytes();
    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }
    &amp;s[..]
}

fn main() {
    let s = String::from("hello world");
    let word = first_word(&amp;s);  // &amp;String 隐式转为 &amp;str
    
    println!("{}", word);  // 输出: hello
    
    // s.clear();  // 错误！word 借用期间不能修改 s
}</code></pre>
<ul>
<li><strong>解释</strong> ：<code>&amp;str</code> 是 UTF-8 安全的。as_bytes() 转为 <code>&amp;[u8]</code>。切片索引必须在字符边界（否则 panic!）。用 chars() 或 bytes() 迭代以避免。</li>
</ul>
<h2 id="4-多维-slice"><a class="header" href="#4-多维-slice">4. 多维 Slice</a></h2>
<p>Slice 可以是多维的，如 <code>&amp;[[T]]</code>。</p>
<p>示例：矩阵 slice</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let matrix = vec![vec![1, 2], vec![3, 4]];
    let row = &amp;matrix[0][..];  // &amp;[i32]: [1, 2]
    
    println!("{:?}", row);
}</code></pre>
<ul>
<li>解释：嵌套借用。复杂时考虑扁平化或专用 crate。</li>
</ul>
<blockquote>
<p>注意事项：
索引越界：如果你请求的范围超出了集合边界（如 <code>&amp;s[0..100]</code>），Rust 会在运行时 panic。
UTF-8 字符：对于字符串切片，索引必须落在字符边界上。如果在多字节字符（如中文）中间切片，程序会崩溃。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="常用集合"><a class="header" href="#常用集合">常用集合</a></h1>
<p>在 Rust 标准库 <code>std::collections</code> 模块下，集合被分为四大通用类型 <strong>线性序列</strong> 、<strong>Key-Value 映射表</strong> 、<strong>集合类型</strong>和 <strong>优先队列</strong> 。这些集合存储在堆内存中，并通过指针（如引用、智能指针）进行管理。</p>
<hr>
<h2 id="一-线性序列-linear-sequences"><a class="header" href="#一-线性序列-linear-sequences">一、 线性序列 (Linear Sequences)</a></h2>
<p>这类集合按顺序存储数据，适合处理列表、队列等逻辑。</p>
<ul>
<li><strong>向量 (Vec)</strong> ：最常用的动态数组。支持快速随机访问，在末尾插入/删除效率最高。</li>
<li><strong>双端队列 (VecDeque)</strong> ：基于循环缓冲区实现。在序列的<strong>头部和尾部</strong>插入或删除数据都非常高效。</li>
<li><strong>链表 (LinkedList)</strong> ：双向链表。虽然支持快速合并和拆分，但由于内存不连续，现代硬件上性能通常不如 <code>Vec</code>。</li>
</ul>
<h3 id="代码示例vec-与-vecdeque"><a class="header" href="#代码示例vec-与-vecdeque">代码示例：Vec 与 VecDeque</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">use std::collections::VecDeque;

fn main() {
    // 1. Vec: 动态数组
    let mut v = vec![1, 2, 3];
    v.push(4); 
    println!("Vec 第三个元素: {}", v[2]); // 随机访问

    // 2. VecDeque: 双端操作
    let mut dq = VecDeque::new();
    dq.push_back(10); // 尾部插入
    dq.push_front(20); // 头部插入
    println!("Deque 头部: {:?}", dq.front()); // 输出 Some(20)
}</code></pre>
<hr>
<h2 id="二-key-value-映射表-key-value-maps"><a class="header" href="#二-key-value-映射表-key-value-maps">二、 Key-Value 映射表 (Key-Value Maps)</a></h2>
<p>映射表用于存储“键-值”对，通过键来快速查找对应的值。</p>
<ul>
<li><strong>无序哈希表 (HashMap)</strong> ：通过哈希函数存储。查找速度极快（平均 <strong>$O(1)$</strong>），但由于哈希冲突和重新分配，内部顺序是无序的。</li>
<li><strong>有序哈希表 (BTreeMap)</strong> ：基于 B 树实现。键（Key）必须实现 <code>Ord</code> 特征，数据会按键的大小<strong>自动排序</strong>存储。</li>
</ul>
<h3 id="代码示例hashmap-与-btreemap"><a class="header" href="#代码示例hashmap-与-btreemap">代码示例：HashMap 与 BTreeMap</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">use std::collections::{HashMap, BTreeMap};

fn main() {
    // 1. HashMap: 无序
    let mut scores = HashMap::new();
    scores.insert("Alice", 90);
    scores.insert("Bob", 85);

    // 2. BTreeMap: 自动排序
    let mut sorted_map = BTreeMap::new();
    sorted_map.insert(3, "c");
    sorted_map.insert(1, "a");
    sorted_map.insert(2, "b");

    // 遍历 BTreeMap 时，顺序始终是 1, 2, 3
    for (key, value) in &amp;sorted_map {
        println!("{}: {}", key, value);
    }
}</code></pre>
<hr>
<h2 id="三-集合类型-set-types"><a class="header" href="#三-集合类型-set-types">三、 集合类型 (Set Types)</a></h2>
<p>集合类型实际上是不带“值”的映射表，主要用于保证元素的 <strong>唯一性</strong> 。</p>
<ul>
<li><strong>无序集合 (HashSet)</strong> ：基于 <code>HashMap</code> 实现。用于快速去重或检查某个元素是否存在。</li>
<li><strong>有序集合 (BTreeSet)</strong> ：基于 <code>BTreeMap</code> 实现。元素会根据自身顺序进行 <strong>排序</strong> 。</li>
</ul>
<h3 id="代码示例hashset-的去重功能"><a class="header" href="#代码示例hashset-的去重功能">代码示例：HashSet 的去重功能</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">use std::collections::HashSet;

fn main() {
    let mut books = HashSet::new();
    books.insert("Rust Programming");
    books.insert("Rust Programming"); // 重复插入会被忽略

    if !books.contains("C++") {
        println!("我们没有找到关于 C++ 的书。");
    }
}</code></pre>
<hr>
<h2 id="四-优先队列-priority-queues"><a class="header" href="#四-优先队列-priority-queues">四、 优先队列 (Priority Queues)</a></h2>
<p>当需要始终优先处理“最大”或“最小”的元素时，使用此类集合。</p>
<ul>
<li><strong>二叉堆 (BinaryHeap)</strong> ：默认是 <strong>最大堆</strong> 。无论插入顺序如何，每次弹出的总是集合中最大的元素。</li>
</ul>
<h3 id="代码示例binaryheap"><a class="header" href="#代码示例binaryheap">代码示例：BinaryHeap</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">use std::collections::BinaryHeap;

fn main() {
    let mut heap = BinaryHeap::new();

    // 乱序插入
    heap.push(1);
    heap.push(5);
    heap.push(2);

    // 总是弹出当前最大的值
    println!("弹出最大值: {:?}", heap.pop()); // 输出 Some(5)
    println!("再次弹出: {:?}", heap.pop());   // 输出 Some(2)
}</code></pre>
<hr>
<h2 id="总结如何选择集合"><a class="header" href="#总结如何选择集合">总结：如何选择集合？</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>需求场景</strong></th><th><strong>推荐集合类型</strong></th></tr>
</thead>
<tbody>
<tr><td><strong>存储简单的列表、作为默认选择</strong></td><td><code>Vec</code></td></tr>
<tr><td><strong>需要频繁从头部插入数据</strong></td><td><code>VecDeque</code></td></tr>
<tr><td><strong>根据 ID 或名称快速查找数据</strong></td><td><code>HashMap</code></td></tr>
<tr><td><strong>需要查找数据且要求结果按顺序排列</strong></td><td><code>BTreeMap</code></td></tr>
<tr><td><strong>只需要去重，不关心关联值</strong></td><td><code>HashSet</code></td></tr>
<tr><td><strong>始终要处理“优先级最高”的任务</strong></td><td><code>BinaryHeap</code></td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="泛型"><a class="header" href="#泛型">泛型</a></h1>
<p>泛型是 Rust 实现 零开销抽象（Zero-cost Abstractions） 的核心，它允许你编写不依赖于具体类型的通用代码。</p>
<ul>
<li><strong>什么是泛型？</strong>：使用类型参数（如 ）定义代码，允许在不同类型上重用。T 是占位符，在使用时替换为具体类型。</li>
<li><strong>优势</strong>：代码复用、类型安全、性能高（编译时展开）。</li>
<li><strong>语法</strong>：在函数、struct 等后用 &lt;参数&gt;，如 fn foo(arg: T)。</li>
<li><strong>与 trait 的关系</strong>：泛型常结合 trait bound（如 T: Clone）限制类型。</li>
</ul>
<h2 id="1-泛型基础generics-basics"><a class="header" href="#1-泛型基础generics-basics">1. <strong>泛型基础(Generics Basics)</strong></a></h2>
<h3 id="泛型类型参数"><a class="header" href="#泛型类型参数">泛型类型参数</a></h3>
<p>Rust 中的泛型允许我们在编写函数或结构体时不指定具体类型，从而让代码更具通用性。例如：</p>
<pre class="playground"><code class="language-rust editable edition2024">fn swap&lt;T&gt;(x: T, y: T) -&gt; (T, T) {
    (y, x)
}

fn main() {
    let (a, b) = swap(1, 2);
    println!("Swapped values: {}, {}", a, b);

    let (x, y) = swap("Hello", "World");
    println!("Swapped strings: {}, {}", x, y);
}</code></pre>
<p>swap 函数接受两个相同类型的参数 x 和 y，并返回它们的交换值。T 在调用时会被具体类型替换，确保返回的元组类型与输入类型一致。</p>
<h3 id="泛型约束"><a class="header" href="#泛型约束">泛型约束</a></h3>
<p>有时我们希望泛型类型参数满足特定的条件，例如只允许实现了某个特征（<code>trait</code>）的类型。可以使用 <code>T: Trait</code> 来为泛型添加约束。</p>
<ul>
<li><strong>语法</strong>：fn foo&lt;T: Trait1 + Trait2&gt;(arg: T)</li>
<li><strong>常见 bound</strong>：Copy、Clone、Debug、PartialEq、PartialOrd 等。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn print_debug&lt;T: std::fmt::Debug&gt;(val: T) {
    println!("{:?}", val);
}
fn main() {
    print_debug(42);          // 传递整数，符合 Debug 特征
    // print_debug("Hello");  // 编译错误，因为字符串没有 Debug 特征
}</code></pre>
<h3 id="泛型方法"><a class="header" href="#泛型方法">泛型方法</a></h3>
<p>方法与函数类似，但它们是定义在<strong>结构体、枚举、trait 等类型</strong>上的。在定义方法时，你可以在<strong>impl块中</strong>使用泛型类型参数。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    // 泛型方法，接受一个泛型参数并返回其和
    fn new(x: T, y: T) -&gt; Self {
        Pair { x, y }
    }
    fn get_x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
    fn get_y(&amp;self) -&gt; &amp;T {
        &amp;self.y
    }
}
fn main() {
    let pair = Pair::new(1, 2);  // T = i32
    println!("Pair: {} and {}", pair.get_x(), pair.get_y());
    let pair_str = Pair::new("Hello", "World");  // T = &amp;str
    println!("Pair: {} and {}", pair_str.get_x(), pair_str.get_y());
}</code></pre>
<p>在这个例子中，Pair 是一个泛型结构体，new 方法和 get_x、get_y 方法都是泛型方法。它们可以处理任何类型 T，确保类型一致性。</p>
<h3 id="对于复杂-bound用-where-子句提高可读性"><a class="header" href="#对于复杂-bound用-where-子句提高可读性">对于复杂 bound，用 where 子句提高可读性</a></h3>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; U
where
    T: Debug + Clone,
    U: Clone + PartialEq,
{
    if t.clone() == u {  // 错误！T 和 U 类型不同，不能比较
        // ...
    }
    u
}
<span class="boring">}</span></code></pre>
<p>解释：where 在签名后。适用于函数、impl、trait。</p>
<h2 id="2-结构体和枚举中的泛型"><a class="header" href="#2-结构体和枚举中的泛型">2. <strong>结构体和枚举中的泛型</strong></a></h2>
<h3 id="泛型结构体"><a class="header" href="#泛型结构体">泛型结构体</a></h3>
<p>结构体也可以使用泛型类型，字段类型由泛型决定,以便存储不同类型的数据。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct Pair&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let int_float = Pair { x: 42, y: 3.14 };
    let string_int = Pair { x: "Hello", y: 100 };
    println!("int_float: ({}, {})", int_float.x, int_float.y);
    println!("string_int: ({}, {})", string_int.x, string_int.y);
}</code></pre>
<p>在这个示例中，<code>Pair</code> 结构体有两个泛型参数 <code>T</code> 和 <code>U</code>，它们可以代表不同的类型。</p>
<h3 id="泛型枚举"><a class="header" href="#泛型枚举">泛型枚举</a></h3>
<p>枚举类型也可以使用泛型，允许它们处理不同类型的数据。例如，标准库中的 <code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code> 就是泛型枚举。</p>
<pre class="playground"><code class="language-rust editable edition2024">// 定义一个泛型枚举
enum MyOption&lt;T&gt; {
    Some(T),
    None,
}

fn main() {
    let some_int = MyOption::Some(42);
    let none: MyOption&lt;i32&gt; = MyOption::None;
  
    match some_int {
        MyOption::Some(value) =&gt; println!("Some: {}", value),
        MyOption::None =&gt; println!("None"),
    }
}</code></pre>
<h2 id="3-特征trait与泛型"><a class="header" href="#3-特征trait与泛型">3. <strong>特征（Trait）与泛型</strong></a></h2>
<h3 id="泛型与特征结合"><a class="header" href="#泛型与特征结合">泛型与特征结合</a></h3>
<p>特征（trait，具体看下一节介绍)）可以与泛型结合使用，限制泛型类型必须实现特定的特征。例如：</p>
<pre class="playground"><code class="language-rust editable edition2024">// 定义一个 trait
trait Printable {
    fn print(&amp;self);
}
// 为 `i32` 实现 `Printable` 特征
impl Printable for i32 {
    fn print(&amp;self) {
        println!("Printing i32: {}", self);
    }
}
// 泛型函数，只有实现了 `Printable` 特征的类型才能使用
fn print_value&lt;T: Printable&gt;(val: T) {
    val.print();
}
fn main() {
    let x = 42;
    print_value(x);  // 可以，因为 i32 实现了 Printable 特征
}</code></pre>
<h2 id="4-生命周期lifetime与泛型"><a class="header" href="#4-生命周期lifetime与泛型">4. <strong>生命周期（Lifetime）与泛型</strong></a></h2>
<p>有时，生命周期和泛型约束会结合使用，以确保泛型类型满足特定条件。在某些情况下，泛型类型可能是引用类型，因此需要生命周期标注。（其他复杂情况见生命周期小节）</p>
<pre class="playground"><code class="language-rust editable edition2024">// 一个泛型函数，它的类型 T 必须是引用类型，并且带有生命周期标注
fn first_word&lt;'a, T&gt;(s: &amp;'a T) -&gt; &amp;'a str
where
    T: AsRef&lt;str&gt;,  // 泛型类型 T 必须实现 AsRef&lt;str&gt; 特征
{
    let str_ref: &amp;str = s.as_ref(); // 将 T 转换为 &amp;str
    let bytes = str_ref.as_bytes();
    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;str_ref[0..i];
        }
    }
    &amp;str_ref[..]
}
fn main() {
    let string = String::from("Hello world");
    let word = first_word(&amp;string);
    println!("The first word is: {}", word);
}</code></pre>
<h2 id="5-关联类型associated-types"><a class="header" href="#5-关联类型associated-types">5. <strong>关联类型（Associated Types）</strong></a></h2>
<p>Rust 允许在 trait 中定义“关联类型”，这些类型在 trait 的实现中被具体化。这样可以简化泛型的使用。</p>
<pre class="playground"><code class="language-rust editable edition2024">// 定义一个 trait，带有关联类型
trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
// 为 Vec 实现 Iterator 特征
impl&lt;T&gt; Iterator for Vec&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.pop()
    }
}
fn main() {
    let mut vec = vec![1, 2, 3];
    let mut iter = vec.into_iter();
    println!("{:?}", iter.next());  // 输出 Some(3)
}</code></pre>
<h2 id="6-泛型与性能考虑"><a class="header" href="#6-泛型与性能考虑">6. <strong>泛型与性能考虑</strong></a></h2>
<p>在 <code>Rust</code>中，泛型是非常强大的工具，它允许编写类型安全且灵活的代码。然而，许多人担心使用泛型是否会影响程序的性能。幸运的是，<code>Rust</code>的设计非常注重性能，尤其是与泛型相关的部分。让我们深入探讨泛型如何影响性能，以及如何最大程度地避免性能损失。</p>
<p><code>Rust</code>使用一种称为 单态化<code>（Monomorphization）</code> 的机制来处理泛型。单态化是指编译器在编译时将泛型类型的代码转换为具体类型的实现。这意味着泛型代码在编译期间被实例化为不同类型的具体代码，因此没有运行时的性能开销。</p>
<p>这种机制确保了泛型代码的 零成本抽象<code>（Zero-cost Abstraction）</code>。也就是说，使用泛型不会导致额外的运行时开销。</p>
<p>尽管泛型本身不会带来运行时的性能损失，但它们可能会影响 <strong>内存布局</strong> 和 <strong>大小</strong>，特别是当涉及到<strong>动态分发</strong>时。泛型类型的大小由编译器在单态化时决定。如果泛型类型的大小变化较大，可能会导致更多的内存分配或数据拷贝。编译器会为每种具体类型生成不同的内存布局，从而避免了不必要的浪费。</p>
<h2 id="7-与标准库的泛型交互"><a class="header" href="#7-与标准库的泛型交互">7. <strong>与标准库的泛型交互</strong></a></h2>
<p>标准库中的许多类型，如 <code>Vec&lt;T&gt;</code>、<code>Option&lt;T&gt;</code>、<code>Result&lt;T, E&gt;</code> 都使用泛型。你可以通过这些泛型类型来简化代码。</p>
<p>Rust 标准库几乎处处是泛型。</p>
<ul>
<li><strong>常见容器</strong>：<code>Vec&lt;T&gt;</code>（动态数组）、<code>HashMap&lt;K, V&gt;</code>（键值对）。</li>
<li><strong>错误处理</strong>：<code>Result&lt;T, E&gt;</code>是编写健壮代码的核心。</li>
<li><strong>迭代器与闭包</strong>：它们利用泛型接口实现高度灵活的数据处理流。</li>
</ul>
<h2 id="8-高级泛型使用"><a class="header" href="#8-高级泛型使用">8. <strong>高级泛型使用</strong></a></h2>
<h3 id="高阶类型hkt的模拟"><a class="header" href="#高阶类型hkt的模拟">高阶类型（HKT）的模拟</a></h3>
<ul>
<li><strong><code>HKT (Higher Kinded Types)</code></strong> 模拟：通过 <code>type alias</code> 和 <code>Trait</code> 模拟对“容器的抽象”。</li>
<li><strong>并发/异步</strong>：使用 <code>Send</code>和 <code>Sync</code>特征约束确保泛型数据在多线程间安全传递。</li>
<li><strong>宏与泛型</strong>：结合使用以生成复杂的泛型 <code>boilerplate</code> 代码。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="trait"><a class="header" href="#trait">Trait</a></h1>
<p>Rust 中的 <code>trait</code> 是一种非常强大的特性，它允许我们定义共享行为的契约，并使得不同类型可以实现这些行为。学习 Rust 中的 <code>trait</code> 是深入理解 Rust 编程语言的重要一步，尤其是在类型系统和抽象的层次上。
需掌握：</p>
<ol>
<li><strong>特征基础</strong>：定义、实现、默认实现。</li>
<li><strong>特征约束 (静态分发)</strong>：Trait Bound、<code>where</code> 子句、<code>impl Trait</code>。</li>
<li><strong>多态与分发 (核心)</strong>
<ul>
<li><strong>静态分发</strong>：泛型展开，性能最高。</li>
<li><strong>动态分发</strong>：<code>dyn Trait</code> 对象，虚函数表 。</li>
</ul>
</li>
<li><strong>进阶特性</strong>：关联类型、Supertraits（继承）、完全限定语法。</li>
<li><strong>高级规则</strong>：孤儿规则、覆盖实现。</li>
<li><strong>特殊特征</strong>
<ul>
<li><strong>标准库三巨头</strong>：<code>Debug</code>, <code>Display</code>, <code>Default</code></li>
<li><strong>所有权控制</strong>：<code>Copy</code>, <code>Clone</code>, <code>Drop</code></li>
<li><strong>标记特征</strong>：<code>Sized</code>, <code>Send</code>, <code>Sync</code></li>
<li><strong>运算符重载</strong>：<code>std::ops</code></li>
</ul>
</li>
</ol>
<p>下面是学习 <code>trait</code> 时应该掌握的主要知识点，以及相关的代码示例：</p>
<h2 id="1-定义-trait"><a class="header" href="#1-定义-trait">1. <strong>定义 Trait</strong></a></h2>
<ul>
<li><code>trait</code> 是行为的集合。你可以在 <code>trait</code> 中定义方法和关联类型，其他类型可以实现这些方法。</li>
<li><code>trait</code> 定义了一组方法的签名，但不包含具体的实现。</li>
</ul>
<h3 id="示例定义-trait"><a class="header" href="#示例定义-trait">示例：定义 Trait</a></h3>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 定义一个 trait
trait Speak {
    fn speak(&amp;self);
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="2-为类型实现-trait"><a class="header" href="#2-为类型实现-trait">2. <strong>为类型实现 Trait</strong></a></h2>
<ul>
<li>类型（例如结构体、枚举等）可以通过 <code>impl</code> 块来实现某个 <code>trait</code>。</li>
<li>一个类型可以实现多个 <code>trait</code>，每个 <code>trait</code> 都可以定义一组方法。</li>
</ul>
<h3 id="示例为结构体实现-trait"><a class="header" href="#示例为结构体实现-trait">示例：为结构体实现 Trait</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">trait Speak {
    fn speak(&amp;self);
}
struct Dog;
impl Speak for Dog {
    fn speak(&amp;self) {
        println!("Woof!");
    }
}
struct Cat;
impl Speak for Cat {
    fn speak(&amp;self) {
        println!("Meow!");
    }
}
fn main() {
    let dog = Dog;
    let cat = Cat;
    dog.speak();  // 输出 "Woof!"
    cat.speak();  // 输出 "Meow!"
}</code></pre>
<hr>
<h2 id="3-trait-默认实现"><a class="header" href="#3-trait-默认实现">3. <strong>Trait 默认实现</strong></a></h2>
<ul>
<li><code>trait</code> 可以为某些方法提供默认实现，这样某些类型可以选择不实现这些方法，而是使用默认实现。</li>
</ul>
<h3 id="示例trait-的默认实现"><a class="header" href="#示例trait-的默认实现">示例：Trait 的默认实现</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">trait Speak {
    fn speak(&amp;self) {
        println!("I can speak in a default way!");
    }
}
struct Dog;
impl Speak for Dog {
    // 不需要显式实现 speak 方法，使用默认实现
}
fn main() {
    let dog = Dog;
    dog.speak();  // 输出 "I can speak in a default way!"
}</code></pre>
<hr>
<h2 id="4-trait-和生命周期"><a class="header" href="#4-trait-和生命周期">4. <strong>Trait 和生命周期</strong></a></h2>
<ul>
<li>你可以在 <code>trait</code> 中使用生命周期标注，确保实现该 <code>trait</code> 的类型处理引用时，能够正确管理引用的生命周期。</li>
</ul>
<h3 id="示例trait-和生命周期"><a class="header" href="#示例trait-和生命周期">示例：Trait 和生命周期</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">trait PrintWithLifetime&lt;'a&gt; {
    fn print(&amp;self, s: &amp;'a str);
}

struct Printer;

impl&lt;'a&gt; PrintWithLifetime&lt;'a&gt; for Printer {
    fn print(&amp;self, s: &amp;'a str) {
        println!("{}", s);
    }
}

fn main() {
    let printer = Printer;
    let message = "Hello, world!";
    printer.print(message);
}</code></pre>
<hr>
<h2 id="5-关联类型"><a class="header" href="#5-关联类型">5. <strong>关联类型</strong></a></h2>
<ul>
<li><code>trait</code> 可以定义  <strong>关联类型</strong> ，这种类型在实现 <code>trait</code> 时需要指定。这种方式使得 <code>trait</code> 更加灵活和强大。</li>
</ul>
<h3 id="示例使用关联类型"><a class="header" href="#示例使用关联类型">示例：使用关联类型</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">trait Iterator {
    type Item;  // 关联类型
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
struct Counter {
    count: i32,
}
impl Iterator for Counter {
    type Item = i32;  // 为关联类型指定具体类型
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.count += 1;
        Some(self.count)
    }
}

fn main() {
    let mut counter = Counter { count: 0 };
    println!("{}", counter.next().unwrap()); // 输出 1
    println!("{}", counter.next().unwrap()); // 输出 2
}</code></pre>
<hr>
<h2 id="6-trait-的继承"><a class="header" href="#6-trait-的继承">6. <strong>Trait 的继承</strong></a></h2>
<ul>
<li>一个 <code>trait</code> 可以继承其他 <code>trait</code>。这使得一个 <code>trait</code> 可以继承另一个 <code>trait</code> 的方法和行为。</li>
</ul>
<h3 id="示例trait-的继承"><a class="header" href="#示例trait-的继承">示例：Trait 的继承</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">trait Animal {
    fn sound(&amp;self);
}

trait DogBehavior: Animal {  // DogBehavior 继承 Animal
    fn fetch(&amp;self);
}

struct Dog;

impl Animal for Dog {
    fn sound(&amp;self) {
        println!("Woof!");
    }
}
//实现 DogBehavior 时，必须也实现 Animal。
impl DogBehavior for Dog {
    fn fetch(&amp;self) {
        println!("Fetching the ball!");
    }
}

fn main() {
    let dog = Dog;
    dog.sound();  // 输出 "Woof!"
    dog.fetch();  // 输出 "Fetching the ball!"
}</code></pre>
<hr>
<h2 id="7-trait-bound-和泛型"><a class="header" href="#7-trait-bound-和泛型">7. <strong>Trait Bound 和泛型</strong></a></h2>
<ul>
<li><code>trait</code> 可以和泛型一起使用，通过 <strong>trait bound</strong> 来约束泛型类型，确保传入的类型实现了特定的 <code>trait</code>。</li>
</ul>
<h3 id="示例trait-bound-和泛型"><a class="header" href="#示例trait-bound-和泛型">示例：Trait Bound 和泛型</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">trait Speak {
    fn speak(&amp;self);
}
struct Dog;
impl Speak for Dog {
    fn speak(&amp;self) {
        println!("Woof!");
    }
}
fn make_speak&lt;T: Speak&gt;(animal: T) {
    animal.speak();
}
fn main() {
    let dog = Dog;
    make_speak(dog);  // 输出 "Woof!"
}</code></pre>
<p>在这个例子中，<code>make_speak</code> 函数的参数 <code>T</code> 被约束为实现了 <code>Speak</code> trait 的类型，因此它可以接受任何实现了 <code>Speak</code> 的类型作为参数。</p>
<hr>
<h2 id="8-trait-作为参数和返回类型"><a class="header" href="#8-trait-作为参数和返回类型">8. <strong>Trait 作为参数和返回类型</strong></a></h2>
<p>在 Rust 的 <code>trait</code> 系统中，将 <code>trait</code> 用作参数或返回类型是实现抽象和多态的核心手段。根据性能需求和灵活性要求，Rust 提供了**静态分发（Static Dispatch）<strong>和</strong>动态分发（Dynamic Dispatch）**两种机制。</p>
<h3 id="trait-作为参数"><a class="header" href="#trait-作为参数">Trait 作为参数</a></h3>
<p>当你希望函数能够接受多种不同类型，只要这些类型实现了特定行为时，可以使用 <code>trait</code> 作为参数。</p>
<h4 id="a-impl-trait-语法语法糖"><a class="header" href="#a-impl-trait-语法语法糖">A. <code>impl Trait</code> 语法（语法糖）</a></h4>
<p>这是最简单、最常用的方式，适用于参数较少的情况。</p>
<pre class="playground"><code class="language-rust editable edition2024">trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
// 接受任何实现了 Summary 的类型
fn notify(item: &amp;impl Summary) {
    println!("新闻更新: {}", item.summarize());
}
fn main() {
    struct Tweet { content: String }
    impl Summary for Tweet {
        fn summarize(&amp;self) -&gt; String { self.content.clone() }
    }
    let tweet = Tweet { content: String::from("Rust 是一种系统级语言") };
    notify(&amp;tweet);  // 输出 "新闻更新: Rust 是一种系统级语言"
}</code></pre>
<h4 id="b-trait-bound特征约束"><a class="header" href="#b-trait-bound特征约束">B. Trait Bound（特征约束）</a></h4>
<p><code>impl Trait</code> 实际上是泛型特征约束的简写。在复杂的场景下（例如要求两个参数必须是<strong>同一种</strong>泛型类型），必须使用特征约束。</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 强制要求 item1 和 item2 必须是相同的具体类型 T
fn notify_double&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {
    // ...
}

<span class="boring">}</span></code></pre>
<h3 id="trait-作为返回类型"><a class="header" href="#trait-作为返回类型">Trait 作为返回类型</a></h3>
<p>这是 Rust 抽象能力的高级体现，但根据返回的是“一种类型”还是“多种类型”，处理方式截然不同。</p>
<h4 id="a-静态分发impl-trait"><a class="header" href="#a-静态分发impl-trait">A. 静态分发：<code>impl Trait</code></a></h4>
<p>当你确定函数在<strong>编译时</strong>只会返回一种具体的类型，但不想写出冗长的类型名（如闭包或复杂的迭代器）时，使用 <code>impl Trait</code>。</p>
<ul>
<li><strong>优点</strong>：性能极高（零开销抽象），编译器会进行单态化处理。</li>
<li><strong>局限</strong>：函数的所有分支<strong>必须返回同一种</strong>具体类型。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">struct NewsArticle { content: String }
impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String { self.content.clone() }
}
fn returns_summarizable() -&gt; impl Summary {
    NewsArticle { content: String::from("内容...") }
}
fn main() {
    let article = returns_summarizable();
    println!("{}", article.summarize());  // 输出 "内容..."
}
</code></pre>
<h4 id="b-动态分发trait-对象-dyn-trait"><a class="header" href="#b-动态分发trait-对象-dyn-trait">B. 动态分发：Trait 对象 (<code>dyn Trait</code>)</a></h4>
<p>如果你需要在运行时根据条件返回<strong>不同类型</strong>的对象，必须使用特征对象。特征对象必须通过指针来使用，如引用 <code>&amp;dyn Trait</code> 或智能指针 <code>Box&lt;dyn Trait&gt;</code>。</p>
<ul>
<li><strong>优点</strong>：支持真正的多态，允许在同一个函数中根据逻辑返回不同的结构体。</li>
<li><strong>原理</strong>：使用虚函数表（vtable）在运行时查找方法。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">struct Dog;
struct Cat;

impl Summary for Dog { fn summarize(&amp;self) -&gt; String { "汪".into() } }
impl Summary for Cat { fn summarize(&amp;self) -&gt; String { "喵".into() } }

// 使用智能指针 Box 包装特征对象
fn get_animal(is_dog: bool) -&gt; Box&lt;dyn Summary&gt; {
    if is_dog {
        Box::new(Dog)
    } else {
        Box::new(Cat)
    }
}
fn main() {
    let animal = get_animal(true);  // 返回 Dog 的特征对象
    println!("{}", animal.summarize());  // 输出 "汪"
    
    let animal = get_animal(false);  // 返回 Cat 的特征对象
    println!("{}", animal.summarize());  // 输出 "喵"
}</code></pre>
<pre class="playground"><code class="language-rust editable edition2024">trait Speak {
    fn speak(&amp;self);
}
struct Dog;
impl Speak for Dog {
    fn speak(&amp;self) {
        println!("Woof!");
    }
}
fn make_speak(animal: &amp;dyn Speak) {
    animal.speak();
}
fn main() {
    let dog = Dog;
    make_speak(&amp;dog);  // 使用 trait 对象动态分发
}
</code></pre>
<h3 id="静态分发-vs-动态分发"><a class="header" href="#静态分发-vs-动态分发">静态分发 vs 动态分发</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>特性</th><th><code>impl Trait</code> (静态分发)</th><th><code>dyn Trait</code> (动态分发)</th></tr>
</thead>
<tbody>
<tr><td><strong>分发时机</strong></td><td>编译期 (Compile-time)</td><td>运行期 (Runtime)</td></tr>
<tr><td><strong>性能开销</strong></td><td><strong>无</strong>（类似于内联函数）</td><td><strong>有</strong>（虚表查询、无法内联优化）</td></tr>
<tr><td><strong>二进制大小</strong></td><td>较大（代码膨胀/单态化）</td><td>较小</td></tr>
<tr><td><strong>类型限制</strong></td><td>必须返回单一具体类型</td><td>可以返回多种实现了特征的类型</td></tr>
<tr><td><strong>指针需求</strong></td><td>不需要</td><td><strong>必须</strong>通过 <code>Box</code>, <code>&amp;</code> 等指针使用</td></tr>
</tbody>
</table>
</div>
<h3 id="特征对象安全-object-safety"><a class="header" href="#特征对象安全-object-safety">特征对象安全 (Object Safety)</a></h3>
<p>并非所有的 <code>trait</code> 都能转换成 <code>dyn Trait</code> 对象。为了保证对象安全，<code>trait</code> 必须满足以下条件：</p>
<ol>
<li>方法的返回类型不能是 <code>Self</code>。</li>
<li>方法不能有泛型类型参数。</li>
<li>方法的第一参数必须是 <code>&amp;self</code>, <code>&amp;mut self</code>, <code>Box&lt;Self&gt;</code> 等（不能没有 <code>self</code>）。</li>
</ol>
<blockquote>
<p><strong>笔记要点</strong>：如果一个 <code>trait</code> 不满足“对象安全”，你只能将其用作泛型约束（静态分发），而不能创建特征对象。</p>
</blockquote>
<hr>
<h2 id="9-where-子句与-trait-约束"><a class="header" href="#9-where-子句与-trait-约束">9. <strong><code>where</code> 子句与 trait 约束</strong></a></h2>
<ul>
<li><code>where</code> 子句可以用来指定泛型参数的 trait 约束，这使得代码更加清晰和可读。</li>
</ul>
<h3 id="示例where-子句和-trait-约束"><a class="header" href="#示例where-子句和-trait-约束">示例：<code>where</code> 子句和 trait 约束</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">fn print_value&lt;T&gt;(value: T) 
where
    T: std::fmt::Debug,  // 使用 where 子句进行 trait 约束
{
    println!("{:?}", value);
}

fn main() {
    print_value(42);  // 可以，因为 i32 实现了 Debug trait
    // print_value("Hello");  // 编译错误，字符串没有实现 Debug trait
}</code></pre>
<hr>
<h2 id="10-copy-和-clone-特征"><a class="header" href="#10-copy-和-clone-特征">10. <strong><code>Copy</code> 和 <code>Clone</code> 特征</strong></a></h2>
<ul>
<li><code>Copy</code> 和 <code>Clone</code> 是两个常用的 <code>trait</code>，用于控制类型的值是否可以被复制（而不是移动）。它们在处理需要复制的类型时非常重要。</li>
</ul>
<h3 id="示例使用-copy-和-clone"><a class="header" href="#示例使用-copy-和-clone">示例：使用 <code>Copy</code> 和 <code>Clone</code></a></h3>
<pre class="playground"><code class="language-rust editable edition2024">trait CustomClone {
    fn custom_clone(&amp;self) -&gt; Self;
}
#[derive(Clone)]
struct Point {
    x: i32,
    y: i32,
}
impl CustomClone for Point {
    fn custom_clone(&amp;self) -&gt; Self {
        Point { x: self.x, y: self.y }
    }
}
fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = p1.custom_clone();
    println!("p2: ({}, {})", p2.x, p2.y);
}</code></pre>
<hr>
<h2 id="11-孤儿规则-orphan-rules"><a class="header" href="#11-孤儿规则-orphan-rules">11. <strong>孤儿规则 (Orphan Rules)</strong></a></h2>
<p>这是 Rust 保证代码安全性的核心：<strong>你不能为外部类型实现外部特征</strong>。</p>
<ul>
<li><strong>规则</strong>：只有当特征或类型其中之一是在当前 crate（包）中定义的，你才能为该类型实现该特征。</li>
<li><strong>目的</strong>：防止不同库之间因为冲突的实现而导致代码行为混乱。</li>
</ul>
<p><strong>示例</strong>：你不能在自己的项目中为 <code>Vec&lt;T&gt;</code>（标准库）实现 <code>Display</code> 特征（标准库），因为两者都不是你定义的。</p>
<hr>
<h2 id="12-完全限定语法-fully-qualified-syntax"><a class="header" href="#12-完全限定语法-fully-qualified-syntax">12. <strong>完全限定语法 (Fully Qualified Syntax)</strong></a></h2>
<p>当一个类型实现的两个不同 <code>trait</code> 拥有<strong>同名方法</strong>时，Rust 需要你明确指定调用哪一个。</p>
<h3 id="示例解决同名冲突"><a class="header" href="#示例解决同名冲突">示例：解决同名冲突</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">trait Pilot {
    fn fly(&amp;self);
}
trait Wizard {
    fn fly(&amp;self);
}
struct Human;
impl Pilot for Human {
    fn fly(&amp;self) { println!("准备起飞。"); }
}
impl Wizard for Human {
    fn fly(&amp;self) { println!("飞向云端。"); }
}
fn main() {
    let person = Human;
    // person.fly(); // ❌ 报错：歧义
    
    Pilot::fly(&amp;person);  // 调用 Pilot 的实现
    Wizard::fly(&amp;person); // 调用 Wizard 的实现
}
</code></pre>
<hr>
<h2 id="13-blanket-implementations-覆盖实现"><a class="header" href="#13-blanket-implementations-覆盖实现">13. <strong>Blanket Implementations (覆盖实现)</strong></a></h2>
<p>Rust 允许你为<strong>所有</strong>满足特定特征约束的类型实现另一个特征。这在标准库中非常常见（例如 <code>ToString</code>）。</p>
<h3 id="示例覆盖实现"><a class="header" href="#示例覆盖实现">示例：覆盖实现</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">trait MyTrait {
    fn info(&amp;self);
}
// 为所有实现了 Display 的类型实现 MyTrait
impl&lt;T: std::fmt::Display&gt; MyTrait for T {
    fn info(&amp;self) {
        println!("信息: {}", self);
    }
}
fn main() {
    42.info(); // i32 实现了 Display，所以它自动拥有了 MyTrait
}</code></pre>
<hr>
<h2 id="14-标记特征-marker-traits-sized-send-sync"><a class="header" href="#14-标记特征-marker-traits-sized-send-sync">14. <strong>标记特征 (Marker Traits): <code>Sized</code>, <code>Send</code>, <code>Sync</code></strong></a></h2>
<p>标记特征没有方法定义，它们告诉编译器该类型具备某种<strong>属性</strong>。</p>
<ul>
<li><strong><code>Sized</code></strong>：编译时已知大小的类型（默认情况下泛型 <code>T</code> 都是 <code>T: Sized</code>）。</li>
<li><strong><code>?Sized</code></strong>：专门用于解除 <code>Sized</code> 限制，常用于处理 <code>dyn Trait</code> 或 <code>[T]</code>。</li>
<li><strong><code>Send</code> / <code>Sync</code></strong>：用于并发安全，标记类型是否可以安全地跨线程传递或共享。</li>
</ul>
<hr>
<h2 id="15-运算符重载-operator-overloading"><a class="header" href="#15-运算符重载-operator-overloading">15. <strong>运算符重载 (Operator Overloading)</strong></a></h2>
<p>在 Rust 中，所有的运算符（如 <code>+</code>, <code>-</code>, <code>*</code>）本质上都是通过特定的 <code>trait</code> 实现的（位于 <code>std::ops</code> 模块）。</p>
<h3 id="示例重载-"><a class="header" href="#示例重载-">示例：重载 <code>+</code></a></h3>
<pre class="playground"><code class="language-rust editable edition2024">use std::ops::Add;
#[derive(Debug, PartialEq)]
struct Point { x: i32, y: i32 }
impl Add for Point {
    type Output = Point;
    fn add(self, other: Point) -&gt; Point {
        Point { x: self.x + other.x, y: self.y + other.y }
    }
}
fn main() {
    let p1 = Point { x: 1, y: 0 } + Point { x: 2, y: 3 };
    println!("{:?}", p1); // Point { x: 3, y: 3 }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="智能指针"><a class="header" href="#智能指针">智能指针</a></h1>
<p>Rust 里“智能指针”这块，按 <strong>“它解决什么问题 + 它的所有权/借用规则 + 运行时成本”</strong> 来系统学。下面把需要掌握的知识点尽量全列出来，并按学习路径组织。</p>
<hr>
<h2 id="定义"><a class="header" href="#定义">定义</a></h2>
<h3 id="什么算智能指针"><a class="header" href="#什么算智能指针">什么算“智能指针”</a></h3>
<ul>
<li><strong>智能指针 vs 普通引用 <code>&amp;T</code> / <code>&amp;mut T</code></strong> ：智能指针是“像指针一样用（<code>Deref</code>）+ 还带管理/策略”的类型</li>
<li>三个核心 trait：
<ul>
<li><code>Deref</code> / <code>DerefMut</code>：让 <code>*p</code>、方法调用、解引用自动转换成立</li>
<li><code>Drop</code>：离开作用域时自动清理资源（RAII）</li>
<li><code>CoerceUnsized</code>/<code>DispatchFromDyn</code>（了解即可）：<code>Box&lt;T&gt;</code> 到 <code>Box&lt;dyn Trait&gt;</code> 的不定大小转换等</li>
</ul>
</li>
</ul>
<p>要理解为什么 <code>Box</code> 或 <code>String</code> 是智能指针，必须先看它们背后的两个关键特征。智能指针本质上是一个<strong>实现了 <code>Deref</code> 和 <code>Drop</code> 的结构体</strong>。</p>
<h3 id="a-deref-特征让结构体像指针"><a class="header" href="#a-deref-特征让结构体像指针">A. <code>Deref</code> 特征：让结构体“像”指针</a></h3>
<p>普通的结构体不能被解引用（即不能用 <code>*</code>）。实现了 <code>Deref</code> 之后，智能指针就可以像普通引用一样工作。</p>
<ul>
<li><strong>解引用强制转换 (Deref Coercion)</strong>：这是 <code>Rust</code> 的魔法。如果一个函数需要 <code>&amp;str</code> 参数，你传给它 <code>&amp;String</code>（<code>String</code>实现了 <code>Deref</code>），<code>Rust</code>会自动帮你转换。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">use std::ops::Deref;
struct MyBox&lt;T&gt;(T);
impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
// 实现 Deref 告诉编译器：当我对 MyBox 使用 * 时，返回内部的那个值
impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;
    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.0
    }
}
fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y); // 这里的 *y 实际上执行的是 *(y.deref())
    println!("{}", *y); 
}
</code></pre>
<h3 id="b-drop-特征自动清理的析构函数"><a class="header" href="#b-drop-特征自动清理的析构函数">B. <code>Drop</code> 特征：自动清理的“析构函数”</a></h3>
<p><code>Drop</code> 特征允许你自定义：当一个变量离开作用域时该发生什么。对于智能指针，这通常意味着<strong>释放它所拥有的堆内存</strong>。</p>
<ul>
<li><strong>自动调用</strong>：你不需要手动调用 <code>drop</code>，Rust 会自动在变量生命周期结束时插入清理代码。</li>
<li><strong>防止泄漏</strong>：有了 <code>Drop</code>，Rust 确保了即便程序在中间出错退出，堆内存也会被正确回收。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">struct CustomSmartPointer {
    data: String,
}
impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!("正在清理数据: {}！", self.data);
    }
}
fn main() {
    let c = CustomSmartPointer { data: String::from("我的数据") };
    let d = CustomSmartPointer { data: String::from("其他数据") };
    println!("智能指针已创建。");
    // 函数结束时，d 先被清理，c 后被清理（先进后出）
}
</code></pre>
<p>智能指针通过 <code>Deref</code> 让我们能方便地访问数据，通过 <code>Drop</code> 让我们不再担心内存回收。</p>
<hr>
<h2 id="1-boxt堆分配--递归类型"><a class="header" href="#1-boxt堆分配--递归类型">1. <code>Box&lt;T&gt;</code>：堆分配 &amp; 递归类型</a></h2>
<p>你要会的点：</p>
<ul>
<li><strong>什么时候需要 <code>Box</code></strong>
<ul>
<li>把值放到<strong>堆</strong>上（存储实际的数据 <code>T</code>）,而在<strong>栈</strong>(存储指针地址,64 位系统通常是8字节）上仅保留一个指向堆数据的指针</li>
<li>处理  <strong>递归类型</strong> （编译期需要知道每个类型占用多少内存空间–如：链表）</li>
<li>作为 <strong>trait object</strong> 的持有者：当你需要一个“实现了某个特征的类型”而不是具体类型时，通常使用<code>Box&lt;dyn Trait&gt;</code></li>
<li>转移大数据所有权,如果你有一个非常大的结构体或数组，将其作为参数传递给函数时，如果不使用指针，<code>Rust</code>默认会进行栈拷贝，这非常消耗性能。</li>
</ul>
</li>
<li><strong>所有权语义</strong> ：<code>Box&lt;T&gt;</code> 独占所有权，同一时间只能有一个 <code>Box</code> 指向该堆数据,移动后原变量不可用</li>
<li><strong>解引用与方法调用</strong> ：<code>Box&lt;T&gt;</code> 自动 <code>Deref</code> 到 <code>T</code></li>
</ul>
<h3 id="示例递归类型链表"><a class="header" href="#示例递归类型链表">示例：递归类型（链表）</a></h3>
<pre><code class="language-rust ignore">enum List {
    Cons(i32, List), // 错误：List 包含 List，会导致无限大小
    Nil,
}</code></pre>
<p>编译器会报错，因为 Cons 变体包含另一个 <code>List</code>，这会形成无限递归，编译器无法计算 <code>List</code> 结构的大小。解决方案： 使用<code>Box</code> 智能指针，将递归类型“在堆上间接存储”，<code>List</code>本身就有固定大小了。</p>
<pre class="playground"><code class="language-rust editable edition2024">// 递归 enum：如果没有 Box，编译器无法在编译期知道 List 的大小。
// Box&lt;List&gt; 让递归“在堆上间接存储”，List 本身就有固定大小了。
#[derive(Debug)]
enum List {
    Cons(i32, Box&lt;List&gt;),//Cons 占用：一个 i32 的空间 + 一个指针的空间
    Nil,
}
impl List {
    fn new() -&gt; Self {
        List::Nil
    }
    fn prepend(self, v: i32) -&gt; Self {
        List::Cons(v, Box::new(self))
    }
    fn len(&amp;self) -&gt; usize {
        match self {
            List::Cons(_, next) =&gt; 1 + next.len(),
            List::Nil =&gt; 0,
        }
    }
}
fn main() {
    let list = List::new().prepend(3).prepend(2).prepend(1);
    println!("{list:?}");
    println!("len = {}", list.len());
}</code></pre>
<h3 id="示例返回-trait-object动态分发"><a class="header" href="#示例返回-trait-object动态分发">示例：返回 trait object（动态分发）</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">trait Draw {
    fn draw(&amp;self);
}
struct Circle {r: f32}
impl Draw for Circle {
    fn draw(&amp;self) {
        println!("Circle radius = {}", self.r);
    }
}
struct Square {side: f32}
impl Draw for Square {
    fn draw(&amp;self) {
        println!("Square side = {}", self.side);
    }
}
// 返回 Box&lt;dyn Draw&gt;：调用者只知道“它能 draw”，不关心具体类型。
// 这会使用动态分发（vtable）。
fn make_shape(kind: &amp;str) -&gt; Box&lt;dyn Draw&gt; {
    match kind {
        "circle" =&gt; Box::new(Circle { r: 2.0 }),
        _ =&gt; Box::new(Square { side: 3.0 }),
    }
}
fn main() {
    let s1 = make_shape("circle");
    let s2 = make_shape("square");
    s1.draw();
    s2.draw();
}</code></pre>
<hr>
<h2 id="2-rct单线程引用计数共享所有权"><a class="header" href="#2-rct单线程引用计数共享所有权">2. <code>Rc&lt;T&gt;</code>：单线程引用计数共享所有权</a></h2>
<p>在 <code>Rust</code> 的所有权规则中，通常一个值只能有一个所有者。但在某些复杂的应用场景中（例如图结构、社交网络或共享配置），一个数据可能需要被多个不同的部分共同拥有。这时，<code>Box&lt;T&gt;</code> 的独占所有权就不够用了，我们需要 <code>Rc&lt;T&gt;</code>(<code>Reference Counted</code>引用计数)。</p>
<p>你要会的点：</p>
<ul>
<li><strong>为什么需要 Rc</strong> ：它允许一个数据拥有多个所有者。它在堆上存储数据，并额外记录一个“引用计数器”，用来统计目前有多少个指针指向这份数据</li>
<li><strong>只读共享</strong>：<code>Rc&lt;T&gt;</code> 默认只允许你不可变地借用数据。如果你想通过其中一个 <code>Rc</code> 修改数据，编译器会拒绝（除非配合后面要讲的 <code>RefCell</code>）。</li>
<li><strong>共享而非拷贝</strong>：当你“克隆”一个 <code>Rc&lt;T&gt;</code> 时，Rust 并不会在堆上重新分配内存并拷贝数据，而是
<ul>
<li><strong>增加引用计数</strong>：计数器加 1。</li>
<li><strong>拷贝指针地址</strong>：在栈上创建一个新的指针指向同一个堆位置。</li>
<li>只有当<strong>计数器归零</strong>时: 堆上的数据才会被真正清理。</li>
</ul>
</li>
<li><strong>强引用/弱引用</strong>
<ul>
<li><code>Rc::clone(&amp;rc)</code> 增加强引用计数（不是深拷贝）</li>
<li><code>Weak&lt;T&gt;</code> 用于打破环，避免内存泄漏</li>
</ul>
</li>
<li><strong>循环引用问题</strong> ：<code>Rc</code> 形成环会  <strong>泄漏</strong> （计数永远不为 0）</li>
<li>常用 API：<code>Rc::new</code>、<code>Rc::clone</code>、<code>Rc::strong_count</code>、<code>Rc::weak_count</code>、<code>Rc::downgrade</code></li>
</ul>
<h3 id="示例共享一段数据"><a class="header" href="#示例共享一段数据">示例：共享一段数据</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">use std::rc::Rc;
fn main() {
    // 1. 在堆上创建共享数据，初始计数为 1
    let config = Rc::new(String::from("核心配置程序"));
    
    println!("--- 初始状态 ---");
    println!("内容: {}", config);
    println!("引用计数: {}", Rc::strong_count(&amp;config));

    // 2. 共享数据：创建两个新的指针指向同一块堆内存
    // Rc::clone 仅增加计数，不会拷贝字符串文本
    let user_a = Rc::clone(&amp;config);
    let user_b = Rc::clone(&amp;config);

    println!("\n--- 共享后 ---");
    println!("User A 看到的内容: {}", user_a);
    println!("User B 看到的内容: {}", user_b);
    println!("当前总引用计数: {}", Rc::strong_count(&amp;config));

    // 3. 释放其中一个引用
    drop(user_a);
    println!("\n--- 释放 User A 后 ---");
    println!("剩余引用计数: {}", Rc::strong_count(&amp;config));
}</code></pre>
<ul>
<li><strong>内存物理表现</strong>：<code>config</code>、<code>user_a</code> 和 <code>user_b</code> 是三个存储在栈上的指针，它们内部存储的内存地* 址完全相同，都指向堆上的同一个 <code>String</code>。</li>
<li><strong>内容访问</strong>：由于实现了 <code>Deref</code> 特征，你可以像使用普通 <code>String</code> 一样直接打印 <code>user_a</code> 或 <code>user_b</code>。</li>
<li><strong>计数变化</strong>：每次调用 <code>Rc::clone</code>，计数器加 1；每次指针离开作用域（或被 <code>drop</code>），计数器减 1。</li>
</ul>
<h3 id="强引用-strong-reference-与-弱引用-weak-reference"><a class="header" href="#强引用-strong-reference-与-弱引用-weak-reference">强引用 (Strong Reference) 与 弱引用 (Weak Reference)</a></h3>
<p>这是管理 <code>Rc</code> 生命周期的两种手段：</p>
<ul>
<li>
<p><strong>强引用 (<code>Rc&lt;T&gt;</code>)</strong>：</p>
<ul>
<li><strong>行为</strong>：使用 <code>Rc::clone(&amp;rc)</code> 会增加<strong>强引用计数</strong>。</li>
<li><strong>本质</strong>：它不是深拷贝（Deep Copy），只是在栈上多了一个指向堆内存的指针，并在堆上把计数器加 1。</li>
<li><strong>作用</strong>：只要强引用计数大于 0，堆上的数据就<strong>绝对不会</strong>被销毁。</li>
</ul>
</li>
<li>
<p><strong>弱引用 (<code>Weak&lt;T&gt;</code>)</strong>：</p>
<ul>
<li><strong>行为</strong>：通过 <code>Rc::downgrade(&amp;rc)</code> 创建。</li>
<li><strong>本质</strong>：它会增加<strong>弱引用计数</strong>，但<strong>不影响</strong>强引用计数。</li>
<li><strong>作用</strong>：它不拥有数据的所有权。即便还有 100 个 <code>Weak</code> 指针指向数据，只要强引用计数归零，数据依然会被清理。</li>
<li><strong>使用</strong>：因为数据可能已被销毁，使用前必须通过 <code>weak_ptr.upgrade()</code> 将其“升级”回 <code>Option&lt;Rc&lt;T&gt;&gt;</code> 进行检查。</li>
</ul>
</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">use std::rc::Rc;
fn main() {
    // 1. 创建一个强引用 Rc
    let strong_ptr = Rc::new(String::from("Rust 智能指针"));
    
    // 2. 从强引用创建一个弱引用
    // downgrade 不会增加 strong_count
    let weak_ptr = Rc::downgrade(&amp;strong_ptr);
    let weak_ptr2 = Rc::downgrade(&amp;strong_ptr);

    println!("--- 初始状态 ---");
    println!("强引用计数: {}", Rc::strong_count(&amp;strong_ptr)); // 1
    println!("弱引用计数: {}", Rc::weak_count(&amp;strong_ptr));   // 2

    // 3. 尝试使用弱引用访问数据
    // 必须通过 upgrade() 升级为 Option&lt;Rc&lt;T&gt;&gt;
    match weak_ptr.upgrade() {
        Some(rc) =&gt; println!("弱引用升级成功，得到数据: {}", rc),
        None =&gt; println!("弱引用升级失败，数据已销毁"),
    }

    // 销毁一个弱引用
    drop(weak_ptr2);
    println!("销毁一个弱引用后强引用计数: {}", Rc::strong_count(&amp;strong_ptr)); // 1
    println!("销毁一个弱引用后弱引用计数: {}", Rc::weak_count(&amp;strong_ptr));   // 1

    println!("\n--- 销毁强引用后 ---");
    // 4. 手动销毁强引用（模拟离开作用域）
    drop(strong_ptr);

    // 5. 再次尝试使用弱引用访问数据
    // 此时强引用计数为 0，数据已被回收
    match weak_ptr.upgrade() {
        Some(rc) =&gt; println!("弱引用升级成功: {}", rc),
        None =&gt; println!("弱引用升级失败，数据已销毁"),
    }
}</code></pre>
<h3 id="rc-环"><a class="header" href="#rc-环">Rc 环</a></h3>
<p><strong>循环引用问题</strong>:这是<code>Rc</code> 最危险的陷阱。</p>
<ul>
<li><strong>成因</strong>：如果两个 <code>Rc</code> 指针互相指向对方（例如：节点 A 拥有指向节点 B 的 Rc，而节点 B 也拥有指向节点 A 的 Rc），就会形成一个环。</li>
<li><strong>后果</strong>：由于环的存在，这两个对象的强引用计数永远至少为 1。当外部作用域结束时，它们无法被清理，导致<strong>内存泄漏</strong>（<code>Memory Leak</code>）。</li>
<li><strong>解决方案</strong>：将其中一条路径改为 <code>Weak&lt;T&gt;</code>。例如：父节点用 <code>Rc</code> 指向子节点（强引用），而子节点用 <code>Weak</code> 指向父节点（弱引用）。这样环就被打破了。</li>
</ul>
<p>由于 <code>Rc&lt;T&gt;</code> 默认是只读的，为了在创建节点后能修改指针指向对方，我们需要配合使用 <code>RefCell&lt;T&gt;</code>演示环形引用。</p>
<pre class="playground"><code class="language-rust editable edition2024">use std::rc::Rc;
use std::cell::RefCell;
// 定义一个简单的 Node，它可以指向另一个 Node
#[derive(Debug)]
struct Node {
    next: RefCell&lt;Option&lt;Rc&lt;Node&gt;&gt;&gt;,
}
impl Drop for Node {
    fn drop(&amp;mut self) {
        println!("Node 被销毁了！");
    }
}
fn main() {
    // 1. 创建两个节点 A 和 B
    let a = Rc::new(Node { next: RefCell::new(None) });
    let b = Rc::new(Node { next: RefCell::new(None) });

    println!("--- 建立环之前 ---");
    println!("A 的强引用计数: {}", Rc::strong_count(&amp;a)); // 1
    println!("B 的强引用计数: {}", Rc::strong_count(&amp;b)); // 1

    // 2. 建立环：A 指向 B，B 指向 A
    *a.next.borrow_mut() = Some(Rc::clone(&amp;b));
    *b.next.borrow_mut() = Some(Rc::clone(&amp;a));

    println!("--- 建立环之后 ---");
    println!("A 的强引用计数: {}", Rc::strong_count(&amp;a)); // 2
    println!("B 的强引用计数: {}", Rc::strong_count(&amp;b)); // 2

    // 3. 函数结束前，我们尝试让 a 和 b 离开作用域
    println!("--- main 函数即将结束 ---");
} 
// 正常情况下，这里应该打印两次 "Node 被销毁了！"，但实际上什么都不会打印。</code></pre>
<blockquote>
<p>笔记：为什么会泄漏？</p>
</blockquote>
<ul>
<li><strong>计数器逻辑</strong>：当 main 函数结束时，变量 a 和 b 被丢弃。
<ul>
<li><strong>a 被丢弃</strong>，其对应的堆内存计数从 2 降到 1。</li>
<li><strong>b 被丢弃</strong>，其对应的堆内存计数从 2 降到 1。</li>
</ul>
</li>
<li><strong>死循环</strong>：堆内存 A 还在等待堆内存 B 释放以便将其计数减为 0；而堆内存 B 也在等待堆内存 A 释放。</li>
<li><strong>结果</strong>：两个内存块的计数器永远卡在 1，drop 方法永远不会被触发，这块堆内存就泄漏了。</li>
</ul>
<h4 id="解决方案"><a class="header" href="#解决方案">解决方案</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">use std::cell::RefCell;
use std::rc::{Rc, Weak};

// 一个“父-子”节点结构：
// - 子节点用 Rc 拥有（多个地方可以共享孩子）
// - 父指针用 Weak 指向父（避免形成 Rc 环）
#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,  // Weak&lt;Node&gt;：这是指向父节点的指针, Weak 不增加强引用计数
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,    // children 拥有子节点
}
impl Drop for Node {
    fn drop(&amp;mut self) {
        println!("Node 被销毁了！");
    }
}
fn main() {
    let parent = Rc::new(Node {
        value: 1,
        parent: RefCell::new(Weak::new()),// 初始化时，父节点没有“父”，设为空弱引用
        children: RefCell::new(vec![]),// 初始化时，子节点列表为空向量
    });//将 Node 实例放入堆中，并返回一个智能指针，此时 parent 的强引用计数为 1，弱计数 = 0

    let child = Rc::new(Node {
        value: 2,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });//child 的强计数 = 1，弱计数 = 0

    // 建立父 -&gt; 子 的强引用关系
    parent.children.borrow_mut().push(Rc::clone(&amp;child));
    // 通过 borrow_mut() 获取 Vec 的可变借用，然后把 child 的一个克隆存进去。
    // 此时 child 的强引用计数变为 2（一个是变量 child，一个是 parent.children 里的克隆）

    // 建立子 -&gt; 父 的弱引用关系（关键：避免环）
    *child.parent.borrow_mut() = Rc::downgrade(&amp;parent);
    //通过 Rc::downgrade 将 parent 的强引用转为弱引用并存入 child.parent
    //parent 的强计数保持为 1。parent 的弱计数变为 1。

    println!("parent strong = {}, weak = {}",
        Rc::strong_count(&amp;parent),
        Rc::weak_count(&amp;parent)
    );
    println!("child strong = {}, weak = {}",
        Rc::strong_count(&amp;child),
        Rc::weak_count(&amp;child)
    );

    // Weak::upgrade：尝试把 Weak 变回 Rc（如果父节点已释放则返回 None）
    if let Some(p) = child.parent.borrow().upgrade() {
        println!("child's parent value = {}", p.value);
    } else {
        println!("parent already dropped");
    }
}
</code></pre>
<blockquote>
<p>核心设计：为什么这样设计结构？</p>
</blockquote>
<p>在 Rust 中，指针是表示内存地址的类型。为了实现父子双向链接，代码采用了“强弱结合”的策略：</p>
<ul>
<li><code>children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;</code>(向下强引用)：
<ul>
<li>父节点需要“拥有”它的子节点，所以使用 <code>Rc&lt;Node&gt;</code>。只要父节点存在，子节点就不会被销毁。</li>
</ul>
</li>
<li><code>parent: RefCell&lt;Weak&lt;Node&gt;&gt;</code> (向上弱引用)：
<ul>
<li>这是破环关键。子节点只需要“知道”父节点是谁，但不应该“拥有”父节点。</li>
<li>使用 <code>Weak&lt;Node&gt;</code> 不会增加父节点的强引用计数，因此不会阻止父节点被回收。</li>
</ul>
</li>
<li><code>RefCell</code>(内部可变性)：
<ul>
<li>因为节点创建时是孤立的，必须在创建后修改属性（建立连接），所以需要 RefCell 绕过编译期的不可变检查。</li>
</ul>
</li>
</ul>
<div class="table-wrapper">
<table>
<thead>
<tr><th>执行阶段</th><th>Parent 计数 (Strong/Weak)</th><th>Child 计数 (Strong/Weak)</th><th>逻辑说明</th></tr>
</thead>
<tbody>
<tr><td>创建后</td><td>1 / 0</td><td>1 / 0</td><td>变量 parent 和 child 各自拥有 1 个所有权</td></tr>
<tr><td>建立父-&gt;子连接</td><td>1 / 0</td><td>2 / 0</td><td>parent.children 存了一个 Rc::clone(&amp;child)，强计数加 1</td></tr>
<tr><td>建立子-&gt;父连接</td><td>1 / 1</td><td>2 / 0</td><td>child.parent 存了一个 downgrade(&amp;parent)，仅增加弱计数</td></tr>
</tbody>
</table>
</div>
<h3 id="常用-api-速查表"><a class="header" href="#常用-api-速查表">常用 API 速查表</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>API</th><th>功能描述</th></tr>
</thead>
<tbody>
<tr><td><code>Rc::new(val)</code></td><td>创建一个新的 Rc 实例，初始强计数为 1。</td></tr>
<tr><td><code>Rc::clone(&amp;rc)</code></td><td>增加强引用计数，返回新指针。</td></tr>
<tr><td><code>Rc::strong_count(&amp;rc)</code></td><td>查看当前的强引用数量。</td></tr>
<tr><td><code>Rc::weak_count(&amp;rc)</code></td><td>查看当前的弱引用数量。</td></tr>
<tr><td><code>Rc::downgrade(&amp;rc)</code></td><td>获取一个 <code>Weak&lt;T&gt;</code> 指针。</td></tr>
<tr><td><code>weak.upgrade()</code></td><td>尝试将弱引用转回强引用，返回 <code>Option&lt;Rc&lt;T&gt;&gt;</code>。</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="3-arct多线程引用计数共享所有权"><a class="header" href="#3-arct多线程引用计数共享所有权">3. <code>Arc&lt;T&gt;</code>：多线程引用计数共享所有权</a></h2>
<p>如果在多线程环境下使用 <code>Rc&lt;T&gt;</code>，编译器会直接报错，因为 <code>Rc&lt;T&gt;</code> 内部的引用计数是非原子的，无法在多个线程间安全地更新。为了解决这个问题，<code>Rust</code> 提供了 <code>Arc&lt;T&gt;</code>（<code>Atomic Reference Counted</code> 原子引用计数）,它允许在多个线程之间安全地共享同一个堆数据的所有权。和 <code>Rc&lt;T&gt;</code> 一样，<code>Arc&lt;T&gt;</code> 默认也是只读的。如果你需要多个线程同时修改数据，你还需要配合下一阶段我们要讲的锁机制（如 Mutex）。</p>
<p>在计算机中，普通的整数加减（如 <code>count += 1</code>）并不是一个不可分割的操作。如果两个线程同时尝试修改 <code>Rc</code> 的计数器，可能会导致计数错误，进而引发提前释放内存或内存泄漏。<code>Arc&lt;T&gt;</code> 使用了 原子操作来更新计数。这是一种硬件层面的特殊指令，能确保在多线程竞争时计数器依然准确。</p>
<p>你要会的点：</p>
<ul>
<li><code>Arc</code> = Atomic Rc（线程安全，计数操作是原子的）</li>
<li>成本：比 <code>Rc</code> 更贵（原子操作），单线程场景优先 <code>Rc</code>以获得最佳性能</li>
<li>常见组合：<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>、<code>Arc&lt;RwLock&lt;T&gt;&gt;</code></li>
<li>线程安全标志：
<ul>
<li><strong><code>Rc&lt;T&gt;</code></strong> 未实现 <code>Send</code> 和 <code>Sync</code> 特征，因此不能跨线程传递</li>
<li><strong><code>Arc&lt;T&gt;</code></strong> 实现了 <code>Send</code> 和 <code>Sync</code>（前提是内部的 <code>T</code> 也是线程安全的），可以在线程间自由穿梭</li>
</ul>
</li>
</ul>
<h3 id="示例多线程共享只读"><a class="header" href="#示例多线程共享只读">示例：多线程共享只读</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">use std::sync::Arc;
use std::thread;
fn main() {
    // 1. 创建一个 Arc 指针
    let data = Arc::new(String::from("多线程共享数据"));
    println!("Arc-data 初始计数: {}", Arc::strong_count(&amp;data));
    let mut handles = vec![];
    for i in 0..5 {
        // 2. 克隆 Arc 指针：这只是增加原子计数，不拷贝字符串本身
        let data_clone = Arc::clone(&amp;data);
        let handle = thread::spawn(move || {
            // 3. 在子线程中使用数据
            println!("线程 {} 看到的数据: {}", i, data_clone);
        });
        handles.push(handle);
    }
    // 等待所有线程结束
    for handle in handles {
        handle.join().unwrap();
    }
    println!("所有线程已完成，最后计数: {}", Arc::strong_count(&amp;data));
}</code></pre>
<hr>
<h2 id="4-线程安全内部可变性mutext--rwlockt"><a class="header" href="#4-线程安全内部可变性mutext--rwlockt">4. 线程安全内部可变性：<code>Mutex&lt;T&gt;</code> / <code>RwLock&lt;T&gt;</code></a></h2>
<p>在多线程环境下，单靠 <code>Arc&lt;T&gt;</code> 只能解决“谁拥有数据”的问题，但由于 <code>Arc&lt;T&gt;</code> 提供的引用是不可变的，我们无法修改数据。为了在多线程中修改数据，我们需要使用“<strong>锁</strong>”。</p>
<p>你要会的点：</p>
<ul>
<li><code>Mutex&lt;T&gt;</code>：互斥锁，提供独占可变访问（锁守卫 <code>MutexGuard</code>）</li>
<li><code>RwLock&lt;T&gt;</code>：读写锁，多读单写</li>
<li><strong>死锁、锁粒度、持锁时间</strong> （工程上很关键）</li>
<li>常见组合：<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>、<code>Arc&lt;RwLock&lt;T&gt;&gt;</code></li>
<li>运行时成本：加锁/解锁、竞争、可能阻塞</li>
</ul>
<h3 id="示例mutext-互斥锁"><a class="header" href="#示例mutext-互斥锁">示例：<code>Mutex&lt;T&gt;</code> (互斥锁)</a></h3>
<p><code>Mutex</code> 是 <code>Mutual Exclusion</code>（互斥）的缩写。它保证在任何时刻，只有一个线程可以访问数据。</p>
<p>工作机制：</p>
<ol>
<li>线程尝试通过 <code>.lock()</code> 获取锁。</li>
<li>如果锁已被占用，线程会阻塞（等待）。</li>
<li>获取成功后，返回一个 <code>MutexGuard</code>（智能指针）。</li>
<li><strong>自动释放</strong>：由于 <code>MutexGuard</code> 实现了 <code>Drop</code> 特征，当它离开作用域时，锁会自动释放，无需手动解锁。</li>
</ol>
<pre class="playground"><code class="language-rust editable edition2024">use std::sync::Mutex;
fn main() {
    let m = Mutex::new(5);
    {
        // lock() 返回一个 Result，因为如果另一个线程在持有锁时 panic，锁会变得“中毒”
        let mut num = m.lock().unwrap(); 
        *num = 6; // 通过解引用修改内部数据
    } // num 离开作用域，锁自动释放

    println!("m = {:?}", m);
}</code></pre>
<h3 id="示例rwlockt-读写锁"><a class="header" href="#示例rwlockt-读写锁">示例：<code>RwLock&lt;T&gt;</code> (读写锁)</a></h3>
<p>RwLock 代表 <code>Read-Write Lock</code>。它比 Mutex 更灵活，遵循“多读单写”规则：</p>
<ul>
<li><strong>多读</strong>：允许多个线程同时持有只<strong>读锁</strong> (<code>.read()</code>)。</li>
<li><strong>单写</strong>：同一时间只允许一个线程持有<strong>写锁</strong> (<code>.write()</code>)。此时<strong>不允许任何读锁</strong>。</li>
</ul>
<p><strong>适用场景</strong>：适用于“<strong>读多写少</strong>”的场景，性能通常优于 <code>Mutex</code>。</p>
<p><code>Mutex&lt;T&gt;</code> 的规则很简单：任何人要用，必须排队。
而 <code>RwLock&lt;T&gt;</code> 引入了“多读”逻辑，这虽然提高了并发效率，但也让逻辑变得复杂：你不能直接把一个读锁“升级”为写锁。你必须先释放读锁，然后再去竞争写锁</p>
<pre class="playground"><code class="language-rust editable edition2024">use std::sync::{Arc, RwLock};
use std::thread;
use std::time::Duration;
fn main() {
    // 1. 使用 Arc 包装 RwLock，实现多线程共享所有权
    let lock = Arc::new(RwLock::new(5));
    let mut handles = vec![];
    // --- 模拟多个读取者 ---
    for i in 0..3 {
        let lock_clone = Arc::clone(&amp;lock);
        let handle = thread::spawn(move || {
            // 获取读锁：允许多个线程同时进入此处
            let r = lock_clone.read().unwrap();
            println!("读者 {} 读取到的值: {}", i, *r);
            // 读锁在这里自动释放
        });
        handles.push(handle);
    }
    // --- 模拟一个写入者 ---
    {
        let lock_clone = Arc::clone(&amp;lock);
        let handle = thread::spawn(move || {
            println!("写入者正在尝试获取写锁...");
            // 获取写锁：此时所有读锁和其他写锁都会被阻塞
            let mut w = lock_clone.write().unwrap();
            *w += 10;
            println!("写入者已将值修改为: {}", *w);
            // 写锁在这里自动释放
        });
        handles.push(handle);
    }
    // 等待所有线程结束
    for handle in handles {
        handle.join().unwrap();
    }

    println!("最终结果: {}", *lock.read().unwrap());
}</code></pre>
<h4 id="关键细节解析"><a class="header" href="#关键细节解析">关键细节解析</a></h4>
<ul>
<li>
<p><strong><code>.read().unwrap()</code></strong>：</p>
<ul>
<li>返回一个 <code>ReadGuard</code>。只要这个 guard 存在，其他线程也可以调用 <code>.read()</code> 获取读锁。</li>
<li><strong>限制</strong>：一旦有人持有读锁，任何尝试调用 <code>.write()</code> 的线程都会进入睡眠等待状态。</li>
</ul>
</li>
<li>
<p><strong><code>.write().unwrap()</code></strong>：</p>
<ul>
<li>返回一个 <code>WriteGuard</code>。</li>
<li><strong>排他性</strong>：只有当没有任何人持有读锁且没有任何人持有写锁时，它才能成功获取。</li>
</ul>
</li>
<li>
<p><strong>死锁风险</strong>：</p>
<ul>
<li>如果在同一个线程中，你已经持有了读锁，又尝试去获取写锁，会导致<strong>死锁</strong>。</li>
<li>在写操作频繁的场景下，可能会出现“读者饥饿”。</li>
</ul>
</li>
</ul>
<h3 id="总结对比mutex-vs-rwlock"><a class="header" href="#总结对比mutex-vs-rwlock">总结对比：<code>Mutex</code> vs <code>RwLock</code></a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>特性</th><th><code>Mutex&lt;T&gt;</code></th><th><code>RwLock&lt;T&gt;</code></th></tr>
</thead>
<tbody>
<tr><td>访问规则</td><td>一次只能一个线程访问,</td><td>多个读者 OR 一个写者</td></tr>
<tr><td>内部可变性</td><td>是（通过锁获取可变引用）</td><td>是（通过写锁获取可变引用）</td></tr>
<tr><td>线程安全</td><td>是</td><td>是</td></tr>
<tr><td>性能</td><td>简单、开销固定</td><td>读操作多时性能更好，管理成本略高</td></tr>
</tbody>
</table>
</div>
<blockquote>
<p>💡 笔记要点：为什么它们也叫“内部可变性”？</p>
</blockquote>
<p>因为即使你只有一个指向 <code>Mutex&lt;T&gt;</code> 的不可变引用 <code>&amp;Mutex&lt;T&gt;</code>，你依然可以通过调用 <code>.lock()</code> 方法来修改其内部包裹的数据。这种“<strong>外表不可变，内部可变</strong>”的特性正是它们被称为内部可变性的原因。</p>
<h3 id="示例多线程共享可变arcmutext"><a class="header" href="#示例多线程共享可变arcmutext">示例：多线程共享可变（<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>）</a></h3>
<p><strong>核心分工:</strong></p>
<ul>
<li>Arc（<strong>所有权管理者</strong>）：解决“<strong>谁拥有数据</strong>”的问题。它让多个线程可以同时持有指向同一个堆内存的指针</li>
<li>Mutex（<strong>访问权限管理者</strong>）：解决“<strong>谁能修改数据</strong>”的问题。它确保即使多个线程都有指针，同一时间也只有一个线程能真正碰到里面的数据</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">use std::sync::{Arc, Mutex};
use std::thread;
fn main() {
    let counter = Arc::new(Mutex::new(0));//最外层是 Arc，给这把锁加上引用计数功能,中间层是 Mutex，给数据加上一把锁
    let mut handles = vec![];
    for _ in 0..4 {
        let c = Arc::clone(&amp;counter);//克隆的是指针地址和计数器，锁和数据始终只有一份
        handles.push(thread::spawn(move || {
            // lock() 返回一个 guard：guard 活着就持有锁
            let mut guard = c.lock().unwrap();
            *guard += 1;
            // 不需要手动写 unlock(), guard drop 时自动解锁（RAII）
        }));
    }
    for h in handles {
        h.join().unwrap();
    }
    println!("counter = {}", *counter.lock().unwrap()); // 4
}
</code></pre>
<h3 id="示例多线程共享可变读多写少arcrwlockt"><a class="header" href="#示例多线程共享可变读多写少arcrwlockt">示例：多线程共享可变（读多写少<code>Arc&lt;RwLock&lt;T&gt;&gt;</code>）</a></h3>
<p><strong>核心分工:</strong></p>
<ul>
<li>Arc：解决“<strong>谁拥有数据</strong>”的问题，确保堆内存地址在所有线程执行完毕前保持有效。</li>
<li>RwLock：解决“<strong>如何高效访问</strong>”的问题。它允许 100 个线程同时读取（并发），但只要有 1 个线程在写，其他人都必须等待（排他）。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">use std::sync::{Arc, RwLock};
use std::thread;
use std::time::Duration;
fn main() {
    // 1. 初始化数据，Arc 负责跨线程共享，RwLock 负责并发权限
    let data = Arc::new(RwLock::new(0));
    let mut handles = vec![];
    let start_time = std::time::Instant::now();
    // 2. 开启 5 个读者线程
    for i in 0..5 {
        let d = Arc::clone(&amp;data);
        handles.push(thread::spawn(move || {
            // 获取读锁：注意！多个线程可以同时成功获取读锁
            let _guard = d.read().unwrap();
            println!("读者 {} 正在读取...", i);
            // 模拟一个耗时的读取操作（1秒）
            thread::sleep(Duration::from_secs(1)); 
            println!("读者 {} 读取完毕", i);
        }));
    }
    // 3. 开启 1 个写者线程
    let d_writer = Arc::clone(&amp;data);
    handles.push(thread::spawn(move || {
        // 模拟等待一段时间再写，确保读者们已经先拿到了锁
        thread::sleep(Duration::from_millis(500));
        println!("写者：尝试获取写锁（会被阻塞，直到所有读者读完）...");
        // 获取写锁：必须等所有读锁释放
        let mut w = d_writer.write().unwrap();
        *w += 1;
        println!("写者：修改完毕！");
    }));
    for h in handles {
        h.join().unwrap();
    }
    println!("--- 总耗时: {:?} ---", start_time.elapsed());
}</code></pre>
<h4 id="代码逻辑深度拆解"><a class="header" href="#代码逻辑深度拆解">代码逻辑深度拆解</a></h4>
<ul>
<li>读锁并发 (<code>.read().unwrap()</code>)
<ul>
<li>当 <code>reader1</code> 调用 <code>read()</code> 时，如果此时没有写线程，它会立即获得 <code>ReadGuard</code>。</li>
<li><strong>优势</strong>：如果有 <code>reader2、reader3</code> 同时进来，只要当前没有线程持有“写锁”, 它们都可以获取读锁。这比 <code>Mutex</code> 快得多，因为 <code>Mutex</code> 会强制让读者也排队。</li>
</ul>
</li>
<li>写锁独占 (<code>.write().unwrap()</code>)：
<ul>
<li>当 <code>writer</code> 调用 <code>write()</code> 时，写锁具有排他性, 它必须等待所有正在读取的线程释放读锁，且没有其他写线程在工作。反之，只要有任何读锁未释放，写锁获取也会被阻塞。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-celltcopy-类型的轻量内部可变性"><a class="header" href="#5-celltcopy-类型的轻量内部可变性">5. <code>Cell&lt;T&gt;</code>：<code>Copy</code> 类型的轻量内部可变性</a></h2>
<p>在掌握了 <code>Rc</code> 和 <code>Arc</code> 之后，你可能已经发现它们默认是<strong>不可变共享</strong>的。为了在“不可变”的外壳下修改数据，我们需要<strong>内部可变性</strong>（<code>Interior Mutability</code>）。</p>
<p>在 <code>Rust</code> 中，如果你使用普通引用，最怕的是：“<strong>我手里拿着指向数据的指针，结果别人把数据改了/删了，导致我手里的指针失效</strong>”。
但 <code>Cell</code> 完美避开了这个问题，因为它禁止你获取内部数据的指针：</p>
<ul>
<li>没有借用：你调用 <code>c.get()</code> 时，它直接给你一个全新的副本。你手里的副本和 <code>Cell</code> 里面的原始数据已经没关系了。</li>
<li>随便覆盖：既然谁也拿不到指向 <code>Cell</code> 内部的指针，那么无论你调用多少次 <code>set</code>，都只是在修改那一块内存的值，不会破坏任何人的指针（因为根本没人持有指针）。</li>
</ul>
<p>你要会的点：</p>
<ul>
<li><code>Cell&lt;T&gt;</code> 主要用于实现了 <code>Copy</code> 特征的类型（如 <code>i32, bool, f64</code> 等简单类型）</li>
<li><code>Cell</code> 的操作逻辑不是“借用”，而是“<strong>值拷贝</strong>”。它不会给你内部数据的引用，而是让你把值取出来或存进去。</li>
<li>与其它智能指针不同，<code>Cell</code> 不提供 <code>.borrow()</code> 或 <code>.borrow_mut()</code> 方法,只有两个核心动作：
<ul>
<li><code>.get()</code>：返回内部值的一个<strong>全新的副本</strong>（<code>Copy</code>）</li>
<li><code>.set(value)</code>：将新值拷贝进去，覆盖旧值</li>
</ul>
</li>
<li>应用场景:
<ul>
<li><strong>简单标志位</strong>：在结构体内部存储一些状态标记（如 <code>is_valid: Cell&lt;bool&gt;</code>），即使结构体是以不可变引用的形式传递，也能随时更新这些标记。</li>
<li><strong>性能敏感场景</strong>：如果你只需要操作简单的数字或布尔值，且不需要获取它们的引用，选 <code>Cell</code> 而不是 <code>RefCell</code>。</li>
</ul>
</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">use std::cell::Cell;
fn main() {
    // 即使变量 c 本身没有声明为 mut
    let c = Cell::new(10);
    // 我们可以通过不可变引用修改它的值
    let c_ref1 = &amp;c;
    let c_ref2 = &amp;c;
    c_ref1.set(20); 
    c_ref2.set(30);
    println!("当前值: {}", c.get()); // 输出 30
}</code></pre>
<hr>
<h2 id="6-refcellt运行时借用检查内部可变性"><a class="header" href="#6-refcellt运行时借用检查内部可变性">6. <code>RefCell&lt;T&gt;</code>：运行时借用检查（内部可变性）</a></h2>
<p>如果说 <code>Cell&lt;T&gt;</code> 是通过“不给你指针”来保证安全，那么 <code>RefCell&lt;T&gt;</code>(<code>Reference Cell</code>) 就是通过<strong>雇佣一个运行时保安</strong>来让你安全地持有指针。</p>
<p>你要会的点：</p>
<ul>
<li>用于那些不方便拷贝（非 <code>Copy</code> 类型，比如 <code>Vec</code> 或自定义结构体），且你需要获取其引用的场景</li>
<li><strong>内部可变性（Interior Mutability）</strong> ：即便外面是不可变绑定，也能在内部修改</li>
<li>借用规则从编译时延后到运行时：
<ul>
<li><code>borrow()</code> 获取一个不可变引用, 得到 <code>Ref&lt;T&gt;</code></li>
<li><code>borrow_mut()</code> 获取一个可变引用, 得到 <code>RefMut&lt;T&gt;</code></li>
<li>在程序运行时，RefCell 内部会维护一个计数器来记录当前的借用状态,运行时违反了规则则会 <strong>panic</strong></li>
</ul>
</li>
<li>与 <code>Rc</code> 组合：<code>Rc&lt;RefCell&lt;T&gt;&gt;</code> 是单线程常见共享可变方案</li>
</ul>
<h3 id="示例共享--可变单线程"><a class="header" href="#示例共享--可变单线程">示例：共享 + 可变（单线程）</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">use std::cell::RefCell;

fn main() {
    // 数据包裹在 RefCell 中
    let data = RefCell::new(vec![1, 2, 3]);
    // 即使 data 是不可变的，我们也能获取可变借用
    {
        let mut mut_ref = data.borrow_mut();
        mut_ref.push(4);
    } // mut_ref 在这里离开作用域，借用标记被释放
    // 获取两个不可变借用
    let ref1 = data.borrow();
    let ref2 = data.borrow();
    println!("数据内容: {:?}", ref1);
}</code></pre>
<h4 id="为什么会-panic违反规则的后果"><a class="header" href="#为什么会-panic违反规则的后果">为什么会 Panic？（违反规则的后果）</a></h4>
<p>如果你尝试在同一个作用域内同时进行不可变和可变借用，RefCell 就会报错：</p>
<pre><code class="language-rust ignore">let data = RefCell::new(5);
let r1 = data.borrow();     // 运行时：不可变借用计数 +1
let r2 = data.borrow_mut(); // 运行时：发现已有不可变借用，直接 PANIC！</code></pre>
<h4 id="cellt-与-refcellt-的深度对比"><a class="header" href="#cellt-与-refcellt-的深度对比"><code>Cell&lt;T&gt;</code> 与 <code>RefCell&lt;T&gt;</code> 的深度对比</a></h4>
<p>这是笔记中最重要的部分：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>特性</th><th><code>Cell&lt;T&gt;</code></th><th><code>RefCell&lt;T&gt;</code></th></tr>
</thead>
<tbody>
<tr><td><strong>适用类型</strong></td><td>实现了 <code>Copy</code> 的简单类型</td><td>任何类型（通常是较大的对象）</td></tr>
<tr><td><strong>获取方式</strong></td><td>返回值的副本（<code>.get()</code>）</td><td>返回数据的引用（<code>.borrow()</code>）</td></tr>
<tr><td><strong>性能开销</strong></td><td><strong>零开销</strong>（仅内存拷贝）</td><td><strong>有开销</strong>（运行时维护借用计数）</td></tr>
<tr><td><strong>安全性</strong></td><td>编译时安全（无引用）</td><td><strong>运行时可能 Panic</strong></td></tr>
<tr><td><strong>线程安全</strong></td><td><strong>不安全</strong> (<code>!Sync</code>)</td><td><strong>不安全</strong> (<code>!Sync</code>)</td></tr>
</tbody>
</table>
</div>
<h4 id="-为什么需要-refcell"><a class="header" href="#-为什么需要-refcell">💡 为什么需要 <code>RefCell</code>？</a></h4>
<p>最常见的场景是：<strong>你实现了一个 Trait，而该 Trait 的方法签名要求使用不可变引用 <code>&amp;self</code>，但你的具体实现却需要修改内部状态（比如缓存、日志记录等）</strong>。</p>
<h4 id="总结一句话"><a class="header" href="#总结一句话">总结一句话</a></h4>
<blockquote>
<p><strong><code>Cell</code> 是“搬家”（拷贝值），<code>RefCell</code> 是“登记处”（在运行时盯着谁拿了钥匙，违规就报警）。</strong></p>
</blockquote>
<h3 id="rcrefcellt单线程共享--可变"><a class="header" href="#rcrefcellt单线程共享--可变"><code>Rc&lt;RefCell&lt;T&gt;&gt;</code>：单线程共享 + 可变</a></h3>
<p>这是 Rust 单线程开发中最强大的<strong>组合拳</strong>。如果你理解了 <code>Rc</code>（解决所有权共享）和 <code>RefCell</code>（解决不可变外壳下的修改），那么把它们套在一起就得到了：<strong>一个可以被多个地方同时持有、且每个地方都能修改的“共享变量”。</strong></p>
<p>在 <code>Rust</code>中，指针是表示内存地址的类型。为了实现“多处读写”这种在其他语言中很常见的行为，我们需要这种“套娃”结构。</p>
<h4 id="核心逻辑"><a class="header" href="#核心逻辑">核心逻辑</a></h4>
<ul>
<li><strong>外层 <code>Rc&lt;T&gt;**</code>：负责</strong>共享**。它允许多个变量持有指向同一块堆内存的指针，解决了“谁能拿到这块内存”的问题。</li>
<li><strong>内层 <code>RefCell&lt;T&gt;**</code>：负责</strong>修改**。它允许你在只有 <code>Rc</code> 提供的不可变引用的情况下，通过运行时检查来修改内部数据。</li>
</ul>
<p>当你创建 <code>let x = Rc::new(RefCell::new(5))</code> 时，内存中发生了以下情况：</p>
<ul>
<li><strong>栈上</strong>：有一个 <code>Rc</code> 指针</li>
<li><strong>堆上</strong>：分配了一块空间，包含
<ul>
<li><code>Rc</code> 的引用计数器</li>
<li><code>RefCell</code> 的借用状态标志位</li>
<li>实际的数据 <code>T</code>。</li>
</ul>
</li>
</ul>
<h4 id="代码示例共享计数器"><a class="header" href="#代码示例共享计数器">代码示例：共享计数器</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">use std::rc::Rc;
use std::cell::RefCell;
fn main() {
    // 1. 创建共享的可变数据
    let shared_data = Rc::new(RefCell::new(vec![1, 2, 3]));
    // 2. 克隆 Rc 指针（增加强引用计数）
    let shared_data_clone = Rc::clone(&amp;shared_data);
    // 3. 在一处修改
    {
        let mut mut_ref = shared_data.borrow_mut();
        mut_ref.push(4);
    } 
    // 4. 在另一处读取，发现数据已经变了
    println!("克隆端看到的数据: {:?}", shared_data_clone.borrow());
    // 输出: [1, 2, 3, 4]
}
</code></pre>
<h4 id="深度对比单线程-vs-多线程"><a class="header" href="#深度对比单线程-vs-多线程">深度对比：单线程 vs 多线程</a></h4>
<p>这个组合有一个完美的“多线程对应版本”，请务必记在笔记中对比：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>场景</th><th>工具组合</th><th>逻辑</th></tr>
</thead>
<tbody>
<tr><td><strong>单线程</strong></td><td><strong><code>Rc&lt;RefCell&lt;T&gt;&gt;</code></strong></td><td><strong>引用计数 + 运行时借用检查</strong></td></tr>
<tr><td><strong>多线程</strong></td><td><strong><code>Arc&lt;Mutex&lt;T&gt;&gt;</code></strong></td><td><strong>原子计数 + 互斥锁</strong></td></tr>
</tbody>
</table>
</div>
<h4 id="风险警示运行时崩溃"><a class="header" href="#风险警示运行时崩溃">风险警示：运行时崩溃</a></h4>
<p>虽然这个组合很强，但它保留了 <code>RefCell</code> 的风险：</p>
<ul>
<li>如果你在同一个线程中，通过 <code>shared_data.borrow()</code> 拿到了一个引用还没放手，又尝试用 <code>shared_data_clone.borrow_mut()</code> 去修改，<strong>程序会直接 Panic</strong>。</li>
<li>它依然不是线程安全的，不能跨线程传递。</li>
</ul>
<hr>
<h2 id="7-cowa-t写时克隆copy-on-write"><a class="header" href="#7-cowa-t写时克隆copy-on-write">7. <code>Cow&lt;'a, T&gt;</code>：写时克隆（Copy-On-Write）</a></h2>
<p>这是 <code>Rust</code> 中一个非常“聪明”且能显著提升性能的智能指针。<code>Cow</code> 的全称是 <code>Copy-On-Write</code>（写时克隆）。它的核心思想是：<strong>不到万不得已，绝不分配内存</strong>。将内存分配<strong>推迟到真正发生修改</strong>的那一刻。</p>
<h3 id="核心定义"><a class="header" href="#核心定义">核心定义</a></h3>
<p><code>Cow</code> 是一个枚举类型，包含两个变体：<code>Borrowed(&amp;'a T)</code> 和 <code>Owned(T::Owned)</code>。它允许你以一种统一的方式处理借用的数据和拥有的数据。</p>
<ul>
<li><code>Borrowed(&amp;'a T)</code>：持有数据的只读引用</li>
<li><code>Owned(T::Owned)</code>：持有数据的所有权（通常在堆上）</li>
</ul>
<h3 id="懒惰是美德"><a class="header" href="#懒惰是美德">懒惰是美德</a></h3>
<ul>
<li>初始状态: 当你创建一个 <code>Cow</code> 时，它通常从 <code>Borrowed</code> 开始。这不需要分配新内存，开销极小。</li>
<li>读取数据：当你只需要读取时，它保持 Borrowed 状态，性能损耗为 <code>O(1)</code>。</li>
<li>修改数据：当你调用 <code>.to_mut()</code> 尝试修改数据时，<code>Cow</code> 会检查：如果已经是 <code>Owned</code>，直接返回引用。如果是 <code>Borrowed</code>，此时才会执行克隆（<code>Clone</code>），将数据变为 <code>Owned</code>，然后再让你修改。</li>
</ul>
<p>你要会的点：</p>
<ul>
<li>表示“要么借用，要么拥有”</li>
<li>读操作零拷贝，写操作才会 <code>to_mut()</code> 触发克隆</li>
<li>常见场景：字符串处理、API 既接受 <code>&amp;str</code> 又能返回 <code>String</code> 的优化</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">use std::borrow::Cow;
// 如果不需要修改，就借用输入（零拷贝）；
// 如果需要修改，再转成拥有的 String。
fn normalize(s: &amp;str) -&gt; Cow&lt;'_, str&gt; {
    if s.contains(' ') {
        // 需要修改：分配新 String（Owned）
        Cow::Owned(s.replace(' ', "_"))
    } else {
        // 不需要修改：直接借用（Borrowed）
        Cow::Borrowed(s)
    }
}
fn main() {
    let a = normalize("hello");
    let b = normalize("hello world");

    println!("a = {}", a);
    println!("b = {}", b);
}</code></pre>
<hr>
<h2 id="8-pinp禁止被移动自引用异步"><a class="header" href="#8-pinp禁止被移动自引用异步">8. <code>Pin&lt;P&gt;</code>：禁止被移动（自引用/异步）</a></h2>
<p>这是 Rust 中最“玄学”但也最底层、最重要的智能指针之一。如果说 <code>Box</code> 是为了放进堆里，那么 <code>Pin</code> 就是为了<strong>锁死内存地址</strong>。</p>
<h3 id="define"><a class="header" href="#define">Define</a></h3>
<h4 id="a-核心危机自引用结构-self-referential-structs"><a class="header" href="#a-核心危机自引用结构-self-referential-structs">A. 核心危机：自引用结构 (Self-referential Structs)</a></h4>
<p>在 Rust 中，几乎所有类型都是可以移动的（<code>Move</code>）。这意味着如果你把一个变量传给另一个函数，它的<strong>内存地址可能会发生改变</strong>。但在某些特殊场景下，这种“移动”会导致程序崩溃。</p>
<p>想象一个结构体，它的一个字段是指向另一个字段的指针：</p>
<pre><code class="language-rust ignore">struct SelfRef {
    data: String,
    ptr: *const String, // 这个指针指向同一个结构体里的 data
}
</code></pre>
<ol>
<li><strong>初始状态</strong>：<code>ptr</code> 记录了 <code>data</code> 在内存中的地址（比如 <code>0x100</code>）。</li>
<li><strong>发生移动</strong>：如果你把这个结构体移动到堆上或者传给另一个线程，整个结构体的内存地址变了（变成了 <code>0x200</code>）。</li>
<li><strong>结果</strong>：<code>data</code> 的新地址是 <code>0x200</code>，但 <code>ptr</code> 仍然指着旧地址 <code>0x100</code>。<strong>指针失效了！</strong> 这会导致未定义行为。</li>
</ol>
<h4 id="b-pinp-的作用"><a class="header" href="#b-pinp-的作用">B. <code>Pin&lt;P&gt;</code> 的作用</a></h4>
<p><code>Pin</code> 的作用就是：<strong>给指针加一个约束，保证它指向的数据在内存中永远不会被移动。</strong></p>
<ul>
<li>一旦数据被 <code>Pin</code> 住，你无法再通过 <code>mem::swap</code> 或移动所有权等方式改变它的物理位置。</li>
<li>它主要配合 <code>P</code>（通常是 <code>Box</code> 或引用）使用，形成 <code>Pin&lt;Box&lt;T&gt;&gt;</code> 或 <code>Pin&lt;&amp;mut T&gt;</code>。</li>
</ul>
<h4 id="c-为什么异步asyncawait必须用它"><a class="header" href="#c-为什么异步asyncawait必须用它">C. 为什么异步（Async/Await）必须用它？</a></h4>
<p>这是 <code>Pin</code> 最主要的应用场景。</p>
<ul>
<li>当你写 <code>async</code> 块时，编译器会将其转换为一个状态机（实现了 <code>Future</code> trait）。</li>
<li>这个状态机内部经常包含自引用（例如：一个局部变量被引用后跨越了 <code>.await</code> 点）。</li>
<li>因此，<code>Future</code> 的 <code>poll</code> 方法签名必须是 <code>fn poll(self: Pin&lt;&amp;mut Self&gt;, ...)</code>。<strong>没有 <code>Pin</code>，异步代码就无法保证内存安全。</strong></li>
</ul>
<hr>
<h4 id="d-unpin-特征谁可以豁免"><a class="header" href="#d-unpin-特征谁可以豁免">D. <code>Unpin</code> 特征：谁可以豁免？</a></h4>
<p>并不是所有东西都需要被“锁死”。Rust 定义了一个标记特征 <strong><code>Unpin</code></strong>：</p>
<ul>
<li><strong><code>Unpin</code> 类型</strong>：绝大多数普通类型（如 <code>i32</code>, <code>String</code>, <code>Box</code>）。它们即便被移动也是安全的。对于这些类型，<code>Pin&lt;P&gt;</code> 没有任何实际限制，可以随意拿回可变引用。</li>
<li><strong><code>!Unpin</code> 类型</strong>：不能被移动的类型（如异步生成的 <code>Future</code>、自引用结构）。它们必须被 <code>Pin</code> 保护，否则编译器会阻止某些危险操作。</li>
</ul>
<hr>
<h4 id="如何通俗理解-pin"><a class="header" href="#如何通俗理解-pin">如何通俗理解 <code>Pin</code>？</a></h4>
<ul>
<li><strong>普通指针</strong>：像一张写着地址的便签。你可以把便签传来传去，房子（数据）也可能搬家。</li>
<li><strong><code>Pin</code> 指针</strong>：像一颗<strong>钉子</strong>。它不仅告诉你地址，还将房子死死地钉在原地，不准搬家，直到房子被拆除（Drop）为止。</li>
</ul>
<h4 id="选型指南"><a class="header" href="#选型指南">选型指南</a></h4>
<ol>
<li>如果你的数据不包含指向自身的指针，**不需要 <code>Pin**</code>。</li>
<li>如果你在手写复杂的 <code>Future</code> 或者构建自引用底层库，**必须用 <code>Pin**</code>。</li>
</ol>
<p>这个示例只是让你看到 <code>Pin&lt;Box&lt;T&gt;&gt;</code>的写法；真正需要 <code>Pin</code> 的场景主要在 <code>async/Future</code> 或自引用结构里。</p>
<pre class="playground"><code class="language-rust editable edition2024">use std::pin::Pin;
fn main() {
    let x = Box::new(123);
    // Pin&lt;Box&lt;T&gt;&gt;：把堆上的 T “固定住”，承诺之后不会再移动它的内存地址
    let pinned: Pin&lt;Box&lt;i32&gt;&gt; = Box::pin(*x);
    // 访问内部值：as_ref 得到 Pin&lt;&amp;T&gt;，get_ref 拿到 &amp;T
    let r: &amp;i32 = pinned.as_ref().get_ref();
    println!("pinned value = {}", r);
}</code></pre>
<hr>
<h2 id="9-boxdyn-trait--rcdyn-traittrait-object-与动态分发"><a class="header" href="#9-boxdyn-trait--rcdyn-traittrait-object-与动态分发">9. <code>Box&lt;dyn Trait&gt;</code> / <code>Rc&lt;dyn Trait&gt;</code>：trait object 与动态分发</a></h2>
<p>这是 Rust 智能指针系列的最后一项核心应用。如果你需要处理<strong>不同类型但实现了相同特征</strong>的对象（例如一个数组里既有“圆形”又有“正方形”），你就必须用到 <code>Box&lt;dyn Trait&gt;</code> 或 <code>Rc&lt;dyn Trait&gt;</code>。</p>
<p>在 Rust 中，指针是表示内存地址的类型。由于不同类型的大小不同，我们无法直接在栈上存储“某个特征”，必须通过智能指针将其包装成 <strong>Trait Object</strong>。</p>
<p>你要会的点：</p>
<ul>
<li><strong>静态分发（泛型） vs 动态分发（trait object）</strong></li>
<li>对象安全（object safety）限制：哪些 trait 能变成 <code>dyn Trait</code></li>
<li>fat pointer（数据指针 + vtable），大小/性能直觉</li>
</ul>
<h3 id="前置知识"><a class="header" href="#前置知识">前置知识</a></h3>
<h4 id="a-为什么必须用-box-或-rc"><a class="header" href="#a-为什么必须用-box-或-rc">A. 为什么必须用 <code>Box</code> 或 <code>Rc</code>？</a></h4>
<p>特征（Trait）本身是 <strong>DST (Dynamically Sized Type)</strong>，即“动态大小类型”。</p>
<ul>
<li>编译器在编译时不知道具体是哪个结构体实现了该特征，因此不知道它占用多少内存。</li>
<li><strong>解决方案</strong>：将对象放入堆中。<code>Box&lt;dyn Trait&gt;</code> 的大小是固定的（指针大小），无论堆上的对象实际有多大。</li>
</ul>
<h4 id="b-物理结构胖指针-fat-pointer"><a class="header" href="#b-物理结构胖指针-fat-pointer">B. 物理结构：胖指针 (Fat Pointer)</a></h4>
<p>当你使用 <code>Box&lt;dyn Trait&gt;</code> 时，这个指针在栈上占用 <strong>2 个单元</strong>（通常是 16 字节）：</p>
<ol>
<li><strong>数据指针</strong>：指向堆内存中具体的对象数据。</li>
<li><strong>vtable 指针</strong>：指向一个“虚函数表”。表中记录了该特定类型实现该 Trait 的方法地址。</li>
</ol>
<h4 id="c-静态分发-vs-动态分发"><a class="header" href="#c-静态分发-vs-动态分发">C. 静态分发 vs 动态分发</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>特性</th><th>静态分发 (Generics <code>&lt;T: Trait&gt;</code>)</th><th>动态分发 (<code>dyn Trait</code>)</th></tr>
</thead>
<tbody>
<tr><td><strong>原理</strong></td><td>编译时为每种类型生成一份代码（单态化）。</td><td>运行时通过 vtable 查找函数地址。</td></tr>
<tr><td><strong>性能</strong></td><td><strong>极快</strong>。编译器可以进行内联优化。</td><td><strong>略慢</strong>。存在指针跳转开销，无法内联。</td></tr>
<tr><td><strong>灵活性</strong></td><td>集合中只能存同一种类型。</td><td><strong>极高</strong>。集合中可以存多种不同类型。</td></tr>
</tbody>
</table>
</div>
<h4 id="d-代码示例不同类型的绘图"><a class="header" href="#d-代码示例不同类型的绘图">D. 代码示例：不同类型的“绘图”</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">trait Draw {
    fn draw(&amp;self);
}

struct Button { width: u32 }
impl Draw for Button {
    fn draw(&amp;self) { println!("渲染按钮，宽度: {}", self.width); }
}

struct Image { url: String }
impl Draw for Image {
    fn draw(&amp;self) { println!("渲染图片，源自: {}", self.url); }
}

fn main() {
    // 使用 Box&lt;dyn Draw&gt; 存储不同类型的对象
    let components: Vec&lt;Box&lt;dyn Draw&gt;&gt; = vec![
        Box::new(Button { width: 100 }),
        Box::new(Image { url: String::from("logo.png") }),
    ];

    for comp in components {
        comp.draw(); // 运行时动态分发：查表并调用对应方法
    }
}
</code></pre>
<h3 id="什么时候用-boxdyn-trait"><a class="header" href="#什么时候用-boxdyn-trait">什么时候用 <code>Box&lt;dyn Trait&gt;</code>？</a></h3>
<ol>
<li><strong>异质集合</strong>：当你需要一个 <code>Vec</code> 存储多种实现了相同接口的类型时。</li>
<li><strong>解耦</strong>：当你不想在函数签名中暴露具体类型，只想表达“只要实现了这个特征就行”时。</li>
<li><strong>减少编译时间</strong>：泛型会导致代码膨胀（单态化），而 <code>dyn Trait</code> 只有一份代码，可以缩短大型项目的编译时间。</li>
</ol>
<hr>
<h2 id="10-自定义智能指针进阶"><a class="header" href="#10-自定义智能指针进阶">10. 自定义智能指针（进阶）</a></h2>
<p>你要会的点：</p>
<ul>
<li>如何实现自己的指针类型：
<ul>
<li>实现 <code>Deref/DerefMut</code>，让它像引用一样用</li>
<li>实现 <code>Drop</code>，在释放时执行资源回收</li>
</ul>
</li>
<li>RAII 模式（文件句柄、网络连接、锁守卫等）</li>
<li><code>PhantomData</code>（用于告诉编译器“我逻辑上拥有/借用某个 T”，影响 drop check/variance）——偏高级，但智能指针写多了会遇到</li>
</ul>
<p>要自定义一个智能指针，本质上是创建一个结构体，并为它实现两个核心特征（Trait）：<strong><code>Deref</code></strong> 和 <strong><code>Drop</code></strong>。在 Rust 中，正是这两个特征让普通结构体拥有了“像指针一样工作”和“自动管理资源”的超能力。</p>
<h3 id="1-自定义智能指针的核心公式"><a class="header" href="#1-自定义智能指针的核心公式">1. 自定义智能指针的核心公式</a></h3>
<ul>
<li><strong><code>Deref</code> 特征</strong>：允许你通过解引用操作符（<code>*</code>）访问内部数据。</li>
<li><strong><code>Drop</code> 特征</strong>：定义当指针离开作用域时该执行什么清理逻辑（例如释放内存、关闭文件、打印日志）。</li>
</ul>
<h3 id="2-实战演练创建一个简单的-myboxt"><a class="header" href="#2-实战演练创建一个简单的-myboxt">2. 实战演练：创建一个简单的 <code>MyBox&lt;T&gt;</code></a></h3>
<p>我们将模仿 <code>Box&lt;T&gt;</code> 的行为，创建一个能包裹数据的智能指针。</p>
<pre class="playground"><code class="language-rust editable edition2024">use std::ops::Deref;

//A. 定义结构体
struct MyBox&lt;T&gt;(T); // 元组结构体
impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}

//B. 实现 `Deref` (让它能被 `*` 解引用)
//如果不实现 `Deref`，编译器就不知道执行 `*my_box` 时该返回什么。
impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T; // 关联类型，指定解引用后得到的类型
    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0 // 返回元组中的第一个元素引用
    }
}
//C. 实现 `Drop` (赋予它自动清理的能力)
impl&lt;T&gt; Drop for MyBox&lt;T&gt; {
    fn drop(&amp;mut self) {
        println!("MyBox 指针被销毁了，资源已释放！");
    }
}

fn main() {
    let x = 5;
    let y = MyBox::new(x);
    assert_eq!(5, x);
    assert_eq!(5, *y); // 这里触发了 y.deref()
    println!("y 的值是: {}", *y);
} // y 在这里离开作用域，触发 drop() 方法</code></pre>
<h3 id="3-深度原理deref-强制转换-deref-coercion"><a class="header" href="#3-深度原理deref-强制转换-deref-coercion">3. 深度原理：Deref 强制转换 (Deref Coercion)</a></h3>
<p>这是 Rust 智能指针极其好用的秘密武器。<strong>Deref 强制转换</strong>可以将一个实现了 <code>Deref</code> 的类型的引用转换为它内部类型的引用。</p>
<p><strong>例子：</strong>
如果你有一个 <code>MyBox&lt;String&gt;</code>，Rust 可以自动将其转换为 <code>&amp;str</code>：</p>
<pre><code class="language-rust ignore">fn hello(name: &amp;str) {
    println!("Hello, {}!", name);
}
fn main() {
    let m = MyBox::new(String::from("Rust"));
    // &amp;m 是 &amp;MyBox&lt;String&gt;
    // Rust 自动调用 deref 将其变为 &amp;String
    // String 也实现了 Deref，再次调用 deref 变为 &amp;str
    hello(&amp;m); 
}</code></pre>
<hr>
<h2 id="11-选择指南"><a class="header" href="#11-选择指南">11. 选择指南</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>需求场景</th><th>推荐指针</th><th>备注</th></tr>
</thead>
<tbody>
<tr><td><strong>堆分配、大数据传递、递归类型</strong></td><td><strong><code>Box&lt;T&gt;</code></strong></td><td>唯一所有权，开销最低。</td></tr>
<tr><td><strong>单线程、多处共享只读数据</strong></td><td><strong><code>Rc&lt;T&gt;</code></strong></td><td>引用计数。</td></tr>
<tr><td><strong>多线程、多处共享只读数据</strong></td><td><strong><code>Arc&lt;T&gt;</code></strong></td><td>原子引用计数，线程安全。</td></tr>
<tr><td><strong>单线程、小对象内部可变 (Copy类型)</strong></td><td><strong><code>Cell&lt;T&gt;</code></strong></td><td>get/set 值拷贝。</td></tr>
<tr><td><strong>单线程、大对象内部可变 (非Copy)</strong></td><td><strong><code>RefCell&lt;T&gt;</code></strong></td><td>运行时借用检查。</td></tr>
<tr><td><strong>单线程、多所有权共享且可修改</strong></td><td><strong><code>Rc&lt;RefCell&lt;T&gt;&gt;</code></strong></td><td>经典套娃组合。</td></tr>
<tr><td><strong>多线程、共享且可修改</strong></td><td><strong><code>Arc&lt;Mutex&lt;T&gt;&gt;</code></strong></td><td>并发黄金搭档。</td></tr>
<tr><td><strong>避免循环引用、内存泄漏</strong></td><td><strong><code>Weak&lt;T&gt;</code></strong></td><td>配合 Rc 或 Arc 使用。</td></tr>
<tr><td><strong>性能优化、按需克隆</strong></td><td><strong><code>Cow&lt;T&gt;</code></strong></td><td>写时克隆。</td></tr>
<tr><td><strong>异步编程、锁死内存地址</strong></td><td><strong><code>Pin&lt;P&gt;</code></strong></td><td>防止自引用结构移动。</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="生命周期"><a class="header" href="#生命周期">生命周期</a></h1>
<h2 id="一基础概念"><a class="header" href="#一基础概念">一、基础概念</a></h2>
<h3 id="1-生命周期的本质悬空引用预防机制"><a class="header" href="#1-生命周期的本质悬空引用预防机制">1. 生命周期的本质：悬空引用预防机制</a></h3>
<p>生命周期（Lifetimes）是 Rust 编译器用来确保引用在有效范围内的机制。它用于防止悬空引用（Dangling References）问题，确保<strong>引用</strong>指向的数据在<strong>引用存在期间</strong>不会被销毁。例如：</p>
<pre class="playground"><code class="language-rust editable edition2024">// 错误示例：试图返回局部变量引用
// 报错：returns a reference to data owned by the current function
/*
fn get_data() -&gt; &amp;String {
    let s = String::from("Hello");
    &amp;s // s 在函数结束时被销毁，返回引用会导致悬空指针
}
*/

// 正确方案 1：转移所有权（最常用）
fn get_data_owned() -&gt; String {
    String::from("Hello")
}

// 正确方案 2：传入引用，返回引用（建立生命周期关联）
fn identity&lt;'a&gt;(input: &amp;'a String) -&gt; &amp;'a String {
    input
}</code></pre>
<p>在 Rust 中，借用检查器会确保引用的有效性，防止程序出现不安全的悬空引用。</p>
<h3 id="2-借用检查器borrow-checker的工作原理"><a class="header" href="#2-借用检查器borrow-checker的工作原理">2. 借用检查器（Borrow Checker）的工作原理</a></h3>
<p>借用检查器通过分析变量的生命周期，确保引用始终在有效范围内 <strong><code>作用域(数据源) - 生命周期(引用) &gt;= 0</code></strong>。它会验证以下规则：</p>
<ul>
<li>不允许在拥有可变借用时同时存在不可变借用。</li>
<li>不允许在不可变借用存在时修改数据。</li>
</ul>
<h3 id="3-生命周期与作用域的关系"><a class="header" href="#3-生命周期与作用域的关系">3. 生命周期与作用域的关系</a></h3>
<p>生命周期通常与作用域（<code>scope</code>）密切相关，作用域定义了一个变量或引用的有效区域，而生命周期则追踪这个变量或引用的生存时间，避免悬空引用。每个引用都会有一个生命周期，与它指向的数据的生命周期匹配。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut x = 10;
    let r;
    {
        let y = &amp;x; // y 的生命周期在此作用域内
        r = y;      // 将 y 赋值给 r
    }               // y 离开了作用域，但 r 还在
    
    // println!("{}", r); // 如果取消注释会报错：因为 r 指向的内容寿命不足
    
    x = 20; // 此时修改 x 是安全的，因为旧的借用 r 已经无效了
    println!("x: {}", x);
}</code></pre>
<h3 id="4-显式标注语法a"><a class="header" href="#4-显式标注语法a">4. 显式标注语法（<code>'a</code>）</a></h3>
<p>显式标注并不是为了“<strong>告诉编译器这个引用活多久</strong>”，而是为了建立<strong>输入和输出之间的一致性约</strong>束。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn longest&lt;'a&gt;(s1: &amp;'a str, s2: &amp;'a str) -&gt; &amp;'a str {
    if s1.len() &gt; s2.len() {
        s1
    } else {
        s2
    }
}
fn main() {
    let a = String::from("Hello World");
    let b = String::from("Hello");
    let longest = longest(&amp;a, &amp;b);
    println!("longest: {}", longest);
}</code></pre>
<p>此处 <code>'a</code> 是生命周期标注，表示函数返回的引用与传入参数的生命周期相同。</p>
<hr>
<h2 id="二生命周期省略规则lifetime-elision"><a class="header" href="#二生命周期省略规则lifetime-elision">二、生命周期省略规则（Lifetime Elision）</a></h2>
<p>为了避免开发者在所有地方都手动书写 <code>'a</code>，<code>Rust</code> 编译器内置了一套确定性的模式。如果代码符合这些模式，编译器会自动补全生命周期。这被称为“省略”，但生命周期依然客观存在，只是被编译器隐藏了。</p>
<h3 id="1-输入生命周期与输出生命周期"><a class="header" href="#1-输入生命周期与输出生命周期">1. 输入生命周期与输出生命周期</a></h3>
<p>Rust 提供了生命周期省略规则，简化函数签名。当函数参数和返回值都没有生命周期标注时，编译器会推导出生命周期。</p>
<ul>
<li>输入生命周期 (<code>Input Lifetimes</code>)：函数参数中的引用。</li>
<li>输出生命周期 (<code>Output Lifetimes</code>)：函数返回值中的引用。</li>
</ul>
<p>误以为“省略”意味着“没有约束”?</p>
<pre><code class="language-rust ignore">//fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str { ... } // 补全后
fn first_word(s: &amp;str) -&gt; &amp;str {
    s.split_whitespace().next().unwrap()
}
/* // 错误示例：编译器无法应用省略规则，因为没有输入引用作为来源
fn produce_str() -&gt; &amp;str {
    let s = String::from("hello");
    &amp;s // 依然会报错：returns a reference to data owned by the current function
}
*/
fn main() {
    let a = String::from("Hello World");
    let first = first_word(&amp;a);
    println!("first: {}", first);
}</code></pre>
<p>编译器会推导出 <code>first_word</code>函数的生命周期。</p>
<h3 id="2-函数生命周期省略的三大准则"><a class="header" href="#2-函数生命周期省略的三大准则">2. 函数生命周期省略的三大准则</a></h3>
<p>编译器按照以下顺序尝试推导，如果推导失败（即不符合这三条），则要求手动标注：</p>
<ul>
<li><strong>规则一</strong>：每一个是引用的参数都有它自己的生命周期参数（例如 <code>fn(x: &amp;'a i32, y: &amp;'b i32)</code>）。</li>
<li><strong>规则二</strong>：如果只有一个输入生命周期参数，那么该生命周期被赋给所有输出生命周期参数。</li>
<li><strong>规则三</strong>：如果有多个输入生命周期参数，但其中一个是 &amp;self 或 &amp;mut self，那么 self 的生命周期被赋给所有输出生命周期参数。</li>
</ul>
<pre><code class="language-rust ignore">// 实践场景：编译器会报错，因为不符合规则二（有两个输入）

/*
fn pick_one(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    x
}
*/
// 正确方案：手动介入，指明关联
fn pick_one&lt;'a&gt;(x: &amp;'a str, _y: &amp;str) -&gt; &amp;'a str {
    x
}</code></pre>
<h3 id="3-方法签名中的生命周期省略self-与-mut-self"><a class="header" href="#3-方法签名中的生命周期省略self-与-mut-self">3. 方法签名中的生命周期省略（<code>&amp;self</code> 与 <code>&amp;mut self</code>）</a></h3>
<p>在 Rust 的面向对象风格代码中，返回的引用通常是结构体自身的一部分。在方法中，返回值的生命周期默认与 self 绑定，这意味着只要你手里拿着方法返回的引用，你就一直持有对整个结构体的借用。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct Level {
    content: String,
}
impl Level {
    // 自动应用规则三：fn get_content&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a str
    fn get_content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}
fn main() {
    let mut lv = Level { content: "Rust".into() };
    let res = lv.get_content(); // res 绑定了 lv 的生命周期
    // lv.content.push_str("!"); // 报错：无法修改 lv，因为 res 还在引用它
    println!("{}", res); 
    lv.content.push_str("!"); // 成功：res 在 println 之后不再使用，借用结束（NLL特性）
}</code></pre>
<hr>
<h2 id="三函数中的生命周期"><a class="header" href="#三函数中的生命周期">三、函数中的生命周期</a></h2>
<p>函数签名中的生命周期标注是对编译器的一种“承诺”。它并不改变引用的实际寿命，而是描述了输入引用的寿命如何“流向”输出引用。当编译器无法通过省略规则自动推导时，我们需要手动精确定义这种流动关系。</p>
<h3 id="1-单个与多个生命周期参数"><a class="header" href="#1-单个与多个生命周期参数">1. 单个与多个生命周期参数</a></h3>
<p>函数可以接收多个生命周期参数，每个生命周期都需要进行标注。例如：</p>
<pre class="playground"><code class="language-rust editable edition2024">fn example&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre>
<p>如果你给所有参数都标注同一个 <code>'a</code>，编译器会强制将它们关联在一起，取其中的**交集（即最短的那个寿命）**作为结果。这有时会导致过度限制。如果两个输入参数之间没有逻辑上的关联，使用不同的生命周期标注可以给调用者更大的灵活性。</p>
<pre class="playground"><code class="language-rust editable edition2024">// 情况 A：使用单个生命周期。x 和 y 被锁定在同一个寿命中。
fn pick_x&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    x
}

// 情况 B：使用多个生命周期。返回值只与 x 关联，与 y 无关。
fn pick_x_flexible&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;'a str {
    x
}

fn main() {
    let x_long = String::from("Long lived");
    let res;
    {
        let y_short = String::from("Short");
        // 如果使用 pick_x(x_long, y_short)，res 会因为 y_short 而被缩短寿命，报错。
        // 使用 flexible 版本，res 的寿命只取决于 x_long。
        res = pick_x_flexible(&amp;x_long, &amp;y_short); 
    } // y_short 在这里销毁，但 res 依然有效
    println!("res: {}", res); 
}</code></pre>
<h3 id="2-多个引用输入的约束关系"><a class="header" href="#2-多个引用输入的约束关系">2. 多个引用输入的约束关系</a></h3>
<p>多个引用参数之间的生命周期关系需要通过显式标注进行约束。有时我们需要表达“引用的引用”或者“参数 A 必须活得比参数 B 久”。这通常通过生命周期约束（Bounds）实现，例如 <code>'a: 'b</code>（读作：’a 至少活得和 ’b 一样久）。</p>
<p>当你需要把一个引用存入另一个引用的目标位置时（例如在处理缓存或修改器时）。</p>
<pre class="playground"><code class="language-rust editable edition2024">// 需求：将 source 的内容更新到 target 指向的地方
// 约束：'a: 'b 表示 source 的寿命必须覆盖 target 的寿命
fn update_and_return&lt;'a, 'b&gt;(target: &amp;mut &amp;'b str, source: &amp;'a str) 
where 'a: 'b 
{
    *target = source; // 只有 source 活得够久，赋值才是安全的
}
fn main() {
    // 1. target 在外层作用域，它的生命周期很长
    let mut target: &amp;str = "I am long-lived"; 
    {
        // 2. source 在内层作用域，它在大括号结束时就会被销毁
        let source_data = String::from("I am short-lived");
        let source_ref = &amp;source_data; 

        // 3. 尝试赋值：
        // 这里的 'a 是内部作用域，'b 是外部作用域。
        // 显然 'a 并不比 'b 活得久，违反了 'a: 'b。
        // 编译器报错：`source_data` does not live long enough
        update_and_return(&amp;mut target, source_ref); 
    } 
    // 4. 危险：如果上面不报错，这里打印 target 就会访问到已经死掉的内存！
    println!("{}", target); 
}</code></pre>
<p>当内容和容器在同一个作用域，或者内容活得更久时，代码是安全的。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn update_and_return&lt;'a, 'b&gt;(target: &amp;mut &amp;'b str, source: &amp;'a str) 
where 'a: 'b 
{
    *target = source;
}
fn main() {
    // 1. source 先创建，它的生命周期最长
    let source_data = String::from("I live long enough");
    let source_ref = &amp;source_data; 
    // 2. target 后创建（或在同一层）
    let mut target: &amp;str = "initial";
    // 3. 赋值：
    // 此时 source_ref 的寿命 ('a) 覆盖了 target 的寿命 ('b)。
    // 满足 'a: 'b，安全通过！
    update_and_return(&amp;mut target, source_ref);
    // 4. 这里的 target 指向 source_data，而 source_data 还没死，安全。
    println!("{}", target); 
}</code></pre>
<h3 id="3-返回引用的生命周期标注要求"><a class="header" href="#3-返回引用的生命周期标注要求">3. 返回引用的生命周期标注要求</a></h3>
<p>返回引用时，必须明确标注返回值生命周期的关系。</p>
<ul>
<li>来源合法性：返回的引用必须来源于输入参数。</li>
<li>绝对禁止：严禁返回指向函数内局部变量的引用。</li>
</ul>
<pre><code class="language-rust ignore">struct Config {
    env: String,
    port: u32,
}
// 实践：从结构体引用中提取内部字段的引用
// 这里的 'a 建立了“整体”与“部分”的寿命契约
fn get_env_ref&lt;'a&gt;(config: &amp;'a Config) -&gt; &amp;'a str {
    &amp;config.env
}

// 错误尝试：如果你试图返回一个跟输入无关的引用
/*
fn mistake&lt;'a&gt;(input: &amp;'a str) -&gt; &amp;'a str {
    let s = String::from("I am local");
    &amp;s // 即使标注了 'a，编译器也会发现 s 的实际寿命达不到 'a 的要求
}
*/</code></pre>
<hr>
<h2 id="四结构体与枚举中的生命周期"><a class="header" href="#四结构体与枚举中的生命周期">四、结构体与枚举中的生命周期</a></h2>
<p>当一个结构体或枚举中包含引用时，这个结构体本身就失去了“独立性”。它变成了一个从属品，其寿命被强制绑定到它所指向的数据上。Rust 要求必须在类型定义上显式标注寿命，以提醒调用者：这个结构体不能比它内部的引用活得久。</p>
<h3 id="1-持有引用的结构体定义"><a class="header" href="#1-持有引用的结构体定义">1. 持有引用的结构体定义</a></h3>
<p>当结构体包含引用时，需要显式标注结构体的生命周期。如果你试图构建一个结构体来存放解析后的数据（如 <code>User</code> 持有 <code>&amp;str</code> 名字），你必须保证 User 在使用时，原始字符串还没被销毁。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct User&lt;'a&gt; {
    name: &amp;'a str, // 结构体持有引用
}
/* fn create_user() -&gt; User&lt;'_&gt; {
    let name = String::from("Alice");
    let user = User { name: &amp;name };
    user // 报错：name 在函数结束时销毁，user 的引用失效
}
*/
fn main() {
    let raw_data = String::from("Alice-25-Engineer");
    // 假设我们解析这段字符串
    let name_slice = &amp;raw_data[0..5];
    let user = User { name: name_slice }; 
    println!("User name: {}", user.name); 
} // user 和 raw_data 在此处一起安全销毁</code></pre>
<h3 id="2-持有引用的枚举定义"><a class="header" href="#2-持有引用的枚举定义">2. 持有引用的枚举定义</a></h3>
<p>和结构体类似，枚举类型也需要为引用添加生命周期标注。 枚举的生命周期规则与结构体完全一致。只要有一个变体（Variant）持有了引用，整个枚举就必须带有生命周期标注。</p>
<pre><code class="language-rust ignore">enum Message&lt;'a&gt; {
    Quit,
    Move { x: i32, y: i32 },
    Write(&amp;'a str), // 只要这里有引用，上面定义就得加 &lt;'a&gt;
}</code></pre>
<h3 id="3-impl-块中的生命周期声明"><a class="header" href="#3-impl-块中的生命周期声明">3. <code>impl</code> 块中的生命周期声明</a></h3>
<p>在 <code>impl</code> 块中，生命周期需要明确标注与结构体的关系。例如：</p>
<h4 id="self-vs-a-self"><a class="header" href="#self-vs-a-self"><code>&amp;self</code> vs <code>&amp;'a self</code></a></h4>
<ul>
<li><code>fn method(&amp;self)</code>：这是最常见的方法签名，表示对结构体的借用是临时的，只在方法调用期间有效。它不需要显式的生命周期标注，Rust 编译器会根据结构体的生命周期推导出它的有效期。</li>
<li><code>fn method(&amp;'a self)</code>：这个签名意味着对结构体的借用必须持续到结构体的生命周期 ’a 结束。这种做法是非常危险的，因为它可能会锁定结构体的借用，直到结构体被销毁为止，导致其他代码无法使用这个结构体。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">struct Inspector&lt;'a&gt; {
    context: &amp;'a str,
}
impl&lt;'a&gt; Inspector&lt;'a&gt; {
    // 正常的方法：借用 &amp;self，用完就还
    fn read(&amp;self) {
        println!("读取内容: {}", self.context);
    }
    // 危险的方法：强制借用 self 持续时间为 'a
    // 这里的 'a 是 context 的寿命，也是这个结构体能活的最长寿命
    fn lock_forever(&amp;'a mut self) {
        println!("!!! 锁定整个结构体 !!!");
    }
}
fn main() {
    let data = String::from("重要卷宗");
    let mut detective = Inspector { context: &amp;data };
    detective.read(); // 第一次读取：成功
    detective.read(); // 第二次读取：成功，说明前两次借用都“还”了
    // 关键点：调用这个“终身锁定”的方法
    detective.lock_forever(); 
    // --- 观察点 ---
    // 按理说，detective 这个变量现在还活着（还没到 main 结尾）
    // 但是，如果你尝试再次调用 read():
    // detective.read(); 
    
    // 报错：cannot borrow `detective` as immutable because it is also borrowed as mutable
    // 编译器的逻辑：
    // 1. lock_forever 要求可变借用 detective 持续 'a 那么久。
    // 2. 'a 是 data 的寿命。
    // 3. 在 main 结束前，data 一直活着，所以那个可变借用一直没还。
    // 4. 一个对象被可变借用期间，不能进行任何其他借用（哪怕是只读）。
}</code></pre>
<p>如果我们将 &amp;’a mut self 改回正常的 &amp;mut self（编译器会自动推导一个临时的生命周期 ’b），你会发现一切都恢复了正常。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct Inspector&lt;'a&gt; {
    context: &amp;'a str,
}
impl&lt;'a&gt; Inspector&lt;'a&gt; {
    // 正常的方法：借用 &amp;self，用完就还
    fn read(&amp;self) {
        println!("读取内容: {}", self.context);
    }
    // 正常的方法：不标注 'a，使用匿名的临时生命周期
    fn quick_work(&amp;mut self) {
        println!("快速处理，完事还回权力。");
    }
}
fn main() {
    let data = String::from("重要卷宗");
    let mut detective = Inspector { context: &amp;data };
    detective.read(); 
    detective.quick_work(); // 借用开始 -&gt; 方法执行 -&gt; 借用结束（归还权力）

    detective.read(); // 成功！因为权限已经还回来了。
    detective.quick_work(); // 再次成功。
}</code></pre>
<h4 id="深度总结为什么-a-self-这么直观地坏事"><a class="header" href="#深度总结为什么-a-self-这么直观地坏事">深度总结：为什么 <code>&amp;'a self</code> 这么直观地“坏事”？</a></h4>
<p>你可以这样理解：</p>
<ol>
<li>
<p>普通 <code>&amp;self</code>：像你去图书馆借书。看完（方法结束）就把书还给图书馆了。其他人（或你后续的代码）还能再借。</p>
</li>
<li>
<p><code>&amp;'a self</code>：像你跟图书馆签了个霸王条款：“这书我借了，直到图书馆倒闭（<code>'a</code> 结束）我才还。”</p>
</li>
</ol>
<ul>
<li>结果：虽然你手里拿着书（变量还在作用域内），但因为你一直占着“借阅名额”不放，图书馆（编译器）认为这本书一直处于“被借出且不可用”状态，导致后续任何尝试访问该书的操作都会报错。</li>
</ul>
<p><strong>为什么会出现这种代码？</strong></p>
<p>通常是因为开发者想在结构体里存储一个指向自己的引用（自引用），或者在复杂的 trait 嵌套中写错了标注。在 99% 的情况下，你都不应该在方法的 self 前加上结构体的生命周期参数。</p>
<h3 id="4-结构体字段间的生命周期约束"><a class="header" href="#4-结构体字段间的生命周期约束">4. 结构体字段间的生命周期约束</a></h3>
<p>如果一个结构体有多个引用字段，你可以给它们不同的寿命，或者强制它们同命。</p>
<pre><code class="language-rust ignore">struct Dual&lt;'a, 'b&gt; {
    short: &amp;'a str,
    long: &amp;'b str, // 独立寿命 'b
}

fn main() {
    let s_long: &amp;'static str = "I am static";
    let mut res: &amp;str = ""; 
    {
        let s_short = String::from("short");
        let d = Dual {
            short: &amp;s_short,
            long: s_long, // 'b 被识别为 'static
        };
        // 成功！因为 d.long 的寿命 'b 是独立的。
        // 编译器知道即使 d 销毁了，d.long 引向的数据依然是 'static 的。
        res = d.long; 
    } 
    println!("结果: {}", res); // 运行成功：打印 "I am static"
/*  {
        let s_short = String::from("short");
        let d = Dual {
            short: &amp;s_short, // 寿命是这个大括号
            long: s_long,    // 静态寿命被“传染”，降级为大括号寿命
        };
        // 报错点：虽然 d.long 引用的是静态字符串，
        // 但编译器认为 d.long 的寿命受限于 DualSingle&lt;'a&gt; 的 'a。
        // 而 'a 已经在刚才被 s_short 锁定为大括号寿命了。
        res = d.short; 
    } // s_short 销毁，'a 结束
    println!("{}", res); // 报错：res 借用的数据存活时间不够长
*/
}</code></pre>
<hr>
<h2 id="五生命周期约束与绑定"><a class="header" href="#五生命周期约束与绑定">五、生命周期约束与绑定</a></h2>
<p>核心逻辑：生命周期约束是 Rust 处理“嵌套关系”和“泛型安全性”的铁律。它通过两种符号：<code>'a: 'b</code>（生命周期比拼）和 <code>T: 'a</code>（类型寿命担保），确保在复杂的嵌套结构中，没有任何一个零件会提前损坏。</p>
<h3 id="1-生命周期子类型化subtypinga-b"><a class="header" href="#1-生命周期子类型化subtypinga-b">1. 生命周期子类型化（Subtyping）：<code>'a: 'b</code></a></h3>
<p>生命周期子类型化表示一个生命周期 <code>'a</code> 至少比 <code>'b</code> 长。在编写如缓存、包装器或视图（View）结构时，你经常会遇到“一个引用指向另一个引用”的情况。这时，必须确保内部引用比外部引用更长命。</p>
<h4 id="-错误演示内部引用比外部引用早死"><a class="header" href="#-错误演示内部引用比外部引用早死">❌ 错误演示：内部引用比外部引用早死</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">struct Buffer&lt;'a&gt;(&amp;'a [u8]);
// 需求：Manager 持有一个 Buffer 的引用。
// 逻辑错误：没有指定 'a 和 'b 的关系。
// 如果 'a (数据源) 比 'b (Manager对Buffer的引用) 先死，Manager 就会崩溃。
struct Manager&lt;'a, 'b&gt; {
    buf: &amp;'b Buffer&lt;'a&gt;, 
}
fn main() {
    let mut manager_ptr: Option&lt;Manager&gt; = None;
    {
        let data = vec![1, 2, 3];
        let buffer = Buffer(&amp;data); // 'a 是 data 的寿命
        
        let m = Manager { buf: &amp;buffer }; // 'b 是 buffer 的寿命
        manager_ptr = Some(m);
    } // data 在这里被销毁，'a 结束。
    // 但 'b 可能还没结束（如果 manager_ptr 还在使用），导致悬空指针。
}</code></pre>
<h4 id="-正确演示显式声明-a-b"><a class="header" href="#-正确演示显式声明-a-b">✅ 正确演示：显式声明 <code>'a: 'b</code></a></h4>
<p>通过约束，编译器会强制要求：你想给 <code>Manager</code> 用的数据，必须比 <code>Manager</code> 本身活得久。</p>
<pre><code class="language-rust ignore">// 约束：'a 必须覆盖 'b (数据源必须比借用它的 Manager 活得久)
struct Manager&lt;'a, 'b&gt; 
where 'a: 'b 
{
    buf: &amp;'b Buffer&lt;'a&gt;,
}
// 这样编译器就能在 main 函数中发现：你给的 Buffer 活不过大括号，
// 从而阻止你把 Manager 赋值给外部的 manager_ptr。</code></pre>
<h3 id="2-泛型类型生命周期约束t-a"><a class="header" href="#2-泛型类型生命周期约束t-a">2. 泛型类型生命周期约束：<code>T: 'a</code></a></h3>
<p>真实含义是：<strong>类型 <code>T</code> 中包含的所有引用，都必须活得比 <code>'a</code> 久。</strong> 如果 <code>T</code> 是一个不带引用的普通结构体（如 <code>i32</code>），它默认满足任何 <code>'a</code>（因为它永远不会因引用失效而崩溃）。</p>
<p>当你编写一个容器来装载第三方泛型数据时，你必须确保这些数据在容器存在期间是有效的。</p>
<h4 id="-正确演示refwrapper-模式"><a class="header" href="#-正确演示refwrapper-模式">✅ 正确演示：<code>RefWrapper</code> 模式</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">// T: 'a 保证了不管 T 是什么，只要它里面有引用，那些引用就得比 'a 活得久
struct RefWrapper&lt;'a, T: 'a&gt; {
    data_ref: &amp;'a T,
}
fn main() {
    let val = String::from("hello");
    // T 是 String，String 不含引用，天然满足 T: 'static，当然也满足任何 'a
    let wrapper = RefWrapper { data_ref: &amp;val };
    // 如果 T 是另一个含有引用的结构体，编译器就会检查 T 内部的引用是否覆盖 'a
}</code></pre>
<h3 id="3-trait-对象生命周期约束dyn-trait--a"><a class="header" href="#3-trait-对象生命周期约束dyn-trait--a">3. Trait 对象生命周期约束：<code>dyn Trait + 'a</code></a></h3>
<p>当你把一个对象转换成 <code>dyn Trait</code>（动态分发）并存储起来时，编译器需要知道这个“背后的具体对象”能活多久。</p>
<h3 id="为动态对象打上保质期标签"><a class="header" href="#为动态对象打上保质期标签">为动态对象打上“保质期”标签</a></h3>
<p>如果不加 <code>+ 'a</code>，编译器默认 <code>dyn Trait</code> 是 <code>+ 'static</code>。这会导致你无法将带有局部引用的对象转为 Trait 对象。</p>
<pre class="playground"><code class="language-rust editable edition2024">trait Message {
    fn print(&amp;self);
}
struct SimpleMessage&lt;'a&gt;(&amp;'a str);
impl&lt;'a&gt; Message for SimpleMessage&lt;'a&gt; {
    fn print(&amp;self) { println!("{}", self.0); }
}
// 重点：加上 + 'a，允许这个 Trait 对象持有非静态引用
fn box_message&lt;'a&gt;(msg: SimpleMessage&lt;'a&gt;) -&gt; Box&lt;dyn Message + 'a&gt; {
    Box::new(msg)
}
fn main() {
    let text = String::from("临时消息");
    let msg = SimpleMessage(&amp;text);
    let boxed = box_message(msg);
    boxed.print();
}</code></pre>
<hr>
<h2 id="六特殊生命周期"><a class="header" href="#六特殊生命周期">六、特殊生命周期</a></h2>
<p>在 Rust 中，有两个特殊的生命周期符号，一个是代表“永生”的 <code>'static</code>，另一个是代表“由你推导”的 <code>'_</code>。理解它们对于编写高质量的库代码至关重要。</p>
<h3 id="1-static-静态生命周期"><a class="header" href="#1-static-静态生命周期">1. <code>'static</code> 静态生命周期</a></h3>
<p><code>'static</code> 生命周期代表程序整个运行期间有效的引用，通常用于程序的常量和静态变量：</p>
<pre><code class="language-rust ignore">static NAME: &amp;str = "Rust";</code></pre>
<p>这是 Rust 中最长命的生命周期。但它有两种完全不同的用法，混淆这两者是很多开发者的噩梦。</p>
<h4 id="a-引用类型static-t"><a class="header" href="#a-引用类型static-t">A. 引用类型：<code>&amp;'static T</code></a></h4>
<p>这表示引用指向的数据在程序的<strong>整个运行期间</strong>都存在（通常存储在二进制文件的 <code>.data</code> 或 <code>.rodata</code> 段中）。</p>
<pre class="playground"><code class="language-rust editable edition2024">// 正确：字符串字面量默认就是 &amp;'static str
let s: &amp;'static str = "我永远存在";

/* 错误演示：试图将局部变量标记为 'static
fn main() {
    let local_string = String::from("I am local");
    // 报错：local_string 存活时间不够长，无法变为 'static
    let s: &amp;'static str = &amp;local_string; 
}
*/</code></pre>
<h4 id="b-特征绑定t-static"><a class="header" href="#b-特征绑定t-static">B. 特征绑定：<code>T: 'static</code></a></h4>
<p>这是最容易误解的地方。它不代表 <code>T</code> 必须活一辈子，而是代表：<strong><code>T</code> 内部要么不包含任何引用，要么包含的所有引用都是 <code>'static</code> 的</strong></p>
<p>为什么 <code>String</code> 满足 <code>T: 'static</code>？</p>
<p><code>String</code> 拥有它自己的数据，它内部不持有任何对外界的引用。所以它被认为是“自给自足”的，满足 <code>T: 'static</code>。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn print_it&lt;T: 'static&gt;(item: T) {
    println!("我接受任何 'static 的数据");
}
fn main() {
    let s = String::from("我虽然是局部的，但我没有引用别人");
    // ✅ 正确：String 满足 T: 'static
    print_it(s); 
    let local_val = 10;
    let r = &amp;local_val; 
    // ❌ 错误：r 是一个包含局部引用的类型，它不满足 T: 'static
    // print_it(r); 
}</code></pre>
<h3 id="2-匿名生命周期占位符-_"><a class="header" href="#2-匿名生命周期占位符-_">2. 匿名生命周期占位符 <code>'_</code></a></h3>
<p><code>'_</code> 并不代表一个新的生命周期，它是一个<strong>语法糖</strong>。它告诉编译器：“这里确实需要一个生命周期，但我不想手动起名字，请按照<strong>省略规则</strong>帮我填上。”</p>
<h4 id="简化-impl-块中的冗余"><a class="header" href="#简化-impl-块中的冗余">简化 <code>impl</code> 块中的冗余</a></h4>
<p>当你在为带有生命周期的结构体编写 <code>impl</code> 时，<code>'_</code> 能让代码清爽很多。</p>
<h5 id="-繁琐写法到处都是-a"><a class="header" href="#-繁琐写法到处都是-a">❌ 繁琐写法：到处都是 <code>'a</code></a></h5>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct StrHolder&lt;'a&gt; {
    s: &amp;'a str,
}
// 每次都要声明并写出 &lt;'a&gt;
impl&lt;'a&gt; StrHolder&lt;'a&gt; {
    fn get_s(&amp;self) -&gt; &amp;str { self.s }
}
<span class="boring">}</span></code></pre>
<h5 id="-优雅写法使用-_"><a class="header" href="#-优雅写法使用-_">✅ 优雅写法：使用 <code>'_</code></a></h5>
<pre class="playground"><code class="language-rust editable edition2024">// 在 impl 中使用 '_，编译器会自动关联 self 的生命周期
impl StrHolder&lt;'_&gt; {
    fn new(s: &amp;str) -&gt; StrHolder&lt;'_&gt; {
        StrHolder { s }
    }
}</code></pre>
<h4 id="匿名生命周期占位符通常用于简化函数签名它告诉编译器自动推导生命周期"><a class="header" href="#匿名生命周期占位符通常用于简化函数签名它告诉编译器自动推导生命周期">匿名生命周期占位符通常用于简化函数签名，它告诉编译器自动推导生命周期</a></h4>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
    s.split_whitespace().next().unwrap()
}</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>符号</th><th>它的“潜台词”</th><th>典型场景</th></tr>
</thead>
<tbody>
<tr><td><code>&amp;'static T</code></td><td>“这个数据永远不会死”</td><td>硬编码的配置、静态常量</td></tr>
<tr><td><code>T: 'static</code></td><td>“这个对象内部没有任何临时工”</td><td>需要把对象发给另一个线程</td></tr>
<tr><td><code>'_</code></td><td>“这里该有个寿命，但我懒得取名，编译器你看着办”</td><td>结构体实现、复杂的嵌套引用省略</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="七型变"><a class="header" href="#七型变">七、型变</a></h2>
<p>型变是 Rust 编译器处理“子类型转换”的一套规则。在生命周期中，如果 <code>'a: 'b</code>（<code>'a</code> 比 <code>'b</code> 长），我们认为 <code>'a</code> 是 <code>'b</code> 的子类型。型变决定了当你把一个“长命引用”传给需要“短命引用”的地方时，这种转换是否合法。</p>
<h3 id="1-协变covariance长命变短命向上转型"><a class="header" href="#1-协变covariance长命变短命向上转型">1. 协变（Covariance）：长命变短命（向上转型）</a></h3>
<p>协变是指子类型可以作为父类型的替代品。例如，在 Rust 中，<code>&amp;T</code> 是协变的：</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: &amp;str = "hello";
let y: &amp;dyn ToString = &amp;x; // 协变
<span class="boring">}</span></code></pre>
<p>这是最自然的逻辑。你有一个活 100 年的引用，传给一个只需要 10 年引用的函数，这显然是安全的。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn take_short&lt;'b&gt;(input: &amp;'b str) {
    println!("我只需要短命引用: {}", input);
}
fn main() {
    let s: &amp;'static str = "我是永生的"; // 'static 是所有生命周期的子类型
    // ✅ 协变：&amp;'static str 自动转换（降级）为 &amp;'b str
    take_short(s); 
}</code></pre>
<p><strong>结论</strong>：<code>&amp;'a T</code> 对 <code>'a </code>是协变的，对 <code>T</code> 也是协变的。</p>
<h3 id="2-逆变contravariance-短命变长命反向转型"><a class="header" href="#2-逆变contravariance-短命变长命反向转型">2. 逆变（Contravariance）: 短命变长命（反向转型）</a></h3>
<p>逆变是指父类型可以作为子类型的替代品，通常在函数类型中出现。</p>
<p>如果 $’a : ’b$，则 $F&lt;’b&gt;$ 可以转换为 $F&lt;’a&gt;$。</p>
<pre><code class="language-txt">// 这里的 F 是 fn(&amp;'a str)
// 如果一个函数能处理短命引用，那么它一定也能处理长命引用。
// 所以 fn(&amp;'short str) 实际上比 fn(&amp;'long str) 的兼容性更强（它是父类）。
</code></pre>
<pre class="playground"><code class="language-rust editable edition2024">// 这是一个“要求高”的函数：它要求传入的处理器必须能处理 'static 引用
fn execute_static_handler(handler: fn(&amp;'static str)) {
    handler("I am static");
}
// 这是处理器 A：只能处理 'static
fn static_only(s: &amp;'static str) {
    println!("Only static: {}", s);
}
// 这是处理器 B：能力极强，能处理任何生命周期的引用（比如 'a）
fn flexible_handler&lt;'a&gt;(s: &amp;'a str) {
    println!("I can handle anything, even short: {}", s);
}
fn main() {
    // 1. 传入匹配的处理器，毫无疑问可以
    execute_static_handler(static_only);

    // 2. 传入“能力更强”的处理器（逆变生效！）
    // 虽然 execute_static_handler 要求的是 fn(&amp;'static str)
    // 但我们可以把 fn(&amp;'a str) 传给它。
    // 因为一个能处理短命引用的函数，必然能安全地处理长命引用。
    execute_static_handler(flexible_handler);
}</code></pre>
<h3 id="3-不变性invariance-严丝合缝禁止转换"><a class="header" href="#3-不变性invariance-严丝合缝禁止转换">3. 不变性（Invariance）: 严丝合缝（禁止转换）</a></h3>
<p>不变性意味着类型不能进行替换。在 Rust 中，<code>&amp;mut T</code> 是不变的。想象中的错误（如果 &amp;mut 是协变的）：</p>
<pre class="playground"><code class="language-rust editable edition2024">fn swap_ref&lt;'a&gt;(target: &amp;mut &amp;'a str, new_val: &amp;'a str) {
    *target = new_val;
}
fn main() {
    let mut long_lived: &amp;'static str = "static";
    {
        let short_lived = String::from("short");
        // 如果 &amp;mut 是协变的，这里就会允许把 &amp;mut &amp;'static 降级为 &amp;mut &amp;'local
        // 然后 swap_ref 就会把 short_lived 的地址塞进 long_lived 变量
        // swap_ref(&amp;mut long_lived, &amp;short_lived); 
    }
    // 大括号结束，short_lived 销毁。
    // 如果上面成功了，这里的 long_lived 就指向了垃圾内存！
    // println!("{}", long_lived); 
}</code></pre>
<p><strong>结论</strong>：&amp;mut T 对于 T 是不变的。这种限制强制要求你存入的数据寿命必须与容器定义的寿命绝对相等。</p>
<h3 id="4-常见容器与智能指针的型变规则"><a class="header" href="#4-常见容器与智能指针的型变规则">4. 常见容器与智能指针的型变规则</a></h3>
<p><code>Box&lt;T&gt;</code>、<code>Rc&lt;T&gt;</code>、<code>Cell&lt;T&gt;</code> 等智能指针的型变规则需要特别注意。</p>
<p>在 Rust 的生命周期进阶中，理解常见容器的型变规则（Variance）是避开“生命周期冲突”报错的关键。下表总结了标准库中常用类型的型变特性：</p>
<h3 id="常见类型型变对照表"><a class="header" href="#常见类型型变对照表">常见类型型变对照表</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>类型</th><th>对 <code>'a</code> 的型变</th><th>对 <code>T</code> 的型变</th><th>备注</th></tr>
</thead>
<tbody>
<tr><td><strong><code>&amp;'a T</code></strong></td><td><strong>协变</strong></td><td><strong>协变</strong></td><td>最灵活。长命引用可降级为短命引用。</td></tr>
<tr><td><strong><code>&amp;'a mut T</code></strong></td><td><strong>协变</strong></td><td><strong>不变 (Invariant)</strong></td><td>引用本身的寿命可缩短，但指向的内容必须严格匹配。</td></tr>
<tr><td><strong><code>Box&lt;T&gt;</code></strong></td><td>-</td><td><strong>协变</strong></td><td>拥有所有权，行为类似 <code>T</code> 本身。</td></tr>
<tr><td><strong><code>Vec&lt;T&gt;</code></strong></td><td>-</td><td><strong>协变</strong></td><td>类似 <code>Box&lt;T&gt;</code>，拥有所有权。</td></tr>
<tr><td>**<code>Rc&lt;T&gt;</code> / <code>Arc&lt;T&gt;**</code></td><td>-</td><td><strong>协变</strong></td><td>虽然共享所有权，但因其不可变性（除非通过内部可变性），保持协变。</td></tr>
<tr><td>**<code>Cell&lt;T&gt;</code> / <code>RefCell&lt;T&gt;**</code></td><td>-</td><td><strong>不变 (Invariant)</strong></td><td><strong>内部可变性</strong>会导致型变失效，必须严格匹配。</td></tr>
<tr><td><strong><code>fn(T) -&gt; U</code></strong></td><td>-</td><td><strong>逆变 (T), 协变 (U)</strong></td><td>参数是反向的（逆变），返回值是正向的（协变）。</td></tr>
</tbody>
</table>
</div>
<h4 id="a-为什么-mut-t-对-t-是不变的invariant"><a class="header" href="#a-为什么-mut-t-对-t-是不变的invariant">A. 为什么 <code>&amp;mut T</code> 对 <code>T</code> 是不变的（Invariant）？</a></h4>
<p>你已经理解了“长命存入短命容器”是危险的。由于 <code>&amp;mut T</code> 允许<strong>写入</strong>，如果它是协变的，你可能会把一个短命引用塞进一个长命的引用变量里。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn overwrite&lt;'a&gt;(container: &amp;mut &amp;'a str, new_val: &amp;'a str) {
    *container = new_val;
}
fn main() {
    let mut static_str: &amp;'static str = "I'm static";
    {
        let short_string = String::from("short");
        // 如果 &amp;mut T 是协变的，这里会把 &amp;mut &amp;'static 降级为 &amp;mut &amp;'a
        // 然后 overwrite 会把 short_string 的地址存进 static_str。
        // Rust 强制要求 T 必须【完全匹配】，所以这里会报错。
        // overwrite(&amp;mut static_str, &amp;short_string); 
    }
}</code></pre>
<h4 id="b-为什么-vect-却是协变的"><a class="header" href="#b-为什么-vect-却是协变的">B. 为什么 <code>Vec&lt;T&gt;</code> 却是协变的？</a></h4>
<p>这看起来很奇怪：<code>Vec&lt;T&gt;</code> 也能写入，为什么它是协变的？
<strong>原因在于所有权（Ownership）。</strong></p>
<p>当你拥有一个 <code>Vec&lt;&amp;'static str&gt;</code> 时，你拥有这个向量的所有权。你可以把它“降级”看作一个 <code>Vec&lt;&amp;'a str&gt;</code>。当你往里面 <code>push</code> 短命引用时，编译器会根据你<strong>当前的、降级后的</strong> <code>Vec</code> 类型来检查。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut my_vec: Vec&lt;&amp;'static str&gt; = vec!["static"];
    // 协变：我们可以把 Vec&lt;&amp;'static str&gt; 传递给接受 Vec&lt;&amp;'a str&gt; 的函数
    fn consume_vec&lt;'a&gt;(v: Vec&lt;&amp;'a str&gt;) { /* ... */ }
    consume_vec(my_vec); // 成功，发生了协变（所有权转移）
}</code></pre>
<p><strong>关键区别</strong>：<code>&amp;mut T</code> 是借用（你是在改别人的东西），而 <code>Vec&lt;T&gt;</code> 是拥有（你在改自己的东西）。</p>
<h4 id="c-内部可变性的不变性陷阱cellt"><a class="header" href="#c-内部可变性的不变性陷阱cellt">C. 内部可变性的“不变性”陷阱：<code>Cell&lt;T&gt;</code></a></h4>
<p><code>Cell&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 与 <code>&amp;mut T</code> 一样，允许在不拥有所有权的情况下修改数据。因此，它们必须是<strong>不变的</strong>。</p>
<pre class="playground"><code class="language-rust editable edition2024">use std::cell::Cell;
fn main() {
    let static_cell: Cell&lt;&amp;'static str&gt; = Cell::new("static");
    
    // 尝试把 Cell&lt;&amp;'static str&gt; 降级为 Cell&lt;&amp;'a str&gt;
    // 这在 Rust 中是不允许的（Invariant）
    // let cell_alias: &amp;Cell&lt;&amp;str&gt; = &amp;static_cell; 
    
    // 如果允许降级，你可以通过 cell_alias 存入一个短命引用，
    // 从而破坏原始 static_cell 的静态担保。
}</code></pre>
<hr>
<h2 id="八高级特性与复杂模式"><a class="header" href="#八高级特性与复杂模式">八、高级特性与复杂模式</a></h2>
<h3 id="1-高阶特征边界hrtbsfora"><a class="header" href="#1-高阶特征边界hrtbsfora">1. 高阶特征边界（HRTBs）：<code>for&lt;'a&gt;</code></a></h3>
<p>通常情况下，生命周期参数是由<strong>调用者</strong>确定的。但有时，我们需要一个函数能够接收一个闭包，而这个闭包处理的引用是在<strong>函数内部临时创建</strong>的。</p>
<h4 id="无法描述未来的借用"><a class="header" href="#无法描述未来的借用">无法描述“未来的借用”</a></h4>
<p>如果你使用普通的 <code>&lt;'a&gt;</code>，编译器会认为这个寿命必须在进入函数之前就存在。</p>
<pre class="playground"><code class="language-rust editable edition2024">// 错误尝试：
/*
fn execute&lt;'a, F&gt;(f: F) 
where F: Fn(&amp;'a str) 
{
    let s = String::from("local"); 
    f(&amp;s); // 报错：s 的寿命不够长。因为 'a 是在调用 execute 前就定死的。
}
*/
// ✅ 正确方案：使用 HRTBs (High-Rank Trait Bounds)
// for&lt;'a&gt; 读作：对于“任何”可能的生命周期 'a
fn execute&lt;F&gt;(f: F) 
where F: for&lt;'a&gt; Fn(&amp;'a str) 
{
    let s = String::from("local"); 
    f(&amp;s); // 成功！f 现在被要求能处理任何寿命的引用，包括函数内部这个临时的
}</code></pre>
<h3 id="2-闭包中的生命周期推导与显式标注"><a class="header" href="#2-闭包中的生命周期推导与显式标注">2. 闭包中的生命周期推导与显式标注</a></h3>
<p>Rust 闭包的生命周期推导有时会很顽固。特别是当你返回一个借用时，编译器可能无法识别出它应该关联哪个输入。</p>
<h4 id="强制闭包生命周期"><a class="header" href="#强制闭包生命周期">强制闭包生命周期</a></h4>
<p>在复杂的 Trait 实现中，你可能需要手动给闭包的参数加上“暗示”。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut data = vec![1, 2, 3];
    // 闭包有时需要显式标注来打破推导僵局
    // 这里的标注确保闭包内部的借用不会“逃逸”或错误绑定
    let closure = |x: &amp;i32| -&gt; &amp;i32 { x };
    let res = closure(&amp;data[0]);
    println!("{}", res);
}</code></pre>
<h3 id="3-再借用reborrowing机制"><a class="header" href="#3-再借用reborrowing机制">3. 再借用（Reborrowing）机制</a></h3>
<p>这是 Rust 默默为你做的一项优化。当你把一个 <code>&amp;mut T</code> 传给函数时，你并没有“移动”这个可变引用，而是进行了一次<strong>透明的再借用</strong>。</p>
<h4 id="为什么可变引用可以连续使用"><a class="header" href="#为什么可变引用可以连续使用">为什么可变引用可以连续使用？</a></h4>
<p>按理说 <code>&amp;mut T</code> 是不具备 <code>Copy</code> 特性的，传给函数后应该就没了。但得益于再借用，你可以这样做：</p>
<pre class="playground"><code class="language-rust editable edition2024">fn touch(s: &amp;mut String) {
    s.push_str("!");
}
fn main() {
    let mut message = String::from("Hello");
    let r = &amp;mut message;
    touch(r); // 这里发生了 reborrow: touch(&amp;mut *r)
    touch(r); // r 依然可用！
    // 但是：你不能在持有再借用的同时使用原始引用
    // let r2 = &amp;mut *r; // r2 是从 r 再借用的
    // touch(r);        // 错误：此时 r 被 r2 锁定了
    // touch(r2);
}</code></pre>
<h3 id="4-非词法生命周期nll-non-lexical-lifetimes"><a class="header" href="#4-非词法生命周期nll-non-lexical-lifetimes">4. 非词法生命周期（NLL, Non-Lexical Lifetimes）</a></h3>
<p>在旧版 Rust 中，生命周期必须持续到大括号结束。NLL 引入后，编译器会分析<strong>数据流图</strong>，只要一个引用在之后不再被使用，它的寿命就会<strong>提前结束</strong>。</p>
<h4 id="在同一个块中先借用再修改"><a class="header" href="#在同一个块中先借用再修改">在同一个块中先借用再修改</a></h4>
<p>这在处理字典（HashMap）的“查询并修改”逻辑时非常有用。</p>
<pre class="playground"><code class="language-rust editable edition2024">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert("key", "value");
    let val = map.get("key"); // 不可变借用开始
    if let Some(v) = val {
        println!("{}", v);
    } // NLL 识别到 val 的使用到此结束
    map.insert("key", "new_value"); // ✅ 成功：即使没出大括号，借用也已提前释放
}</code></pre>
<h3 id="5-生命周期收缩lifetime-narrowing"><a class="header" href="#5-生命周期收缩lifetime-narrowing">5. 生命周期收缩（Lifetime Narrowing）</a></h3>
<p>这其实是<strong>协变</strong>的一种表现。当编译器发现你把一个长命引用赋值给一个短命需求时，它会自动“收缩”引用的法律身份。这通常发生在匹配分支或循环中，确保类型系统能通过。</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="迭代器"><a class="header" href="#迭代器">迭代器</a></h1>
<p>Rust 的迭代器（<code>iterators</code>）是处理序列数据的强大工具，允许你以懒惰（lazy）方式遍历集合，而不立即计算所有元素。这提高了效率，尤其在链式操作中。迭代器实现了 <code>Iterator trait</code>，提供 next() 方法返回 <code>Option&lt;Item&gt;</code>。Rust 标准库中的许多类型如 <code>Vec、HashMap、Range</code> 等都支持迭代器。迭代器是零成本抽象，编译时优化。</p>
<h2 id="一-核心概念"><a class="header" href="#一-核心概念">一、 核心概念</a></h2>
<h3 id="1-迭代器的本质延迟计算lazy-evaluation"><a class="header" href="#1-迭代器的本质延迟计算lazy-evaluation">1. 迭代器的本质：延迟计算（Lazy Evaluation）</a></h3>
<p>在 Rust 中，创建一个迭代器并<strong>不会</strong>立刻执行任何计算。它更像是一个“处方”或“计划书”。只有当你真正开始向迭代器“要东西”时，它才会开始工作。</p>
<h4 id="为什么我的代码没运行"><a class="header" href="#为什么我的代码没运行">为什么我的代码没运行？</a></h4>
<p>很多初学者写了 <code>map</code> 却发现没有任何输出，这就是因为没有触发“消费”。这就是 <code>Lazy</code>：先建管道，后执行。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![1, 2, 3];
    // 这一行代码几乎不消耗时间，也不会打印任何东西
    // 它只是创建了一个“计划”：把每个元素加 1
    let v_iter = v.iter().map(|x| {
        println!("正在计算: {}", x);
        x + 1
    });
    println!("迭代器已创建，准备开始...");
    // 只有到了这一步，或者使用 for 循环，计算才会真正发生
    let result: Vec&lt;_&gt; = v_iter.collect(); 
    println!("最终结果: {:?}", result);
}</code></pre>
<h3 id="2-迭代器与-for-循环的关系"><a class="header" href="#2-迭代器与-for-循环的关系">2. 迭代器与 <code>for</code> 循环的关系</a></h3>
<p><strong>核心逻辑</strong>：Rust 的 <code>for</code> 循环其实是<strong>语法糖</strong>。当你写 <code>for x in items</code> 时，编译器在底层会自动将其转换为迭代器调用。</p>
<h4 id="编译器做了什么"><a class="header" href="#编译器做了什么">编译器做了什么？</a></h4>
<p>当你写下这段代码：</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for x in vec![1, 2, 3] {
    println!("{}", x);
}
<span class="boring">}</span></code></pre>
<p>编译器实际上将其“展开”为类似这样的逻辑：</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut iter = vec![1, 2, 3].into_iter(); // 转换为迭代器
while let Some(x) = iter.next() {         // 不断调用 next()
    println!("{}", x);
}
<span class="boring">}</span></code></pre>
<ul>
<li><strong>注意</strong>：迭代器内部维护了一个状态（通常是一个指针或索引），每次调用 <code>next()</code>，状态就会向后移动。</li>
</ul>
<h3 id="3-消费端consumers与适配器adapters"><a class="header" href="#3-消费端consumers与适配器adapters">3. 消费端（Consumers）与适配器（Adapters）</a></h3>
<p>迭代器的操作可以分为两类，理解它们的区别是掌握数据流的关键。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>类别</th><th>作用</th><th>特点</th><th>例子</th></tr>
</thead>
<tbody>
<tr><td><strong>适配器 (Adapters)</strong></td><td>将一个迭代器转变为另一个迭代器</td><td><strong>惰性</strong>。不触发计算，只定义变换逻辑。</td><td><code>map</code>, <code>filter</code>, <code>zip</code>, <code>take</code></td></tr>
<tr><td><strong>消费端 (Consumers)</strong></td><td>启动迭代过程，产生最终结果</td><td><strong>主动</strong>。会调用 <code>next()</code>，触发整个链条的运行。</td><td><code>collect</code>, <code>sum</code>, <code>fold</code>, <code>count</code></td></tr>
</tbody>
</table>
</div>
<h4 id="组合的威力"><a class="header" href="#组合的威力">组合的威力</a></h4>
<p>你可以通过适配器构建一条复杂的“流水线”，最后用一个消费端收尾。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6];
    // 流水线设计：
    let sum: i32 = numbers.iter()
        .filter(|&amp;&amp;x| x % 2 == 0) // 适配器：只要偶数
        .map(|&amp;x| x * x)          // 适配器：平方
        .take(2)                  // 适配器：只要前两个
        .sum();                   // 消费端：触发所有计算并求和
    println!("前两个偶数的平方和: {}", sum); // (2*2) + (4*4) = 20
}</code></pre>
<hr>
<h2 id="二三大核心-trait"><a class="header" href="#二三大核心-trait">二、三大核心 Trait</a></h2>
<ul>
<li><code>Iterator Trait</code>：核心接口，理解 <code>next()</code> 方法与 <code>Item</code> 关联类型</li>
<li><code>IntoIterator Trait</code>：如何将集合（如 <code>Vec, HashMap</code>）转换为迭代器</li>
<li><code>FromIterator Trait：collect()</code> 方法背后的原理（如何将迭代器转回集合）</li>
</ul>
<p>在 Rust 中，迭代器不是某种特殊的语言构造，而是通过三个核心 Trait 构建的体系。理解了这三个 Trait，你就理解了数据如何在“集合”与“流水线”之间流转。
这一部分你只要抓住一条主线就够了：</p>
<blockquote>
<p>for 负责把东西变成迭代器（IntoIterator） →
迭代器用 next() 吐元素（Iterator） →
collect() 把元素“装回去”（FromIterator）</p>
</blockquote>
<p>可以把它想成一条流水线：</p>
<p>集合/自定义类型 ──(<code>IntoIterator</code>)──&gt; 迭代器 ──(<code>Iterator::next</code>)──&gt; 元素序列 ──(<code>FromIterator/collect</code>)──&gt; 新集合</p>
<h3 id="1-iterator-trait迭代器的基石"><a class="header" href="#1-iterator-trait迭代器的基石">1. <code>Iterator</code> Trait：迭代器的基石</a></h3>
<p>这是最核心的 Trait。只要一个类型实现了它，它就是一个迭代器。</p>
<h4 id="最核心的两个东西item--next"><a class="header" href="#最核心的两个东西item--next">最核心的两个东西：Item + next()</a></h4>
<p>Iterator 的本质就是一个状态机：每次调用 next()，迭代器推进内部状态并尝试产出一个元素。</p>
<blockquote>
<p>next() 的签名必须是 <code>&amp;mut self</code>：因为每次迭代都会改变“我迭到哪了”的内部状态。</p>
</blockquote>
<p>典型形态（要记住结构）：</p>
<pre><code class="language-rust ignore">trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}</code></pre>
<ul>
<li><strong><code>type Item</code></strong>：关联类型，定义了迭代器每次产出什么。</li>
<li><strong><code>fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;</code></strong>：这是唯一需要手动实现的方法。</li>
</ul>
<h5 id="手动实现一个步进器"><a class="header" href="#手动实现一个步进器">手动实现一个“步进器”</a></h5>
<p>通过手动实现，你会发现迭代器只是一个<strong>记录了当前状态</strong>的结构体。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct Counter {
    count: u32,
    max: u32,
}
impl Counter {
    fn new(max: u32) -&gt; Counter {
        Counter { count: 0, max }
    }
}
// 手动实现 Iterator
impl Iterator for Counter {
    type Item = u32; // 告诉编译器，我们产出的是 u32
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.count &lt; self.max {
            self.count += 1;
            Some(self.count)
        } else {
            None // 返回 None 代表迭代结束
        }
    }
}
fn main() {
    let mut counter = Counter::new(3);
    // 我们可以手动调用 next
    assert_eq!(counter.next(), Some(1));
    assert_eq!(counter.next(), Some(2));
    assert_eq!(counter.next(), Some(3));
    assert_eq!(counter.next(), None);
}</code></pre>
<h5 id="手动调用-next最直观理解迭代器"><a class="header" href="#手动调用-next最直观理解迭代器">手动调用 next()：最直观理解迭代器</a></h5>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![10, 20, 30];
    // Vec&lt;T&gt; 的 into_iter() 生成一个“拿走所有权”的迭代器
    let mut it = v.into_iter();
    println!("{:?}", it.next()); // Some(10)
    println!("{:?}", it.next()); // Some(20)
    println!("{:?}", it.next()); // Some(30)
    println!("{:?}", it.next()); // None
    println!("{:?}", it.next()); // 依然 None（很多迭代器是 fused 的，但不是 trait 强制）
}</code></pre>
<p>你看到的就是：<strong>迭代器每次吐一个元素，吐完就 None</strong>。</p>
<h4 id="iterator-的很多方法从哪来的"><a class="header" href="#iterator-的很多方法从哪来的">Iterator 的“很多方法”从哪来的？</a></h4>
<p>map/filter/take/fold/sum/… 这些几乎都是 Iterator trait 上的默认方法，基于 next() 组合出来的。你只要实现 next()，Rust 标准库就送你一整套“函数式管道工具”。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let sum: i32 = (1..=10)
        .map(|x| x * 2)      // 适配器：生成新迭代器
        .filter(|x| x % 3 == 0)
        .sum();              // 消耗器：触发执行
    println!("{sum}");
}</code></pre>
<h3 id="2-intoiterator-trait集合如何变成迭代器for-循环背后"><a class="header" href="#2-intoiterator-trait集合如何变成迭代器for-循环背后">2. <code>IntoIterator</code> Trait：集合如何变成迭代器（for 循环背后）</a></h3>
<p><strong>核心逻辑</strong>：这个 Trait 定义了如何将一个非迭代器类型（如 <code>Vec</code>）转换为迭代器。这也是 <code>for</code> 循环能够工作的根本原因。</p>
<h4 id="for-循环到底做了什么"><a class="header" href="#for-循环到底做了什么">for 循环到底做了什么？</a></h4>
<p><code>for x in something</code> 做的第一件事是：</p>
<blockquote>
<p>调用 <code>something.into_iter()</code>（准确地说是 <code>IntoIterator::into_iter(something)</code>）</p>
</blockquote>
<p>然后不断 next()。</p>
<p>等价理解（伪展开）：</p>
<pre><code class="language-rust ignore">let mut iter = something.into_iter();
while let Some(x) = iter.next() {
    // ...
}

## `IntoIterator`的定义

```rust,ignore
trait IntoIterator {
    type Item;
    type IntoIter: Iterator&lt;Item = Self::Item&gt;;
    fn into_iter(self) -&gt; Self::IntoIter;
}</code></pre>
<p>这里的关键是：</p>
<ul>
<li><code>IntoIterator</code> 负责“怎么生成迭代器”</li>
<li>生成的迭代器必须实现 <code>Iterator</code></li>
<li><code>Item</code> 决定了你在 <code>for x in ...</code> 里拿到的 <code>x</code> 是什么类型</li>
</ul>
<h4 id="同一个容器有-3-种常见-intoiterator-实现"><a class="header" href="#同一个容器有-3-种常见-intoiterator-实现">同一个容器有 3 种常见 IntoIterator 实现</a></h4>
<p>以 <code>Vec&lt;T&gt;</code> 为例：</p>
<ul>
<li><code>Vec&lt;T&gt;</code>（按值）→ <code>into_iter()</code> 产出 <code>T</code>（<strong>消耗原集合</strong>）</li>
<li><code>&amp;Vec&lt;T&gt;</code>（共享借用）→ <code>into_iter()</code> 产出 <code>&amp;T</code></li>
<li><code>&amp;mut Vec&lt;T&gt;</code>（可变借用）→ <code>into_iter()</code> 产出 <code>&amp;mut T</code></li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![String::from("a"), String::from("b")];
    // 1) 借用遍历：拿到 &amp;String
    for s in &amp;v {
        println!("borrowed: {s}");
    }
    println!("still have v: {:?}", v);
    // 2) 所有权遍历：拿到 String（v 被 move 走）
    for s in v {
        println!("owned: {s}");
    }
    // println!("{:?}", v); // ❌ v 已经被消耗
}</code></pre>
<h4 id="自定义类型实现-intoiterator让它能直接-for--in-"><a class="header" href="#自定义类型实现-intoiterator让它能直接-for--in-">自定义类型实现 <code>IntoIterator</code>：让它能直接 <code>for .. in ..</code></a></h4>
<p>比如自定义一个范围类型：</p>
<pre class="playground"><code class="language-rust editable edition2024">struct MyRange {
    start: i32,
    end: i32,
}
struct MyRangeIter {
    cur: i32,
    end: i32,
}
impl Iterator for MyRangeIter {
    type Item = i32;
    fn next(&amp;mut self) -&gt; Option&lt;i32&gt; {
        if self.cur &gt;= self.end {
            None
        } else {
            let v = self.cur;
            self.cur += 1;
            Some(v)
        }
    }
}
impl IntoIterator for MyRange {
    type Item = i32;
    type IntoIter = MyRangeIter;
    fn into_iter(self) -&gt; MyRangeIter {
        MyRangeIter { cur: self.start, end: self.end }
    }
}
fn main() {
    for x in MyRange { start: 0, end: 3 } {
        println!("{x}");
    }
}</code></pre>
<hr>
<h3 id="3-fromiterator-trait流水线的终点-collect"><a class="header" href="#3-fromiterator-trait流水线的终点-collect">3. <code>FromIterator</code> Trait：流水线的终点 (<code>collect</code>)</a></h3>
<p><strong>核心逻辑</strong>：这是 <code>collect()</code> 方法背后的英雄。它定义了如何将迭代器中的元素“收集”回一个新的集合。</p>
<h4 id="collect-不是魔法它靠-fromiterator"><a class="header" href="#collect-不是魔法它靠-fromiterator"><code>collect()</code> 不是魔法，它靠 <code>FromIterator</code></a></h4>
<p>你可以把 collect() 理解成：</p>
<blockquote>
<p>“请把这个迭代器的元素，按目标类型的规则装起来”</p>
</blockquote>
<p>装的规则来自：</p>
<pre><code class="language-rust ignore">trait FromIterator&lt;A&gt; {
    fn from_iter&lt;T: IntoIterator&lt;Item = A&gt;&gt;(iter: T) -&gt; Self;
}</code></pre>
<p>能 collect 成什么类型，取决于那个类型实现没实现 FromIterator。</p>
<h4 id="collect-为什么经常需要你标注类型"><a class="header" href="#collect-为什么经常需要你标注类型"><code>collect()</code> 为什么经常需要你标注类型？</a></h4>
<p>因为光看迭代器元素，编译器不知道你要装进 Vec 还是 HashSet 还是别的。</p>
<p>两种常见写法：</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![1, 2, 3];
    // 写法 1：变量类型标注
    let a: Vec&lt;i32&gt; = v.iter().map(|x| x * 10).collect();
    println!("{a:?}");
    // 写法 2：turbofish
    // let a = v.iter().map(|x| x * 10).collect::&lt;Vec&lt;i32&gt;&gt;();
    // println!("{a:?}");
}</code></pre>
<h4 id="常见-collect-目标vec--hashmap--string"><a class="header" href="#常见-collect-目标vec--hashmap--string">常见 <code>collect</code> 目标：<code>Vec / HashMap / String</code></a></h4>
<p><strong>collect 到 Vec：</strong></p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let out: Vec&lt;i32&gt; = (0..5).map(|x| x * 2).collect();
    println!("{out:?}");
}</code></pre>
<p><strong>collect 到 HashMap：</strong></p>
<pre class="playground"><code class="language-rust editable edition2024">use std::collections::HashMap;
fn main() {
    let pairs = vec![("a", 1), ("b", 2)];
    let map: HashMap&lt;&amp;str, i32&gt; = pairs.into_iter().collect();
    println!("{map:?}");
}</code></pre>
<p><strong>collect 到 String（从 char 序列）：</strong></p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let s: String = ['R', 'u', 's', 't'].into_iter().collect();
    println!("{s}");
}</code></pre>
<h4 id="collectresultvec_-_fromiterator-的高级爽点"><a class="header" href="#collectresultvec_-_fromiterator-的高级爽点"><code>collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()</code>：<code>FromIterator</code> 的“高级爽点”</a></h4>
<p><code>Result</code>（以及 <code>Option</code>）也实现了非常强大的 <code>FromIterator</code>：</p>
<ul>
<li>只要所有元素都是 <code>Ok(x)</code>，就 <code>collect</code> 成 <code>Ok(Vec&lt;x&gt;)</code></li>
<li>只要遇到一个 <code>Err(e)</code>，就立刻返回 <code>Err(e)</code>（短路）</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let inputs = vec!["10", "20", "nope", "40"];
    let parsed: Result&lt;Vec&lt;i32&gt;, _&gt; = inputs
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!("{parsed:?}"); // Err(...)
}</code></pre>
<p>这在解析、校验、批处理里非常常用：<strong>把错误处理“自动织入” <code>collect</code></strong>。</p>
<h4 id="自定义-fromiterator让别人能-collect你的类型"><a class="header" href="#自定义-fromiterator让别人能-collect你的类型">自定义 <code>FromIterator</code>：让别人能 <code>collect::&lt;你的类型&gt;()</code></a></h4>
<p>我们实现一个 EvenVec：只收集偶数（演示“自定义收集规则”）。</p>
<pre class="playground"><code class="language-rust editable edition2024">#[derive(Debug)]
struct EvenVec(Vec&lt;i32&gt;);
impl FromIterator&lt;i32&gt; for EvenVec {
    fn from_iter&lt;T: IntoIterator&lt;Item = i32&gt;&gt;(iter: T) -&gt; Self {
        let mut out = Vec::new();
        for x in iter {
            if x % 2 == 0 {
                out.push(x);
            }
        }
        EvenVec(out)
    }
}
fn main() {
    let evens: EvenVec = (0..10).collect();
    println!("{evens:?}"); // EvenVec([0,2,4,6,8])
}</code></pre>
<hr>
<h2 id="三迭代器的三种模式"><a class="header" href="#三迭代器的三种模式">三、迭代器的三种模式</a></h2>
<p><strong>核心逻辑</strong>：在 Rust 中，迭代器不仅决定如何处理数据，还决定了你是<strong>拥有</strong>这些数据，还是仅仅<strong>借用</strong>这些数据。这直接关系到借用检查器（Borrow Checker）是否会报错。</p>
<p>几乎所有的集合（如 <code>Vec</code>, <code>HashMap</code>, <code>BTreeMap</code>）都提供了这三种方法。</p>
<p>这三者的核心差异只有一件事：**迭代时“元素的所有权/借用”**到底归谁。</p>
<ul>
<li><code>iter()</code>：共享借用（<code>read-only</code>），产出 <code>&amp;T</code></li>
<li><code>iter_mut()</code>：可变借用（<code>read-write</code>），产出 <code>&amp;mut T</code></li>
<li><code>into_iter()</code>：拿走所有权（<code>move</code>），产出 T（通常会消耗原集合）</li>
</ul>
<blockquote>
<p>iter 借只读，iter_mut 借可写，into_iter 拿走不还。</p>
</blockquote>
<h3 id="1-iter不可变借用模式t"><a class="header" href="#1-iter不可变借用模式t">1. <code>iter()</code>：不可变借用模式（<code>&amp;T</code>）</a></h3>
<ul>
<li><strong>产生类型</strong>：产生元素的不可变引用 <code>&amp;T</code>。</li>
<li><strong>使用场景</strong>：你只想读取集合中的数据，而不改变数据，也不想销毁集合。</li>
<li><strong>知识点</strong>：不移动集合元素，只是“借来看看”。迭代结果类型：&amp;T。原集合仍可继续使用（只要借用期结束）。</li>
</ul>
<h4 id="代码演示读取但不修改"><a class="header" href="#代码演示读取但不修改">代码演示：读取但不修改</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![1, 2, 3];
    // iter() 产生 &amp;i32
    let mut v_iter = v.iter();
    assert_eq!(v_iter.next(), Some(&amp;1));
    assert_eq!(v_iter.next(), Some(&amp;2));
    assert_eq!(v_iter.next(), Some(&amp;3));
    // 重点：集合 v 在迭代后依然可以继续使用
    println!("v 依然存在: {:?}", v);
}</code></pre>
<h4 id="代码演示map-时注意解引用"><a class="header" href="#代码演示map-时注意解引用">代码演示：<code>map</code> 时注意解引用</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![1, 2, 3];
    // iter() 产生 &amp;i32，因此 map 的参数是 &amp;i32
    let doubled: Vec&lt;i32&gt; = v.iter().map(|x| x * 2).collect();
    // 这里 x 是 &amp;i32，但 * 运算符对 &amp;i32 会自动解引用（Deref coercion / Copy）
    println!("{:?}", doubled);
}</code></pre>
<h3 id="2-iter_mut可变借用模式mut-t"><a class="header" href="#2-iter_mut可变借用模式mut-t">2. <code>iter_mut()</code>：可变借用模式（<code>&amp;mut T</code>）</a></h3>
<ul>
<li><strong>产生类型</strong>：产生元素的可变引用 <code>&amp;mut T</code>。</li>
<li><strong>使用场景</strong>：你需要原地修改集合中的每一个元素。</li>
<li><strong>知识点</strong>:允许修改元素内容，但仍不拿走所有权。迭代结果类型：<code>&amp;mut T</code>。迭代期间，集合被“独占可变借用”，不能同时被其他借用使用。</li>
</ul>
<h4 id="代码演示原地修改元素"><a class="header" href="#代码演示原地修改元素">代码演示：原地修改元素</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut v = vec![1, 2, 3];
    // iter_mut() 产生 &amp;mut i32
    // 注意：必须要求 v 本身是 mut 的
    for x in v.iter_mut() {
        *x *= 2; // 通过解引用修改原始值
    }
    println!("v 已被原地修改: {:?}", v); // [2, 4, 6]
}</code></pre>
<h4 id="代码演示配合-enumerate-做位置相关修改"><a class="header" href="#代码演示配合-enumerate-做位置相关修改">代码演示：配合 <code>enumerate</code> 做位置相关修改</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut v = vec![5, 5, 5, 5];
    for (i, x) in v.iter_mut().enumerate() {
        *x += i as i32;
    }
    println!("{:?}", v); // [5, 6, 7, 8]
}</code></pre>
<h3 id="3-into_iter所有权模式t"><a class="header" href="#3-into_iter所有权模式t">3. <code>into_iter()</code>：所有权模式（<code>T</code>）</a></h3>
<ul>
<li><strong>产生类型</strong>：产生元素本身 <code>T</code>。</li>
<li><strong>使用场景</strong>：你需要获取元素的所有权（例如移动到另一个线程，或者转换类型），并且<strong>不再需要</strong>原始集合。</li>
<li><strong>知识点</strong>:
<ul>
<li>消耗原集合（通常 move），把元素一个个“搬走”。</li>
<li>迭代结果类型：T</li>
<li>原集合之后一般不能再用（已经 moved）。</li>
</ul>
</li>
</ul>
<blockquote>
<p>重要：into_iter() 的具体行为和返回类型，取决于你对谁调用：</p>
</blockquote>
<ul>
<li>对 <code>Vec&lt;T&gt;</code> 调用：通常产出 T（拿走元素）</li>
<li>对 <code>&amp;Vec&lt;T&gt;</code> 调用：相当于 iter()，产出 <code>&amp;T</code></li>
<li>对 <code>&amp;mut Vec&lt;T&gt;</code> 调用：相当于 iter_mut()，产出 <code>&amp;mut T</code></li>
</ul>
<h4 id="代码演示消费集合拿到元素所有权"><a class="header" href="#代码演示消费集合拿到元素所有权">代码演示：消费集合，拿到元素所有权</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![String::from("a"), String::from("b")];
    // into_iter() 产生 String（所有权）
    let upper: Vec&lt;String&gt; = v.into_iter()
        .map(|s| s.to_uppercase())
        .collect();
    println!("{:?}", upper);
    // println!("{:?}", v); // ❌ v 已被 move（被 into_iter 消耗）
}</code></pre>
<h4 id="代码演示对引用调用-into_iter类型不同"><a class="header" href="#代码演示对引用调用-into_iter类型不同">代码演示：对引用调用 into_iter（类型不同）</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![1, 2, 3];
    let a: Vec&lt;i32&gt; = (&amp;v).into_iter().copied().collect(); // &amp;Vec -&gt; &amp;i32
    let b: Vec&lt;i32&gt; = v.into_iter().collect();            // Vec -&gt; i32 (move)
    println!("{:?}", a);
    println!("{:?}", b);
}</code></pre>
<h3 id="三种模式深度对比表"><a class="header" href="#三种模式深度对比表">三种模式深度对比表</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>方法</th><th>产生的 Item</th><th>背后 Trait 实现</th><th>集合之后是否可用？</th><th>核心性质</th></tr>
</thead>
<tbody>
<tr><td><strong><code>iter()</code></strong></td><td><code>&amp;T</code></td><td><code>impl IntoIterator for &amp;Vec&lt;T&gt;</code></td><td><strong>是</strong></td><td>只读观察</td></tr>
<tr><td><strong><code>iter_mut()</code></strong></td><td><code>&amp;mut T</code></td><td><code>impl IntoIterator for &amp;mut Vec&lt;T&gt;</code></td><td><strong>是</strong></td><td>原地手术</td></tr>
<tr><td><strong><code>into_iter()</code></strong></td><td><code>T</code></td><td><code>impl IntoIterator for Vec&lt;T&gt;</code></td><td><strong>否</strong></td><td>彻底消耗</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-rust ignore">fn main() {
    let mut v = vec![1, 2, 3];
    let it1 = v.iter();      // Iterator&lt;Item = &amp;i32&gt;
    let it2 = v.iter_mut();  // Iterator&lt;Item = &amp;mut i32&gt;
    let it3 = v.into_iter(); // Iterator&lt;Item = i32&gt;  (v 被 move)
}</code></pre>
<h3 id="for-循环到底用的是谁"><a class="header" href="#for-循环到底用的是谁">for 循环到底用的是谁?</a></h3>
<p><code>for x in something {}</code> 本质上会调用 <code>IntoIterator</code></p>
<ul>
<li><code>for x in v</code> → <code>v.into_iter()</code>（可能消耗 <code>v</code>）</li>
<li><code>for x in &amp;v</code> → <code>(&amp;v).into_iter()</code>（等价 <code>iter</code>）</li>
<li><code>for x in &amp;mut v</code> → <code>(&amp;mut v).into_iter()</code>（等价 <code>iter_mut</code>）</li>
</ul>
<h4 id="代码演示三种-for-写法"><a class="header" href="#代码演示三种-for-写法">代码演示：三种 for 写法</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut v = vec![10, 20, 30];
    for x in &amp;v {
        // x: &amp;i32
        println!("read {x}");
    }
    for x in &amp;mut v {
        // x: &amp;mut i32
        *x += 1;
    }
    for x in v {
        // x: i32，v 被消费
        println!("owned {x}");
    }
    // println!("{:?}", v); // ❌ v 已被消费
}</code></pre>
<h3 id="选型建议什么时候用哪个"><a class="header" href="#选型建议什么时候用哪个">选型建议：什么时候用哪个？</a></h3>
<ul>
<li>只读遍历：用 <code>iter()</code> / <code>for x in &amp;v</code></li>
<li>原地改元素：用 <code>iter_mut()</code> / <code>for x in &amp;mut v</code></li>
<li>需要拿到元素所有权（如 String 拼接/转移/线程传递）：用 <code>into_iter()</code> / <code>for x in v</code></li>
<li>想保留原集合，但又想得到“拥有的值”：
<ul>
<li><code>iter().cloned()</code>（针对 <code>Clone</code>）</li>
<li><code>iter().copied()</code>（针对 <code>Copy</code>）</li>
</ul>
</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![1, 2, 3];
    let owned1: Vec&lt;i32&gt; = v.iter().copied().collect(); // 不消耗 v
    let owned2: Vec&lt;i32&gt; = v.clone().into_iter().collect(); // 通过 clone 再消费
    println!("{:?}", owned1);
    println!("{:?}", owned2);
    println!("{:?}", v);
}</code></pre>
<hr>
<h2 id="四常用迭代器适配器"><a class="header" href="#四常用迭代器适配器">四、常用迭代器适配器</a></h2>
<p><strong>核心逻辑</strong>：适配器（Adapters）是迭代器的“加工车间”。它们接收一个迭代器，经过某种变换，输出一个新的迭代器。最重要的一点是：<strong>它们是惰性的（Lazy）</strong>，除非最后的“消费端”（如 <code>collect</code>）发出指令，否则这些加工车间根本不会开工。</p>
<h3 id="1-基础转换map-与-filter"><a class="header" href="#1-基础转换map-与-filter">1. 基础转换：<code>map</code> 与 <code>filter</code></a></h3>
<p>这是最常用的组合，类似于 SQL 中的 <code>SELECT</code> 和 <code>WHERE</code>。</p>
<ul>
<li><strong><code>map</code></strong>：对每个元素执行转换。</li>
<li><strong><code>filter</code></strong>：根据布尔值决定是否保留元素。</li>
</ul>
<h4 id="map逐元素变换"><a class="header" href="#map逐元素变换">map：逐元素变换</a></h4>
<ul>
<li>用途：把 Item 变成另一个东西。</li>
<li>签名直觉：<code>Iterator&lt;Item=A&gt; -&gt; Iterator&lt;Item=B&gt;</code></li>
</ul>
<h5 id="示例i32--i32-的差异最常见坑"><a class="header" href="#示例i32--i32-的差异最常见坑">示例：&amp;i32 / i32 的差异（最常见坑）</a></h5>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![1, 2, 3];
    // v.iter() 产出 &amp;i32，所以闭包参数是 &amp;i32
    let a: Vec&lt;i32&gt; = v.iter().map(|&amp;x| x * 10).collect();// 写法 A：参数里解构, 把 &amp;i32 解引用一层，绑定到 x: i32
    //写法 B：闭包体里解引用:
    // let b: Vec&lt;i32&gt; = v.iter().map(|x| *x * 10).collect();
    // 或者：map(|x| x * 10) 也能过（很多运算会自动解引用），但建议显式 |&amp;x| 养成习惯
    // v.into_iter() 产出 i32，闭包参数是 i32
    let b: Vec&lt;i32&gt; = v.into_iter().map(|x| x * 10).collect();
    println!("{a:?} {b:?}");
}</code></pre>
<h4 id="filter筛选01-对-1"><a class="header" href="#filter筛选01-对-1">filter：筛选（0/1 对 1）</a></h4>
<ul>
<li>用途：按条件保留元素。</li>
<li>关键点：闭包拿到的是 引用的引用 时要解两次（比如 v.iter()）</li>
</ul>
<h5 id="示例过滤偶数注意-x"><a class="header" href="#示例过滤偶数注意-x">示例：过滤偶数（注意 |&amp;&amp;x|）</a></h5>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![1, 2, 3, 4, 5];
    let evens: Vec&lt;i32&gt; = v.iter()
        .filter(|&amp;&amp;x| x % 2 == 0) // 这里 x: &amp;&amp;i32
        .copied()
        .collect();
    println!("{evens:?}"); // [2, 4]
}</code></pre>
<h5 id="常用替代filter_map过滤--映射一步到位"><a class="header" href="#常用替代filter_map过滤--映射一步到位">常用替代：filter_map（过滤 + 映射，一步到位）</a></h5>
<p>这在实际项目里非常高频（解析、容错、跳过非法数据）</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec!["1", "oops", "3", "-7"];
    let nums: Vec&lt;i32&gt; = v.into_iter()
        .filter_map(|s| s.parse::&lt;i32&gt;().ok())
        .collect();
    println!("{nums:?}"); // [1, 3, -7]
}</code></pre>
<h3 id="2-结构操作zip-与-chain"><a class="header" href="#2-结构操作zip-与-chain">2. 结构操作：<code>zip</code> 与 <code>chain</code></a></h3>
<ul>
<li><strong><code>zip</code></strong>：将两个迭代器“拉”在一起，像拉链一样产生一对对的元组 <code>(a, b)</code>。如果长度不等，以短的为准。</li>
<li><strong><code>chain</code></strong>：将两个迭代器“接”在一起，一个完了接另一个。</li>
</ul>
<h4 id="zip并行配对短的结束就结束"><a class="header" href="#zip并行配对短的结束就结束">zip：并行配对（短的结束就结束）</a></h4>
<ul>
<li>用途：将两个迭代器“拉”在一起，并行产出元组 <code>(a, b)</code>。</li>
<li>输出类型：<code>Iterator&lt;Item=(A, B)&gt;</code></li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let names = vec!["alice", "bob", "cindy"];
    let ages  = vec![20, 30];
    // 只会产出 2 组：因为 ages 更短
    let out: Vec&lt;_&gt; = names.iter()
        .zip(ages.iter())
        .map(|(&amp;n, &amp;a)| (n, a))
        .collect();

    println!("{out:?}"); // [("alice",20), ("bob",30)]
}</code></pre>
<h4 id="chain拼接两个迭代器类型要一致"><a class="header" href="#chain拼接两个迭代器类型要一致">chain：拼接两个迭代器（类型要一致）</a></h4>
<ul>
<li>用途：将两个迭代器“接”在一起，一个完了接另一个。</li>
<li>输出类型：<code>Iterator&lt;Item=A&gt;</code>（或 <code>Iterator&lt;Item=B&gt;</code>，取决于输入）</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let a = vec![1, 2];
    let b = vec![3, 4];
    let out: Vec&lt;i32&gt; = a.into_iter().chain(b.into_iter()).collect();
    println!("{out:?}"); // [1,2,3,4]
}</code></pre>
<h3 id="3-处理嵌套flatten-与-flat_map"><a class="header" href="#3-处理嵌套flatten-与-flat_map">3. 处理嵌套：<code>flatten</code> 与 <code>flat_map</code></a></h3>
<p><strong>实践场景</strong>：当你有一个 <code>Vec&lt;Vec&lt;T&gt;&gt;</code> 或者迭代器产生的元素本身又是 <code>Option</code> 或 <code>Result</code> 时。</p>
<ul>
<li><strong><code>flatten</code></strong>：把嵌套结构“拍平”一层。</li>
<li><strong><code>flat_map</code></strong>：先 <code>map</code> 再 <code>flatten</code>。</li>
</ul>
<h4 id="flatten拍平一层元素本身是-iterable"><a class="header" href="#flatten拍平一层元素本身是-iterable">flatten：拍平一层（元素本身是 iterable）</a></h4>
<ul>
<li>用途：把 <code>Vec&lt;Vec&lt;T&gt;&gt;</code> 拍平成 <code>Vec&lt;T&gt;</code>。</li>
<li>输出类型：<code>Iterator&lt;Item=T&gt;</code></li>
</ul>
<h5 id="典型vecvectvecoptiontiteratoritemresultte配合技巧"><a class="header" href="#典型vecvectvecoptiontiteratoritemresultte配合技巧">典型：<code>Vec&lt;Vec&lt;T&gt;&gt;、Vec&lt;Option&lt;T&gt;&gt;、Iterator&lt;Item=Result&lt;T,E&gt;&gt;</code>（配合技巧）</a></h5>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![vec![1, 2], vec![3], vec![4, 5]];
    let out: Vec&lt;i32&gt; = v.into_iter().flatten().collect();
    println!("{out:?}"); // [1,2,3,4,5]
}</code></pre>
<h5 id="经典技巧option-的-flatten--把-some-留下把-none-丢掉"><a class="header" href="#经典技巧option-的-flatten--把-some-留下把-none-丢掉">经典技巧：Option 的 flatten = “把 Some 留下，把 None 丢掉”</a></h5>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![Some(1), None, Some(3)];

    let out: Vec&lt;i32&gt; = v.into_iter().flatten().collect();
    println!("{out:?}"); // [1,3]
}</code></pre>
<h4 id="flat_mapmap--flatten常用于拆分展开"><a class="header" href="#flat_mapmap--flatten常用于拆分展开">flat_map：map + flatten（常用于拆分/展开）</a></h4>
<ul>
<li>用途：先 <code>map</code> 再 <code>flatten</code>，常用于拆分/展开。</li>
<li>输出类型：<code>Iterator&lt;Item=T&gt;</code></li>
</ul>
<h5 id="示例拆分字符串按空格"><a class="header" href="#示例拆分字符串按空格">示例：拆分字符串（按空格）</a></h5>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let lines = vec!["hello world", "rust iter"];
    let words: Vec&lt;&amp;str&gt; = lines.into_iter()
        .flat_map(|line| line.split_whitespace())
        .collect();
    println!("{words:?}"); // ["hello","world","rust","iter"]
}</code></pre>
<h3 id="4-引用处理cloned-与-copied"><a class="header" href="#4-引用处理cloned-与-copied">4. 引用处理：<code>cloned</code> 与 <code>copied</code></a></h3>
<p>当你在使用 <code>iter()</code>（产生 <code>&amp;T</code>）但后续操作需要 <code>T</code> 时，这两个适配器非常有用。</p>
<ul>
<li>
<p><strong><code>cloned()</code></strong>：调用 <code>clone()</code> 产生拥有所有权的值（适用于 <code>String</code> 等）。</p>
</li>
<li>
<p><strong><code>copied()</code></strong>：调用按位拷贝（适用于 <code>i32</code> 等实现了 <code>Copy</code> 的类型）。</p>
</li>
<li>
<p>copied()：&amp;T -&gt; T，要求 T: Copy（如 i32、bool、char）</p>
</li>
<li>
<p>cloned()：&amp;T -&gt; T，要求 T: Clone（如 String、Vec、Arc 等）</p>
</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let a = vec![1, 2, 3];
    let x: Vec&lt;i32&gt; = a.iter().copied().collect();
    let b = vec!["hi".to_string(), "rust".to_string()];
    let y: Vec&lt;String&gt; = b.iter().cloned().collect();
    println!("{x:?}");
    println!("{y:?}");
}</code></pre>
<h3 id="5-截取与跳过take-skip-take_while-skip_while"><a class="header" href="#5-截取与跳过take-skip-take_while-skip_while">5. 截取与跳过：take, skip, take_while, skip_while</a></h3>
<ul>
<li><strong><code>take(n)</code></strong>：只取前 <code>n</code> 个元素。</li>
<li><strong><code>skip(n)</code></strong>：跳过前 <code>n</code> 个元素。</li>
<li><strong><code>take_while(pred)</code></strong>：取元素直到 <code>pred</code> 为 <code>false</code>。</li>
<li><strong><code>skip_while(pred)</code></strong>：跳过元素直到 <code>pred</code> 为 <code>false</code>。</li>
</ul>
<h4 id="taken--skipn按数量切"><a class="header" href="#taken--skipn按数量切">take(n) / skip(n)：按数量切</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![1, 2, 3, 4, 5];
    let a: Vec&lt;i32&gt; = v.iter().take(3).copied().collect(); // [1,2,3]
    let b: Vec&lt;i32&gt; = v.iter().skip(3).copied().collect(); // [4,5]
    println!("{a:?} {b:?}");
}</code></pre>
<h4 id="take_while--skip_while按条件切遇到不满足就停止开始"><a class="header" href="#take_while--skip_while按条件切遇到不满足就停止开始">take_while / skip_while：按条件切（遇到不满足就停止/开始）</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![1, 2, 3, 4, 3, 2];
    let a: Vec&lt;i32&gt; = v.iter().take_while(|&amp;&amp;x| x &lt; 4).copied().collect();
    let b: Vec&lt;i32&gt; = v.iter().skip_while(|&amp;&amp;x| x &lt; 4).copied().collect();
    println!("{a:?}"); // [1,2,3]
    println!("{b:?}"); // [4,3,2]  注意：从第一个不满足开始，后面不再检查条件
}</code></pre>
<p>skip_while 不是“过滤”，它只在开头连续跳过；一旦开始产出，后续不会再跳。</p>
<h3 id="6-辅助工具enumerate-与-inspect"><a class="header" href="#6-辅助工具enumerate-与-inspect">6. 辅助工具：<code>enumerate</code> 与 <code>inspect</code></a></h3>
<ul>
<li><strong><code>enumerate</code></strong>：在迭代时顺便产出索引 <code>(index, value)</code>。</li>
<li><strong><code>inspect</code></strong>：不修改元素，只是查看（常用于调试，看看流水线中间的状态）。</li>
</ul>
<h4 id="enumerate给元素附上索引"><a class="header" href="#enumerate给元素附上索引">enumerate：给元素附上索引</a></h4>
<ul>
<li>用途：做“位置相关”的逻辑（比如给每个元素编号）。</li>
<li>输出类型：<code>(usize, Item)</code></li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec!["a", "b", "c"];
    let pairs: Vec&lt;(usize, &amp;str)&gt; = v.iter()
        .enumerate()
        .map(|(i, &amp;s)| (i, s))
        .collect();
    println!("{pairs:?}"); // [(0,"a"), (1,"b"), (2,"c")]
}</code></pre>
<h4 id="调试辅助inspect"><a class="header" href="#调试辅助inspect">调试辅助：inspect</a></h4>
<ul>
<li>用途：在链条中间打印/埋点，不改变元素。</li>
<li>注意：仍然 lazy，只有终结器触发才会打印。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let out: Vec&lt;i32&gt; = (1..=5)
        .inspect(|x| println!("before map: {x}"))
        .map(|x| x * 10)
        .inspect(|x| println!("after  map: {x}"))
        .filter(|x| x &gt;= &amp;30)
        .collect();
    println!("{out:?}");
}</code></pre>
<h3 id="适配器选型"><a class="header" href="#适配器选型">适配器选型</a></h3>
<p>下面是提到的这些**迭代器适配器（中间操作）**的汇总表</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>分类</th><th>适配器</th><th>作用</th></tr>
</thead>
<tbody>
<tr><td>基础转换</td><td><code>map</code></td><td>对每个元素做映射变换（1→1），生成新迭代器</td></tr>
<tr><td>基础转换</td><td><code>filter</code></td><td>按条件过滤元素（保留满足条件的）</td></tr>
<tr><td>基础转换</td><td><code>enumerate</code></td><td>给每个元素附带索引 <code>(usize, item)</code></td></tr>
<tr><td>结构操作</td><td><code>zip</code></td><td>把两个迭代器按位置配对成 <code>(a, b)</code>，以较短者结束</td></tr>
<tr><td>结构操作</td><td><code>chain</code></td><td>把两个迭代器首尾拼接成一个连续迭代器</td></tr>
<tr><td>结构操作</td><td><code>flatten</code></td><td>拍平一层：把“元素本身可迭代”的迭代器展开一层</td></tr>
<tr><td>结构操作</td><td><code>flat_map</code></td><td><code>map</code> 后再 <code>flatten</code>：每个元素映射为迭代器并展开</td></tr>
<tr><td>截取/跳过</td><td><code>take</code></td><td>只取前 <code>n</code> 个元素</td></tr>
<tr><td>截取/跳过</td><td><code>skip</code></td><td>跳过前 <code>n</code> 个元素</td></tr>
<tr><td>截取/跳过</td><td><code>take_while</code></td><td>从头开始取，直到条件首次不满足就停止</td></tr>
<tr><td>截取/跳过</td><td><code>skip_while</code></td><td>从头开始跳过，直到条件首次不满足就开始产出（之后不再检查条件）</td></tr>
<tr><td>调试辅助</td><td><code>inspect</code></td><td>在迭代链中插入观察/打印，不改变元素（仍是 lazy）</td></tr>
<tr><td>引用处理</td><td><code>cloned</code></td><td>把 <code>&amp;T</code> 变成 <code>T</code>（要求 <code>T: Clone</code>）</td></tr>
<tr><td>引用处理</td><td><code>copied</code></td><td>把 <code>&amp;T</code> 变成 <code>T</code>（要求 <code>T: Copy</code>）</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="五-常用消耗器终结操作"><a class="header" href="#五-常用消耗器终结操作">五、 常用消耗器（终结操作）</a></h2>
<p><strong>核心逻辑</strong>：消耗器（Consumers）是流水线的“出口”。如果没有消耗器，前面的适配器（如 <code>map</code>, <code>filter</code>）永远不会执行。消耗器会通过循环不断调用迭代器的 <code>next()</code> 方法，直到返回 <code>None</code> 为止。<strong>一旦调用了消耗器，该迭代器就被消耗掉了，不能再次使用。</strong></p>
<h3 id="终极集合器collect"><a class="header" href="#终极集合器collect">终极集合器：<code>collect</code></a></h3>
<p>这是最常见的消耗器，我们在前几节已经多次用到。它将迭代器中的元素收集到某种集合中（如 <code>Vec</code>, <code>HashMap</code>, <code>String</code> 等）。</p>
<ul>
<li><strong>特点</strong>：高度泛型，通常需要类型暗示。</li>
<li><strong>技巧</strong>：它可以将 <code>Option&lt;T&gt;</code> 的迭代器收集成 <code>Option&lt;Vec&lt;T&gt;&gt;</code>。</li>
</ul>
<h4 id="关键点类型推断"><a class="header" href="#关键点类型推断">关键点：类型推断</a></h4>
<p>编译器不知道你要收集成什么就会报错，所以常见写法：</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![1, 2, 3];
    let a = v.iter().map(|&amp;x| x * 10).collect::&lt;Vec&lt;i32&gt;&gt;();
    let b: Vec&lt;i32&gt; = v.iter().map(|&amp;x| x * 10).collect();
    println!("{a:?} {b:?}");
}</code></pre>
<h4 id="收集成-hashmap"><a class="header" href="#收集成-hashmap">收集成 HashMap</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![1, 2, 3];
    // collect 触发了迭代
    let doubled: Vec&lt;_&gt; = v.iter().map(|x| x * 2).collect();
    // 进阶：处理 Option。如果其中有一个 None，最终结果就是 None
    let maybe_numbers = vec![Some(1), Some(2), None];
    let result: Option&lt;Vec&lt;i32&gt;&gt; = maybe_numbers.into_iter().collect();
    println!("{:?}", result); // None
}</code></pre>
<h3 id="基础聚合sum-product-count"><a class="header" href="#基础聚合sum-product-count">基础聚合：<code>sum</code>, <code>product</code>, <code>count</code></a></h3>
<p>这些操作非常直观，用于数值计算或统计数量。</p>
<h4 id="count-返回元素个数usize"><a class="header" href="#count-返回元素个数usize">count() 返回元素个数（usize）</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let c = (1..=10).filter(|x| x % 2 == 0).count();
    println!("{c}"); // 5
}</code></pre>
<h4 id="sum--product--返回元素总和--乘积"><a class="header" href="#sum--product--返回元素总和--乘积">sum() / product() : 返回元素总和 / 乘积</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![1, 2, 3, 4];
    let s: i32 = v.iter().sum();
    let p: i32 = v.iter().product();
    println!("{s} {p}"); // 10 24
}</code></pre>
<h3 id="查找与匹配-find-position-any-all-nth"><a class="header" href="#查找与匹配-find-position-any-all-nth">查找与匹配: find, position, any, all, nth</a></h3>
<p><strong>核心优势</strong>：这些方法具有**短路（Short-circuiting）**特性。例如，<code>any</code> 只要找到一个满足条件的元素，就会立即停止迭代，不再处理后续数据。这对于性能优化至关重要。</p>
<ul>
<li><strong><code>any</code></strong>：只要有一个符合条件就返回 <code>true</code>。</li>
<li><strong><code>all</code></strong>：必须全部符合条件才返回 <code>true</code>。</li>
<li><strong><code>find</code></strong>：返回第一个符合条件的元素的引用（包裹在 <code>Option</code> 中）。</li>
<li><strong><code>position</code></strong>：返回第一个符合条件的元素的索引（<code>Option&lt;usize&gt;</code>）。</li>
</ul>
<h4 id="find-找到第一个满足条件的元素返回-optionitem"><a class="header" href="#find-找到第一个满足条件的元素返回-optionitem">find 找到第一个满足条件的元素（返回 <code>Option&lt;Item&gt;</code>）</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![10, 20, 30, 40];
    let f = v.iter().find(|&amp;&amp;x| x &gt;= 25);
    println!("{f:?}"); // Some(&amp;30)
}</code></pre>
<h4 id="position-找到第一个满足条件的索引返回-optionusize"><a class="header" href="#position-找到第一个满足条件的索引返回-optionusize">position 找到第一个满足条件的索引（返回 <code>Option&lt;usize&gt;</code>）</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![10, 20, 30, 40];
    let p = v.iter().position(|&amp;x| x == 30);
    println!("{p:?}"); // Some(2)
}</code></pre>
<h4 id="any--all"><a class="header" href="#any--all">any / all</a></h4>
<ul>
<li><strong><code>any</code></strong>：只要有一个符合条件就返回 <code>true</code>。</li>
<li><strong><code>all</code></strong>：必须全部符合条件才返回 <code>true</code>。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![2, 4, 6, 7];
    println!("{}", v.iter().any(|&amp;x| x % 2 == 1)); // true
    println!("{}", v.iter().all(|&amp;x| x % 2 == 0)); // false
}</code></pre>
<h4 id="nthk-取第-k-个元素但会消耗掉前-k-个不是随机访问"><a class="header" href="#nthk-取第-k-个元素但会消耗掉前-k-个不是随机访问">nth(k): 取第 k 个元素，但会消耗掉前 k 个（不是随机访问）</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut it = (10..=20);
    println!("{:?}", it.nth(3)); // Some(13) 消耗 10,11,12,13
    println!("{:?}", it.next()); // Some(14) 迭代器状态已经推进
}</code></pre>
<h3 id="折叠与归约fold-reduce-scan"><a class="header" href="#折叠与归约fold-reduce-scan">折叠与归约：fold, reduce, scan</a></h3>
<p>这三个是“最像算法”的消耗器/半消耗器。</p>
<h4 id="foldinit-f你提供初始值"><a class="header" href="#foldinit-f你提供初始值">fold(init, f)：你提供初始值</a></h4>
<ul>
<li>总是返回一个值（不会是 Option）</li>
<li>适合：累计、构建字符串、构建 map、统计等</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![1, 2, 3];
    let r = v.iter().fold(100, |acc, &amp;x| acc + x);
    println!("{r}"); // 106
}</code></pre>
<h5 id="典型fold-拼字符串"><a class="header" href="#典型fold-拼字符串">典型：fold 拼字符串</a></h5>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let words = vec!["hello", "rust", "iter"];
    let s = words.iter().fold(String::new(), |mut acc, &amp;w| {
        if !acc.is_empty() { acc.push(' '); }
        acc.push_str(w);
        acc
    });
    println!("{s}");
}</code></pre>
<h4 id="reducef用第一个元素当初始值返回-option"><a class="header" href="#reducef用第一个元素当初始值返回-option">reduce(f)：用第一个元素当初始值（返回 Option）</a></h4>
<ul>
<li>空迭代器会返回 None</li>
<li>适合：最大值、求和等“有自然单位元但不想写 init”的场景</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![1, 2, 3];
    let r = v.into_iter().reduce(|acc, x| acc + x);
    println!("{r:?}"); // Some(6)
}</code></pre>
<h4 id="scanstate-f它是适配器但非常像-fold"><a class="header" href="#scanstate-f它是适配器但非常像-fold">scan(state, f)：它是适配器（但非常像 fold）</a></h4>
<ul>
<li>scan 会产生一个新迭代器，把“中间状态”也作为输出</li>
<li>适合：前缀和、状态机、解析流</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![1, 2, 3, 4];
    // 前缀和：1,3,6,10
    let prefix: Vec&lt;i32&gt; = v.into_iter()
        .scan(0, |state, x| {
            *state += x;
            Some(*state)
        })
        .collect();
    println!("{prefix:?}");
}</code></pre>
<h3 id="极值处理maxminmax_bymin_by"><a class="header" href="#极值处理maxminmax_bymin_by">极值处理：<code>max</code>,<code>min</code>,<code>max_by</code>,<code>min_by</code></a></h3>
<p>返回迭代器中的最大值或最小值。注意它们返回的是 <code>Option</code>，因为迭代器可能没有元素。</p>
<ul>
<li>对于复杂结构，可以使用 <code>max_by</code> 或 <code>max_by_key</code>。</li>
</ul>
<h4 id="maxmin"><a class="header" href="#maxmin">max/min</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec![3, 10, 7];
    println!("{:?}", v.iter().max()); // Some(&amp;10)
    println!("{:?}", v.iter().min()); // Some(&amp;3)
}</code></pre>
<h4 id="自定义比较max_by--min_by"><a class="header" href="#自定义比较max_by--min_by">自定义比较：max_by / min_by</a></h4>
<p>比如按字符串长度找最长：</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v = vec!["aa", "bbbb", "ccc"];
    let best = v.iter().max_by(|a, b| a.len().cmp(&amp;b.len()));
    println!("{best:?}"); // Some("bbbb")
}</code></pre>
<h3 id="本节选择器我到底该用谁"><a class="header" href="#本节选择器我到底该用谁">本节“选择器”：我到底该用谁？</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>类别</th><th>名字</th><th>作用</th><th>返回/特点</th></tr>
</thead>
<tbody>
<tr><td>集合转换</td><td><code>collect</code></td><td>把迭代器收集成集合（<code>Vec/HashMap/HashSet/...</code>）</td><td>返回目标集合类型；常需标注 <code>collect::&lt;Vec&lt;_&gt;&gt;()</code></td></tr>
<tr><td>基础聚合</td><td><code>count</code></td><td>统计元素个数</td><td><code>usize</code></td></tr>
<tr><td>基础聚合</td><td><code>sum</code></td><td>求和</td><td>返回数值类型（需要可推断）</td></tr>
<tr><td>基础聚合</td><td><code>product</code></td><td>连乘</td><td>返回数值类型（需要可推断）</td></tr>
<tr><td>折叠/归约</td><td><code>fold</code></td><td>自定义累计（你提供初始值）</td><td>返回累计结果（不会是 <code>Option</code>）</td></tr>
<tr><td>折叠/归约</td><td><code>reduce</code></td><td>用第一个元素做初始值的归约</td><td><code>Option&lt;Item&gt;</code>，空迭代器为 <code>None</code></td></tr>
<tr><td>折叠/归约</td><td><code>scan</code></td><td>带状态地产生“中间结果序列”（前缀和/状态机）</td><td><strong>注意：它是适配器</strong>，返回新迭代器；通常再 <code>collect()</code></td></tr>
<tr><td>查找/匹配</td><td><code>find</code></td><td>找到第一个满足条件的元素</td><td><code>Option&lt;Item&gt;</code>（借用迭代器通常是 <code>Option&lt;&amp;T&gt;</code>）</td></tr>
<tr><td>查找/匹配</td><td><code>position</code></td><td>找到第一个满足条件的索引</td><td><code>Option&lt;usize&gt;</code></td></tr>
<tr><td>查找/匹配</td><td><code>any</code></td><td>是否存在任意元素满足条件（短路）</td><td><code>bool</code></td></tr>
<tr><td>查找/匹配</td><td><code>all</code></td><td>是否所有元素都满足条件（短路）</td><td><code>bool</code></td></tr>
<tr><td>查找/匹配</td><td><code>nth</code></td><td>取第 <code>n</code> 个元素（从 0 开始）</td><td><code>Option&lt;Item&gt;</code>；会消耗掉前 <code>n</code> 个</td></tr>
<tr><td>极值处理</td><td><code>max</code></td><td>取最大元素</td><td><code>Option&lt;Item&gt;</code>（借用迭代器常为 <code>Option&lt;&amp;T&gt;</code>）</td></tr>
<tr><td>极值处理</td><td><code>min</code></td><td>取最小元素</td><td><code>Option&lt;Item&gt;</code></td></tr>
<tr><td>极值处理</td><td><code>max_by</code></td><td>自定义比较规则取最大</td><td><code>Option&lt;Item&gt;</code>，比较由闭包决定</td></tr>
<tr><td>极值处理</td><td><code>min_by</code></td><td>自定义比较规则取最小</td><td><code>Option&lt;Item&gt;</code>，比较由闭包决定</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="六自定义迭代器"><a class="header" href="#六自定义迭代器">六、自定义迭代器</a></h2>
<p><strong>核心逻辑</strong>：在 Rust 中，要让一个结构体变成迭代器，你不需要继承任何复杂的类，只需要实现 <code>Iterator</code> 这个 Trait。你唯一需要做的，就是告诉编译器<strong>如何产出下一个元素</strong>（<code>next</code> 方法）以及<strong>产出什么</strong>（<code>Item</code> 类型）。</p>
<h3 id="1-实现-iterator-trait-的两要素"><a class="header" href="#1-实现-iterator-trait-的两要素">1. 实现 <code>Iterator</code> Trait 的两要素</a></h3>
<p>要实现自定义迭代器，你的结构体必须具备两点：</p>
<ol>
<li><strong>状态维护</strong>：结构体里需要有字段记录当前迭代到了哪里。</li>
<li><strong><code>next</code> 方法</strong>：每次调用时更新状态，并返回 <code>Some(value)</code> 或 <code>None</code>。</li>
</ol>
<h4 id="斐波那契数列迭代器"><a class="header" href="#斐波那契数列迭代器">斐波那契数列迭代器</a></h4>
<p>斐波那契数列是一个完美的自定义迭代器例子，因为它具有清晰的内部状态转移。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct Fibonacci {
    curr: u32,
    next: u32,
}
impl Fibonacci {
    fn new() -&gt; Fibonacci {
        Fibonacci { curr: 0, next: 1 }
    }
}
// 为 Fibonacci 实现 Iterator
impl Iterator for Fibonacci {
    type Item = u32; // 产出 u32 类型
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let current = self.curr;
        // 计算下一项并更新状态
        self.curr = self.next;
        self.next = current + self.next;
        // 斐波那契数列通常是无限的，但在 Rust 中我们需要设置一个边界
        // 这里假设超过 1000 就停止
        if current &gt; 1000 {
            None
        } else {
            Some(current)
        }
    }
}
fn main() {
    let fib = Fibonacci::new();
    // 一旦实现了 Iterator，你就可以使用 map, filter 等所有适配器！
    for num in fib.take(10) {
        println!("{}", num);
    }
}</code></pre>
<h3 id="2-为集合实现-intoiterator"><a class="header" href="#2-为集合实现-intoiterator">2. 为集合实现 <code>IntoIterator</code></a></h3>
<p>如果你创建了一个自定义集合（比如 <code>MyList</code>），你可能希望直接写 <code>for x in my_list</code>。这时你需要实现 <code>IntoIterator</code>。</p>
<p><strong>核心逻辑</strong>：<code>IntoIterator</code> 的作用是定义“如何从你的集合产生一个迭代器”。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct MyCollection {
    items: Vec&lt;i32&gt;,
}
impl IntoIterator for MyCollection {
    type Item = i32;
    type IntoIter = std::vec::IntoIter&lt;i32&gt;; // 直接复用 Vec 的迭代器类型
    fn into_iter(self) -&gt; Self::IntoIter {
        self.items.into_iter()
    }
}
fn main() {
    let coll = MyCollection { items: vec![1, 2, 3] };
    // 现在可以直接在 for 循环中使用
    for x in coll {
        println!("{}", x);
    }
}</code></pre>
<h3 id="3-自定义迭代器的优势节省内存"><a class="header" href="#3-自定义迭代器的优势节省内存">3. 自定义迭代器的优势：节省内存</a></h3>
<p>自定义迭代器最大的魅力在于：<strong>它是按需生成的。</strong></p>
<p>想象一下你需要处理 100 万个数据，如果你先把它们全部存在 <code>Vec</code> 里，会占用大量内存。但如果你写一个自定义迭代器，它只需要记录“当前在哪”，内存占用几乎为零，无论你要处理多少数据。</p>
<h4 id="-进阶带状态的过滤迭代器"><a class="header" href="#-进阶带状态的过滤迭代器">🛠️ 进阶：带状态的过滤迭代器</a></h4>
<p>你可以创建一个包装另一个迭代器的自定义迭代器。</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SkipNone&lt;I&gt; {
    inner: I,
}
impl&lt;I, T&gt; Iterator for SkipNone&lt;I&gt;
where
    I: Iterator&lt;Item = Option&lt;T&gt;&gt;, // 要求内部迭代器产出 Option
{
    type Item = T;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // 循环调用内部迭代器，直到找到一个 Some 或者结束
        while let Some(opt) = self.inner.next() {
            if let Some(val) = opt {
                return Some(val);
            }
        }
        None
    }
}
<span class="boring">}</span></code></pre>
<h3 id="核心总结自定义三部曲"><a class="header" href="#核心总结自定义三部曲">核心总结：自定义三部曲</a></h3>
<ol>
<li><strong>定义结构体</strong>：确定你需要哪些字段来记住迭代进度（比如索引、当前数值等）。</li>
<li><strong>声明 <code>Item</code> 类型</strong>：告诉 Rust 迭代器产出什么（引用 <code>&amp;T</code> 还是值 <code>T</code>）。</li>
<li><strong>编写 <code>next</code> 逻辑</strong></li>
</ol>
<ul>
<li>如果有数据：更新状态，返回 <code>Some(value)</code>。</li>
<li>如果没数据：返回 <code>None</code>。</li>
</ul>
<hr>
<h2 id="七-高级与特殊迭代器"><a class="header" href="#七-高级与特殊迭代器">七、 高级与特殊迭代器</a></h2>
<ul>
<li>DoubleEndedIterator：双端迭代器，支持从后往前迭代（rev()）</li>
<li>ExactSizeIterator：已知精确长度的迭代器（len()）</li>
<li>FusedIterator：融合迭代器，保证 None 之后永远返回 None</li>
<li>Peekable：支持“预览”下一个元素而不消耗它</li>
</ul>
<hr>
<h2 id="八-性能与底层原理"><a class="header" href="#八-性能与底层原理">八、 性能与底层原理</a></h2>
<ul>
<li>迭代器的内部迭代 vs 外部迭代</li>
<li>编译器优化：循环展开（Loop Unrolling）与内联</li>
<li>迭代器在内存安全上的保障：避免索引越界</li>
<li>itertools 库：了解社区标准扩展包</li>
</ul>
<hr>
<h2 id="九-迭代器与生命周期的交集"><a class="header" href="#九-迭代器与生命周期的交集">九、 迭代器与生命周期的交集</a></h2>
<ul>
<li>迭代器产生的引用寿命约束</li>
<li>在结构体中存储迭代器（涉及生命周期参数）</li>
<li>闭包捕获环境对迭代器生命周期的影响</li>
</ul>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="宏"><a class="header" href="#宏">宏</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="unsafe-code"><a class="header" href="#unsafe-code">UnSafe Code</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="项目组织及依赖管理"><a class="header" href="#项目组织及依赖管理">项目组织及依赖管理</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="项目结构"><a class="header" href="#项目结构">项目结构</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cargotoml"><a class="header" href="#cargotoml">Cargo.Toml</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="文档"><a class="header" href="#文档">文档</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cargo"><a class="header" href="#cargo">Cargo</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cargo-命令"><a class="header" href="#cargo-命令">Cargo 命令</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cargo-工具链"><a class="header" href="#cargo-工具链">Cargo 工具链</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="三方库"><a class="header" href="#三方库">三方库</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="serde"><a class="header" href="#serde">serde</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="seaorm"><a class="header" href="#seaorm">SeaORM</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="介绍-1"><a class="header" href="#介绍-1">介绍</a></h1>
<h2 id="了解-seaorm-的核心工作流"><a class="header" href="#了解-seaorm-的核心工作流">了解 SeaORM 的核心工作流</a></h2>
<h3 id="请记住这三个核心角色之间的转换关系"><a class="header" href="#请记住这三个核心角色之间的转换关系">请记住这三个核心角色之间的转换关系</a></h3>
<ul>
<li>Entity (实体): 对应数据库里的“表”。它定义了结构、关联关系和主键。</li>
<li>Model (模型): 这是一个纯粹的 Rust 结构体，代表了数据库中的一行数据。它是只读的，通常用于查询结果。</li>
<li>ActiveModel (活跃模型): 这是用于修改数据的结构体。当你需要 INSERT 或 UPDATE 时，你会把 Model 转换为ActiveModel，设置好字段后再存入数据库。</li>
</ul>
<h3 id="seaorm-的核心逻辑"><a class="header" href="#seaorm-的核心逻辑">SeaORM 的核心逻辑</a></h3>
<h4 id="1-读写分离model-vs-activemodel"><a class="header" href="#1-读写分离model-vs-activemodel">1. 读写分离（Model vs ActiveModel）</a></h4>
<p>SeaORM 把“数据”分成了两种状态，这是它最特别的地方：</p>
<p>*<strong>Model (只读卡片)：</strong> 你从数据库里查出来的数据。它就像一张 <strong>照片</strong> ，你可以看，但不能直接在上面改。</p>
<p>*<strong>ActiveModel (可写表单)：</strong> 当你要新增或改动数据时，必须把照片变成“表单”。它会记录哪个字段改了，哪个没改，最后再保存回数据库。</p>
<h4 id="2-entity-是地图"><a class="header" href="#2-entity-是地图">2. Entity 是“地图”</a></h4>
<p>*<strong>Entity</strong> 就是数据库表的 <strong>定义（Schema）</strong> 。</p>
<ul>
<li>它告诉程序：表名是什么、有哪些列、主键是谁、表与表之间怎么关联。</li>
</ul>
<h4 id="3-连接要亲手传递"><a class="header" href="#3-连接要亲手传递">3. 连接要“亲手传递”</a></h4>
<ul>
<li>SeaORM  <strong>没有全局变量</strong> （不像某些框架可以直接调用 <code>DB::save()</code>）。</li>
<li>你必须自己拿着“数据库连接对象”（<code>DatabaseConnection</code>），把它传给需要操作数据库的函数。这样做虽然麻烦一点点，但代码更安全、更易于测试。</li>
</ul>
<hr>
<p><strong>总结成一句话：</strong></p>
<blockquote>
<p><strong>Entity</strong> 定义表，<strong>Model</strong> 用来读，<strong>ActiveModel</strong> 用来写，<strong>Connection</strong> 手动传。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="安装与配置"><a class="header" href="#安装与配置">安装与配置</a></h1>
<p><strong>PostgreSQL + SeaORM</strong> 的标准化安装与配置流程。按照这个顺序操作，你可以快速搭建起开发环境。</p>
<hr>
<h2 id="第一步配置-cargotoml-依赖安装首先在你的-rust-项目中引入-seaorm既然你使用-postgresql请务必开启-sqlx-postgres-驱动"><a class="header" href="#第一步配置-cargotoml-依赖安装首先在你的-rust-项目中引入-seaorm既然你使用-postgresql请务必开启-sqlx-postgres-驱动">第一步：配置 <code>Cargo.toml</code> (依赖安装)首先，在你的 Rust 项目中引入 SeaORM。既然你使用 <strong>PostgreSQL</strong>，请务必开启 <code>sqlx-postgres</code> 驱动</a></h2>
<pre><code class="language-toml">[dependencies]
# SeaORM 核心配置
sea-orm = { version = "1.1.0", features = [ 
    "sqlx-postgres",          # 必选：PostgreSQL 驱动
    "runtime-tokio-rustls",   # 必选：异步运行时
    "macros",                 # 必选：用于自动生成代码
    "debug-print",            # 建议：开发时查看 SQL 日志
    "with-chrono",            # 建议：处理数据库的时间类型
] }
# 日志捕获（用于配合 debug-print）
tracing = "0.1"
tracing-subscriber = "0.3"
# 异步库
tokio = { version = "1.0", features = ["full"] }
</code></pre>
<h3 id="extra-features"><a class="header" href="#extra-features">Extra features</a></h3>
<ul>
<li>
<p><strong>debug-print</strong> - 将每个 SQL 语句打印到记录器</p>
</li>
<li>
<p><strong>mock</strong> - 用于单元测试的模拟接口</p>
</li>
<li>
<p><strong>macros</strong> - 过程宏，例如 DeriveEntityModel</p>
</li>
<li>
<p><strong>rbac</strong> - 基于角色的访问控制</p>
</li>
<li>
<p><strong>seaography</strong> - 启用 GraphQL 支持</p>
</li>
<li>
<p><strong>schema-sync</strong> - 启用 SchemaBuilder 中的同步功能</p>
</li>
<li>
<p><strong>with-chrono</strong> - 支持 chrono 类型</p>
</li>
<li>
<p><strong>with-time</strong> - 支持 time 类型</p>
</li>
<li>
<p><strong>with-json</strong> - 支持 serde-json 类型</p>
</li>
<li>
<p><strong>with-rust_decimal</strong> - 支持 rust_decimal 类型</p>
</li>
<li>
<p><strong>with-bigdecimal</strong> - 支持 bigdecimal 类型</p>
</li>
<li>
<p><strong>with-uuid</strong> - 支持 uuid 类型</p>
</li>
<li>
<p><strong>with-ipnetwork</strong> - 支持 Postgres ipnetwork</p>
</li>
<li>
<p><strong>postgres-vector</strong> - 支持 Postgres pgvector</p>
</li>
<li>
<p><strong>postgres-array</strong> - 支持 Postgres 数组类型，默认开启</p>
</li>
<li>
<p><strong>sqlite-use-returning-for-3_35</strong> - 为 SQLite 3.35+ 版本使用 RETURNING 语句，默认开启</p>
</li>
<li>
<p><strong>mariadb-use-returning</strong> - 为 MariaDB 使用 RETURNING 语句，默认开启</p>
</li>
</ul>
<hr>
<h2 id="第二步配置连接选项-database-connection"><a class="header" href="#第二步配置连接选项-database-connection">第二步：配置连接选项 (Database Connection)</a></h2>
<p>在代码中通过 <code>ConnectOptions</code> 建立与 PostgreSQL 的连接。你可以设置连接池的大小和超时时间。
<strong>用法说明：</strong></p>
<pre><code class="language-rust ignore">usesea_orm::{ConnectOptions, Database, DatabaseConnection};
usestd::time::Duration;
pubasyncfnsetup_db() -&gt;Result&lt;DatabaseConnection, sea_orm::DbErr&gt; {
    // PostgreSQL 连接字符串格式
    letdb_url="postgres://username:password@localhost:5432/database_name";
    letmutopt=ConnectOptions::new(db_url);
    opt.max_connections(20)           // 最大连接数
       .min_connections(5)            // 最小连接数
       .connect_timeout(Duration::from_secs(8)) // 连接超时
       .sqlx_logging(false);          // 关闭 SQLx 原生日志，改用 SeaORM 的 debug-print
    // 返回连接对象 (DatabaseConnection)
    Database::connect(opt).await
}</code></pre>
<hr>
<h2 id="第三步开启调试日志-logging"><a class="header" href="#第三步开启调试日志-logging">第三步：开启调试日志 (Logging)</a></h2>
<p>为了在控制台看到 SeaORM 生成的 SQL 语句，你需要在 <code>main</code> 函数开头初始化日志订阅者。</p>
<p><strong>用法说明：</strong></p>
<pre class="playground"><code class="language-rust edition2024">#[tokio::main]
async fn main() {
    // 初始化日志系统，这样才能看到 debug-print 输出的 SQL
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::DEBUG)
        .init();
    letdb=setup_db().await.expect("数据库连接失败");
    // ... 开始你的业务逻辑
}</code></pre>
<hr>
<h2 id="第四步理解操作逻辑-crud-模式"><a class="header" href="#第四步理解操作逻辑-crud-模式">第四步：理解操作逻辑 (CRUD 模式)</a></h2>
<p>配置完成后，你在编写业务逻辑时只需记住这套“三位一体”的操作流：</p>
<p>1.<strong>定义阶段 (Entity)</strong>：写一个结构体代表 PostgreSQL 的表。</p>
<p>2.<strong>读取阶段 (Model)</strong>：使用 <code>Entity::find()</code> 查询，结果存入 <code>Model</code>（只读）。</p>
<p>3.<strong>写入阶段 (ActiveModel)</strong>：</p>
<ul>
<li>要把 <code>Model</code> 转成 <code>ActiveModel</code> 才能修改。</li>
<li>直接创建 <code>ActiveModel</code> 用于插入新数据。</li>
</ul>
<p>4.<strong>手动传递连接</strong>：把第二步生成的 <code>db</code> (DatabaseConnection) 对象传给查询函数。</p>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="迁移系统"><a class="header" href="#迁移系统">迁移系统</a></h1>
<p>迁移系统（<code>Migration</code>）简单来说就是数据库的版本控制工具。就像 <code>Git</code> 记录代码改动一样，<code>Migration</code> 记录数据库表结构的改动（新建表、加字段、删索引等）。</p>
<hr>
<h2 id="1-完整的工作区-workspace-结构"><a class="header" href="#1-完整的工作区-workspace-结构">1. 完整的工作区 (Workspace) 结构</a></h2>
<p>在 Rust 中，SeaORM 官方强烈建议使用 <strong>Workspace</strong> 模式。这能让你的“业务代码”和“数据库迁移代码”彻底解耦。</p>
<p>推荐的目录树如下：</p>
<pre><code class="language-text">my_project/
├── Cargo.toml          # 根目录虚拟清单
├── src/                # 你的业务逻辑 (App Crate)
│   └── main.rs
└── migration/          # 迁移逻辑 (Migration Crate)
    ├── Cargo.toml
    └── src/
        ├── lib.rs      # 定义迁移器
        ├── main.rs     # CLI 入口
        └── m20240110_000001_create_user_table.rs  # 具体的表变动记录
</code></pre>
<hr>
<h2 id="2-第一步初始化与配置"><a class="header" href="#2-第一步初始化与配置">2. 第一步：初始化与配置</a></h2>
<p>首先，安装工具并创建迁移目录。</p>
<h3 id="安装-cli"><a class="header" href="#安装-cli">安装 CLI</a></h3>
<pre><code class="language-bash">cargo install sea-orm-cli
</code></pre>
<h3 id="初始化"><a class="header" href="#初始化">初始化</a></h3>
<p>在你的项目根目录下运行：</p>
<pre><code class="language-bash">sea-orm-cli migrate init
</code></pre>
<h3 id="配置-migrationcargotoml"><a class="header" href="#配置-migrationcargotoml">配置 <code>migration/Cargo.toml</code></a></h3>
<p>这是最容易出错的地方。你需要为迁移脚本开启 <strong>PostgreSQL</strong> 支持：</p>
<pre><code class="language-toml">[dependencies.sea-orm-migration]
version = "1.1.0" 
features = [
  "runtime-tokio-rustls", # 异步运行时
  "sqlx-postgres",        # 明确指定使用 Postgres
]
</code></pre>
<hr>
<h2 id="3-第二步编写迁移逻辑-核心细节"><a class="header" href="#3-第二步编写迁移逻辑-核心细节">3. 第二步：编写迁移逻辑 (核心细节)</a></h2>
<p>迁移文件（如 <code>m..._create_table.rs</code>）是纯 Rust 代码。SeaORM 使用 <strong>SeaQuery</strong>（一种 DSL）来描述 SQL。</p>
<h3 id="up-函数创建表"><a class="header" href="#up-函数创建表"><code>up</code> 函数：创建表</a></h3>
<p>假设我们要创建一个用户表：</p>
<pre><code class="language-rust ignore">use sea_orm_migration::prelude::*;

//SeaORM 需要给每个迁移任务起个名字（存到 PostgreSQL 的 seaql_migrations 表里）。这个宏会自动把你的文件名（比如 m20240110_...）提取出来作为名字，省得你手动写。
#[derive(DeriveMigrationName)]
pub struct Migration;

// 实现 MigrationTrait 来定义具体的迁移逻辑
#[async_trait]
impl MigrationTrait for Migration {
    async fn up(&amp;self, manager: &amp;SchemaManager) -&gt; Result&lt;(), DbErr&gt; {
        // 使用 manager 创建表
        manager
            .create_table(
                Table::create()
                    .table(User::Table) // 表名
                    .if_not_exists()    // 防御性编程
                    .col(
                        ColumnDef::new(User::Id)
                            .integer()
                            .not_null()
                            .auto_increment()
                            .primary_key(),
                    )
                    .col(ColumnDef::new(User::Username).string().not_null().unique_key())
                    .col(ColumnDef::new(User::CreatedAt).date_time().default(Expr::current_timestamp()))
                    .to_owned(),
            )
            .await
    }

    async fn down(&amp;self, manager: &amp;SchemaManager) -&gt; Result&lt;(), DbErr&gt; {
        // 回滚操作：删除表
        manager
            .drop_table(Table::drop().table(User::Table).to_owned())
            .await
    }
}

// 定义表和列的枚举，方便在 Rust 里引用. 在 SQL 里我们需要写 user（表名）、id（列名）,如果不加这个，你得手写字符串 "user", "id"。加了它，你就可以写 User::Table 或 User::Id。如果有拼写错误，编译器会直接报错，这非常安全。
#[derive(DeriveIden)]
enum User {
    Table,
    Id,
    Username,
    CreatedAt,
}</code></pre>
<p>在数据库迁移（Migration）中，<code>up</code> 和 <code>down</code> 就像是版本控制里的 <strong>“前进”</strong> 和 <strong>“后退”</strong>。你可以把它们想象成一对“反义词”操作：<code>up</code> 负责<strong>建立</strong>，<code>down</code> 负责<strong>拆除</strong>。</p>
<h4 id="1-fn-up"><a class="header" href="#1-fn-up">1. <code>fn up</code></a></h4>
<p>当你运行 <code>sea-orm-cli migrate up</code> 时，执行的就是这个函数。</p>
<ul>
<li><strong>目的</strong>：改变数据库的结构，让它变成你想要的新样子。</li>
<li><strong>常见操作</strong>：
<ul>
<li>创建新表（<code>create_table</code>）。</li>
<li>给现有的表增加新列（<code>alter_table</code>）。</li>
<li>创建索引或外键。</li>
</ul>
</li>
</ul>
<h4 id="2-fn-down"><a class="header" href="#2-fn-down">2. <code>fn down</code></a></h4>
<p>当你发现这次改动有问题，或者想回到上一个数据库版本，运行 <code>sea-orm-cli migrate down</code>，执行的就是这个函数。</p>
<ul>
<li><strong>目的</strong>：把 <code>up</code> 函数做过的事情<strong>原样撤销</strong>，让数据库回到没改之前的状态。</li>
<li><strong>常见操作</strong>：
<ul>
<li>如果 <code>up</code> 是创建表，<code>down</code> 就是删除表（<code>drop_table</code>）。</li>
<li>如果 <code>up</code> 是加了一列，<code>down</code> 就是删掉那一列。</li>
</ul>
</li>
<li><strong>重要性</strong>：<strong>对称性</strong>。为了保证数据库的整洁，<code>down</code> 逻辑必须写得准确。如果 <code>up</code> 建了表但 <code>down</code> 没写删表，数据库就会留下“垃圾”。</li>
</ul>
<h4 id="3-它们是如何工作的"><a class="header" href="#3-它们是如何工作的">3. 它们是如何工作的？</a></h4>
<p>SeaORM 会在你的 <strong>PostgreSQL</strong> 数据库里自动维护一张表，叫 <code>seaql_migrations</code>。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>版本号 (Version)</th><th>应用时间 (Applied At)</th></tr>
</thead>
<tbody>
<tr><td>m20220101_000001</td><td>2024-05-20 …</td></tr>
</tbody>
</table>
</div>
<ul>
<li>**当你执行 <code>up**</code>：SeaORM 运行 <code>up</code> 函数。如果成功，就把这个文件名（版本号）记入这张表。<strong>下次再跑 <code>up</code> 时，发现表里已经有了，它就会跳过，不会重复执行。</strong></li>
<li>**当你执行 <code>down**</code>：SeaORM 查找表里最后一条记录，找到对应的文件，执行它的 <code>down</code> 函数。如果成功，就从表里删掉这条记录。</li>
</ul>
<h4 id="4-深入代码细节"><a class="header" href="#4-深入代码细节">4. 深入代码细节</a></h4>
<p>让我们看看你刚才提供的代码块里，这两个函数具体在干什么：</p>
<pre><code class="language-rust ignore">// --- UP: 增加功能 ---
async fn up(&amp;self, manager: &amp;SchemaManager) -&gt; Result&lt;(), DbErr&gt; {
    manager
        .create_table(               // 动作：创建表
            Table::create()          // 建造者模式开始
                .table(User::Table)  // 表名：user
                .col(...)            // 具体的列定义
                .to_owned()
        )
        .await
}

// --- DOWN: 撤销功能 ---
async fn down(&amp;self, manager: &amp;SchemaManager) -&gt; Result&lt;(), DbErr&gt; {
    manager
        .drop_table(                 // 动作：删除表（撤销 up 的创建）
            Table::drop()
                .table(User::Table)  // 指定要删哪张表
                .to_owned()
        )
        .await
}</code></pre>
<hr>
<h2 id="4-第三步如何执行迁移"><a class="header" href="#4-第三步如何执行迁移">4. 第三步：如何执行迁移</a></h2>
<p>你有两个选择：<strong>命令行</strong>或<strong>代码内运行</strong>。</p>
<h3 id="a-命令行方式-手动"><a class="header" href="#a-命令行方式-手动">A. 命令行方式 (手动)</a></h3>
<p>你需要设置环境变量来告诉 CLI 你的 PostgreSQL 连接串：</p>
<pre><code class="language-bash"># 设置环境变量 (Linux/macOS)
export DATABASE_URL="postgres://user:pass@localhost:5432/my_db"
# 查看当前迁移状态
sea-orm-cli migrate status
# 执行所有待处理的迁移
sea-orm-cli migrate up
# 撤销最后一次迁移
sea-orm-cli migrate down
</code></pre>
<h3 id="b-代码方式-自动化"><a class="header" href="#b-代码方式-自动化">B. 代码方式 (自动化)</a></h3>
<p>在 <code>src/main.rs</code> 中，连接数据库后立即执行迁移。这样每次你部署新代码，数据库都会自动更新。</p>
<pre><code class="language-rust ignore">use migration::{Migrator, MigratorTrait}; // 引入你的 migration crate
#[tokio::main]
async fn main() {
    let db = sea_orm::Database::connect("postgres://...").await.unwrap();
    // 这一行会自动运行所有未执行的 .rs 迁移文件
    Migrator::up(&amp;db, None).await.expect("迁移失败");
    println!("数据库已就绪");
}</code></pre>
<hr>
<h2 id="5-迁移系统的生命周期-关键点"><a class="header" href="#5-迁移系统的生命周期-关键点">5. 迁移系统的生命周期 (关键点)</a></h2>
<p>为了防止弄乱 PostgreSQL，请务必理解这三个概念：</p>
<ol>
<li><strong><code>seaql_migrations</code> 表</strong>：SeaORM 会自动在你的数据库里建这张表。它记录了哪些 <code>.rs</code> 文件已经跑过了。不要手动删它。</li>
<li><strong>不可变性</strong>：一旦某个迁移文件已经 <code>up</code> 到了生产环境，<strong>不要修改它</strong>。如果你想加字段，应该建一个<strong>新</strong>的迁移文件。</li>
<li><strong>Iden 宏</strong>：代码最后的 <code>enum User { Table, Id... }</code> 是为了避免在代码里写硬编码字符串（如 <code>"username"</code>），增加类型安全性。</li>
</ol>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="编写迁移"><a class="header" href="#编写迁移">编写迁移</a></h1>
<h2 id="1-迁移系统的核心配置migratortrait"><a class="header" href="#1-迁移系统的核心配置migratortrait">1. 迁移系统的核心配置：<code>MigratorTrait</code></a></h2>
<p>迁移文件写好后，如果不进行 <strong>注册</strong> ，系统是找不到它们的。这是通过 <code>migration/src/lib.rs</code> 实现的。</p>
<ul>
<li><strong><code>Migrator</code> 结构体</strong> ：它是整个迁移的控制塔。</li>
<li><strong><code>migrations</code> 函数</strong> ：
<ul>
<li>它返回一个 <code>Vec&lt;Box&lt;dyn MigrationTrait&gt;&gt;</code>。</li>
<li><strong>重要细节</strong> ：必须手动将每一个迁移文件（如 <code>m20220101_...::Migration</code>）用 <code>Box::new()</code> 包裹并放入数组。</li>
<li><strong>顺序要求</strong> ：数组内的顺序必须是 <strong>时间顺序</strong> 。SeaORM 依赖这个顺序来依次执行。</li>
</ul>
</li>
</ul>
<pre><code class="language-rust ignore">// migration/src/lib.rs 完整还原
pub struct Migrator;

#[async_trait]
impl MigratorTrait for Migrator {
    fn migrations() -&gt; Vec&lt;Box&lt;dyn MigrationTrait&gt;&gt; {
        vec![
            Box::new(m20220101_000001_create_table::Migration),
            // 每一个新生成的迁移文件，都要手动在这里“挂号”
        ]
    }
}</code></pre>
<hr>
<h2 id="2-深入-schemamanager"><a class="header" href="#2-深入-schemamanager">2. 深入 <code>SchemaManager</code></a></h2>
<p>你在 <code>up</code> 和 <code>down</code> 函数中使用的 <code>manager</code> 对象提供了极丰富的 API。</p>
<h3 id="a-结构创建-creation"><a class="header" href="#a-结构创建-creation">A. 结构创建 (Creation)</a></h3>
<pre><code class="language-rust ignore">use sea_orm_migration::{prelude::*, schema::*};
manager
    .create_table(
        Table::create()
            .table("post")
            .if_not_exists()
            .col(pk_auto("id"))
            .col(string("title"))
            .col(string("text"))
            .col(enumeration_null("category", "category", ["Feed", "Store"]))
    )
    .await</code></pre>
<p>除了 <code>create_table</code>，还有这些你可能忽略的细节：</p>
<ul>
<li><strong><code>create_index</code></strong> ：创建索引,eg: <code>manager.create_index(sea_query::Index::create()..)</code>。</li>
<li><strong><code>create_foreign_key</code></strong> ：创建外键约束, eg: <code>manager.create_foreign_key(sea_query::ForeignKey::create()..)</code>。</li>
<li><strong><code>create_type</code> (PostgreSQL 专有)</strong> ：</li>
</ul>
<pre><code class="language-rust ignore">  use sea_orm_migration::prelude::extension::postgres::Type;
manager
    .create_type(
        Type::create()
            .as_enum(CategoryEnum)
            .values(["feed", "story"])
            .to_owned()
    )
    .await?;</code></pre>
<h3 id="b-结构变更与删除"><a class="header" href="#b-结构变更与删除">B. 结构变更与删除</a></h3>
<ul>
<li><strong><code>drop_table</code></strong> ：删除表,eg: <code>manager.drop_table(sea_query::Table::drop()..)</code></li>
<li><strong><code>alter_table</code></strong> ：修改表结构（加字段、改类型）eg: <code>manager.alter_table(sea_query::Table::alter()..)</code></li>
<li><strong><code>rename_table</code></strong> ：重命名。eg: <code>manager.rename_table(sea_query::Table::rename()..)</code></li>
<li><strong><code>truncate_table</code></strong> ：清空表数据但保留结构。eg: <code>manager.truncate_table(sea_query::Table::truncate()..)</code></li>
<li><strong><code>drop_index</code> / <code>drop_foreign_key</code></strong> ：删除索引或外键,eg: <code>manager.drop_index(sea_query::Index::drop()..)</code>;<code>manager.drop_foreign_key(sea_query::ForeignKey::drop()..)</code></li>
<li><strong><code>truncate_table</code></strong> ：截断表数据,eg: <code>manager.truncate_table(sea_query::Table::truncate()..)</code></li>
<li><strong><code>alter_type</code></strong> ：修改数据类型（仅限 PostgreSQL）,eg: <code>manager.alter_type(sea_query::Type::alter()..)</code></li>
<li><strong><code>drop_type</code></strong> ：删除数据类型（仅限 PostgreSQL）,eg: <code>manager.drop_type(sea_query::extension::postgres::Type::drop()..)</code></li>
</ul>
<h3 id="c-结构检查"><a class="header" href="#c-结构检查">C. 结构检查</a></h3>
<p>在执行高风险操作前，可以使用检查方法防止报错：</p>
<ul>
<li><strong><code>has_table("name")</code></strong> ：是否存在某表,eg: <code>manager.has_table("table_name").await?</code>。</li>
<li><strong><code>has_column("table", "col")</code></strong> ：是否存在某列,eg: <code>manager.has_column("table_name", "column_name")</code>。</li>
<li><strong><code>has_index("table", "idx")</code></strong> ：是否存在某索引,eg: <code>manager.has_index("table_name", "index_name")</code>。</li>
</ul>
<hr>
<h2 id="3-原始-sql-的两种执行方式"><a class="header" href="#3-原始-sql-的两种执行方式">3. 原始 SQL 的两种执行方式</a></h2>
<p>虽然 SeaQuery 很好，但有时候你必须写原始 SQL。文档提到了两种方法，区别非常大：</p>
<ol>
<li>
<p><strong><code>execute_unprepared(sql)</code></strong> ：</p>
<ul>
<li>用于<strong>不带参数</strong>的纯 SQL（如 <code>CREATE TABLE</code>）。</li>
<li>它是最直接的字符串执行。</li>
</ul>
<pre><code class="language-rust ignore">// Use `execute_unprepared` if the SQL statement doesn't have value bindings
db.execute_unprepared(
    "CREATE TABLE `cake` (
        `id` int NOT NULL AUTO_INCREMENT PRIMARY KEY,
        `name` varchar(255) NOT NULL
    )"
)
.await?;</code></pre>
</li>
<li>
<p><strong><code>execute_raw(Statement)</code></strong> ：</p>
</li>
</ol>
<ul>
<li>用于<strong>带参数绑定</strong>的 SQL（如 <code>INSERT INTO table (name) VALUES (?)</code>）。</li>
<li><strong>原理</strong> ：它通过 <code>Statement::from_sql_and_values</code> 构建，能有效防御 SQL 注入。</li>
</ul>
<pre><code class="language-rust ignore">// Construct a `Statement` if the SQL contains value bindings
db.execute_raw(Statement::from_sql_and_values(
    manager.get_database_backend(),
    r#"INSERT INTO `cake` (`name`) VALUES (?)"#,
    ["Cheese Cake".into()]
)).await?;</code></pre>
<hr>
<h2 id="4-高级技巧与最佳实践-tips"><a class="header" href="#4-高级技巧与最佳实践-tips">4. 高级技巧与最佳实践 (Tips)</a></h2>
<h3 id="tip-1多原子操作组合"><a class="header" href="#tip-1多原子操作组合">Tip 1：多原子操作组合</a></h3>
<p>你可以在一个 <code>up</code> 函数里写多个操作。<strong>注意：</strong> 因为你用的是  <strong>PostgreSQL</strong> ，这些操作会自动被包裹在一个 <strong>Transaction（事务）</strong> 中。如果第 3 个操作失败了，前 2 个会自动回滚。</p>
<h3 id="tip-2手动实现-add-column-if-not-exists"><a class="header" href="#tip-2手动实现-add-column-if-not-exists">Tip 2：手动实现 <code>ADD COLUMN IF NOT EXISTS</code></a></h3>
<p>MySQL 不支持这个 SQL 语法，所以 SeaORM 建议通过代码逻辑实现：</p>
<pre><code class="language-rust ignore">async fn up(&amp;self, manager: &amp;SchemaManager) -&gt; Result&lt;(), DbErr&gt; {
    if !manager.has_column("user", "email").await? {
        // 只有不存在时才执行 alter_table
    }
    Ok(())
}</code></pre>
<p>初学者暂时可以不考虑，直接写 <code>create_table</code> 和 <code>add_column</code>。等以后遇到报错了，再回来学这个“<strong>手动检查</strong>”的方法。</p>
<h3 id="tip-3数据种子填充"><a class="header" href="#tip-3数据种子填充">Tip 3：数据种子填充</a></h3>
<p>你可以在 <code>up</code> 逻辑里直接使用 <code>ActiveModel</code> 插入初始数据。迁移文件不仅能改表结构，还能利用你已经写好的实体模型来操作数据。 它是将“结构变更”与“数据初始化”合二为一的优雅手段。</p>
<ul>
<li><strong>逻辑</strong> ：先 <code>create_table</code>，紧接着 <code>insert(db)</code>。</li>
</ul>
<pre><code class="language-rust ignore">#[async_trait]
impl MigrationTrait for Migration {
    async fn up(&amp;self, manager: &amp;SchemaManager) -&gt; Result&lt;(), DbErr&gt; {
        // 1. 先用 SeaQuery 建表
        manager.create_table(
            Table::create().table(cake::Entity).if_not_exists()
                .col(ColumnDef::new(cake::Column::Id).integer().not_null().auto_increment().primary_key())
                .col(ColumnDef::new(cake::Column::Name).string().not_null())
                .to_owned()
        ).await?;

        // 2. 表建好了，立刻塞入一条初始数据
        let db = manager.get_connection();
        cake::ActiveModel {
            name: Set("Cheesecake".to_owned()),
            ..Default::default() // 其他字段用默认值
        }
        .insert(db)// 真正的插入动作
        .await?; 

        Ok(())
    }
}</code></pre>
<hr>
<p>迁移系统不仅仅是建表。它是通过 MigratorTrait 注册、利用 SchemaManager 丰富的 API 进行结构演进、并利用 PostgreSQL 的 原子性事务 确保数据安全的一整套工程化方案。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="运行迁移"><a class="header" href="#运行迁移">运行迁移</a></h1>
<h2 id="1-命令行操作-cli"><a class="header" href="#1-命令行操作-cli">1. 命令行操作 (CLI)</a></h2>
<p>在终端里，你可以手动控制数据库的进化。</p>
<blockquote>
<p><strong>注意</strong> ：运行这些命令前，必须先在终端设置环境变量：<code>export DATABASE_URL="postgres://user:pass@localhost:5432/db"</code>。</p>
</blockquote>
<h3 id="常用命令对比表"><a class="header" href="#常用命令对比表">常用命令对比表</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>命令</strong></th><th><strong>行为</strong></th><th><strong>危险等级</strong></th><th><strong>适用场景</strong></th></tr>
</thead>
<tbody>
<tr><td><strong><code>up</code></strong></td><td>运行所有未执行的迁移。</td><td>🟢 安全</td><td>日常更新数据库。</td></tr>
<tr><td><strong><code>down</code></strong></td><td>撤销最后一次迁移。</td><td>🟡 中等</td><td>发现刚写的脚本有错，回滚一下。</td></tr>
<tr><td><strong><code>status</code></strong></td><td>列出哪些已跑，哪些还没跑。</td><td>🟢 安全</td><td>检查当前数据库版本。</td></tr>
<tr><td><strong><code>refresh</code></strong></td><td>先回滚所有迁移，再重新全部跑一遍。</td><td>🔴 危险</td><td>相当于重置数据，但保留表结构的变化。</td></tr>
<tr><td><strong><code>fresh</code></strong></td><td><strong>直接删掉所有表</strong> ，再重新跑一遍。</td><td>💀 极高</td><td>数据库搞乱了，想彻底推倒重来。</td></tr>
<tr><td><strong><code>reset</code></strong></td><td>回滚所有已应用的迁移。</td><td>🔴 危险</td><td>清空数据库结构。</td></tr>
</tbody>
</table>
</div>
<h3 id="a-命令行界面-cli-常用操作"><a class="header" href="#a-命令行界面-cli-常用操作">A. 命令行界面 (CLI) 常用操作</a></h3>
<ul>
<li><code>sea-orm-cli migrate init</code>: 初始化迁移目录，生成基础结构, eg: <code>sea-orm-cli migrate init</code>。</li>
<li><code>sea-orm-cli migrate generate [NAME]</code>: 生成带时间戳的新迁移文件, eg: <code>sea-orm-cli migrate generate create_user_table</code>。</li>
<li><code>sea-orm-cli migrate up</code>: 应用所有挂起的（未执行的）迁移任务, eg: <code>sea-orm-cli migrate up</code>。</li>
<li><code>sea-orm-cli migrate up -n [NUM]</code>: 应用指定数量的挂起迁移任务, eg: <code>sea-orm-cli migrate up -n 3</code>。</li>
<li><code>sea-orm-cli migrate down</code>: 撤销最后一次应用的迁移任务, eg: <code>sea-orm-cli migrate down</code>。</li>
<li><code>sea-orm-cli migrate down -n [NUM]</code>: 撤销最近指定数量的迁移任务, eg: <code>sea-orm-cli migrate down -n 2</code>。</li>
<li><code>sea-orm-cli migrate status</code>: 查看所有迁移任务的状态（已应用或挂起）, eg: <code>sea-orm-cli migrate status</code>。</li>
<li><code>sea-orm-cli migrate fresh</code>: 删除数据库中的所有表，并重新从头应用所有迁移, eg: <code>sea-orm-cli migrate fresh</code>。</li>
<li><code>sea-orm-cli migrate refresh</code>: 回滚所有已应用的迁移，然后重新应用它们, eg: <code>sea-orm-cli migrate refresh</code>。</li>
<li><code>sea-orm-cli migrate reset</code>: 回滚所有已应用的迁移任务, eg: <code>sea-orm-cli migrate reset</code>。</li>
</ul>
<hr>
<h3 id="b-程序化调用-在-rust-代码中运行"><a class="header" href="#b-程序化调用-在-rust-代码中运行">B. 程序化调用 (在 Rust 代码中运行)</a></h3>
<ul>
<li><code>Migrator::up(db, None)</code>: 在程序启动时自动应用所有挂起的迁移, eg: <code>Migrator::up(&amp;db, None).await?</code>。</li>
<li><code>Migrator::up(db, Some(n))</code>: 在代码中应用前 <code>n</code> 个挂起的迁移, eg: <code>Migrator::up(&amp;db, Some(5)).await?</code>。</li>
<li><code>Migrator::down(db, None)</code>: 在代码中回滚所有已应用的迁移（等同于 reset）, eg: <code>Migrator::down(&amp;db, None).await?</code>。</li>
<li><code>Migrator::down(db, Some(n))</code>: 在代码中回滚最后 <code>n</code> 个迁移, eg: <code>Migrator::down(&amp;db, Some(1)).await?</code>。</li>
<li><code>Migrator::status(db)</code>: 在代码中检查迁移状态, eg: <code>let status = Migrator::status(&amp;db).await?</code>。</li>
<li><code>Migrator::fresh(db)</code>: 在代码中执行“删表重练”操作, eg: <code>Migrator::fresh(&amp;db).await?</code>。</li>
<li><code>Migrator::refresh(db)</code>: 在代码中执行“重置并重启”迁移, eg: <code>Migrator::refresh(&amp;db).await?</code>。</li>
<li><code>Migrator::reset(db)</code>: 在代码中撤销所有迁移, eg: <code>Migrator::reset(&amp;db).await?</code>。</li>
<li><code>Migrator::get_pending_migrations(db)</code>: 获取所有尚未应用的迁移列表, eg: <code>let pending = Migrator::get_pending_migrations(&amp;db).await?</code>。</li>
<li><code>Migrator::get_applied_migrations(db)</code>: 获取所有已经成功应用的迁移列表, eg: <code>let applied = Migrator::get_applied_migrations(&amp;db).await?</code>。</li>
</ul>
<hr>
<h2 id="2-代码自动执行生产环境必备"><a class="header" href="#2-代码自动执行生产环境必备">2. 代码自动执行：生产环境必备</a></h2>
<p>在生产环境，你不可能手动去敲命令行。通常在 <code>main.rs</code> 程序启动时自动检测并升级数据库。</p>
<pre><code class="language-rust ignore">use migration::{Migrator, MigratorTrait};
// 在连接数据库后调用
let db = Database::connect(url).await?;
// 自动把所有没跑的迁移补上
Migrator::up(&amp;db, None).await?; </code></pre>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="初始化数据"><a class="header" href="#初始化数据">初始化数据</a></h1>
<p>如何在数据库迁移过程中 <strong>初始化数据（Seeding Data）</strong> 。当你建好表后，通常需要塞入一些初始数据（如默认管理员、配置项等）。</p>
<hr>
<h2 id="1-数据初始化-seeding-data-的三种方式"><a class="header" href="#1-数据初始化-seeding-data-的三种方式">1. 数据初始化 (Seeding Data) 的三种方式</a></h2>
<ul>
<li><strong>使用 ActiveModel 初始化</strong> : 借用已经定义好的 Rust 实体类来插入数据，具有最强的类型安全性:</li>
</ul>
<pre><code class="language-rust ignore">let db = manager.get_connection();
cake::ActiveModel { 
   name: Set(
       "Cheesecake".to_owned()), 
       ..Default::default() 
   }
  .insert(db)
   .await?;</code></pre>
<ul>
<li><strong>使用 SeaQuery 语句初始化</strong> : 不需要依赖具体的实体类，直接通过代码构造插入语句，适合在实体类尚未生成时使用, eg:</li>
</ul>
<pre><code class="language-rust ignore">let stmt = Query::insert()
      .into_table("cake")
      .columns(["name"])
      .values_panic(["Tiramisu".into()])
      .to_owned();
manager.execute(&amp;stmt).await?;</code></pre>
<ul>
<li><strong>事务式初始化 (Transactional)</strong> : 手动开启一个事务，确保数据插入要么全部成功，要么全部回滚，保证数据的一致性, eg:</li>
</ul>
<pre><code class="language-rust ignore">let db = manager.get_connection();
let txn = db.begin().await?; // 开启事务
cake::ActiveModel {
    name: Set("Cheesecake".to_owned()),
    ..Default::default()
}
.insert(&amp;txn)
.await?;
txn.commit().await?; // 提交事务</code></pre>
<hr>
<h2 id="2-深度细节解析"><a class="header" href="#2-深度细节解析">2. 深度细节解析</a></h2>
<h3 id="①-为什么使用-activemodel"><a class="header" href="#①-为什么使用-activemodel">① 为什么使用 <code>ActiveModel</code>？</a></h3>
<p>这是最推荐的方式。因为它是<strong>强类型</strong>的，如果你的数据库字段改了，这段代码在编译阶段就会报错，而不是等到运行时才崩溃。</p>
<blockquote>
<p><strong>注意</strong> ：这要求你的 <code>migration</code> crate 能够引用到 <code>entity</code> crate。</p>
</blockquote>
<h3 id="②-为什么使用-seaquery"><a class="header" href="#②-为什么使用-seaquery">② 为什么使用 <code>SeaQuery</code>？</a></h3>
<p>如果你在写迁移脚本时，还没生成对应的 <code>entity</code> 代码，或者不想让迁移脚本和业务代码耦合得太深，就可以用 <code>Query::insert()</code>。它直接操作字符串表名和列名，灵活性更高。</p>
<h3 id="③-关于-postgresql-的事务-important"><a class="header" href="#③-关于-postgresql-的事务-important">③ 关于 PostgreSQL 的事务 (Important!)</a></h3>
<p>你使用的是  <strong>PostgreSQL</strong> ，有一个非常大的优势：</p>
<ul>
<li><strong>自动事务</strong> ：SeaORM 在 Postgres 上运行 <code>up</code> 函数时，默认会把整个函数包裹在一个事务里。</li>
<li><strong>手动事务的作用</strong> ：虽然有自动事务，但文档中的 <code>db.begin()</code> 允许你在迁移逻辑内部进行更细粒度的控制，或者在复杂的逻辑中明确标注事务边界。</li>
</ul>
<hr>
<h2 id="3-核心-api-说明"><a class="header" href="#3-核心-api-说明">3. 核心 API 说明</a></h2>
<ul>
<li><code>manager.get_connection()</code>: 从迁移管理器中获取当前的数据库连接对象 (<code>DbConn</code>)。</li>
<li><code>Query::insert()</code>: SeaQuery 的插入语句构造器。</li>
<li><code>manager.execute(&amp;stmt)</code>: 执行构造好的 SeaQuery 语句。</li>
<li><code>db.begin()</code>: 在当前连接上开启一个异步事务。</li>
<li><code>txn.commit()</code>: 提交事务，让所有更改永久生效。</li>
</ul>
<hr>
<p>迁移脚本不只是能改“结构（表）”，还能改“内容（数据）”。在 PostgreSQL 中，利用其原子性特点，结合 ActiveModel 的类型安全，你可以非常稳健地完成数据库的初始化。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="生成实体"><a class="header" href="#生成实体">生成实体</a></h1>
<h2 id="using-sea-orm-cli"><a class="header" href="#using-sea-orm-cli">Using sea-orm-cli</a></h2>
<p><code>sea-orm-cli</code> 的实体生成功能（Generate Entity）可以让你不用手写复杂的 Rust 结构体，直接根据数据库里已经建好的表“一键生成”对应的代码。</p>
<h3 id="1-基础安装与配置"><a class="header" href="#1-基础安装与配置">1. 基础安装与配置</a></h3>
<ul>
<li><code>cargo install sea-orm-cli</code>: 安装 SeaORM 命令行工具, eg: <code>cargo install sea-orm-cli</code>。</li>
<li><code>DATABASE_URL=...</code>: 在 <code>.env</code> 文件或环境变量中设置 PostgreSQL 连接字符串, eg: <code>DATABASE_URL=postgres://user:pass@localhost/db</code>。</li>
<li><code>sea-orm-cli -h</code>: 查看所有可用的命令列表, eg: <code>sea-orm-cli -h</code>。</li>
</ul>
<h3 id="2-实体生成命令"><a class="header" href="#2-实体生成命令">2. 实体生成命令</a></h3>
<p>这是最核心的命令，它会扫描数据库并生成 Rust 文件。</p>
<ul>
<li><code>sea-orm-cli generate entity</code>: 发现数据库中的所有表并生成对应的实体文件, eg: <code>sea-orm-cli generate entity -o src/entities</code>。</li>
<li><code>-u / --database-url</code>: 手动指定数据库连接地址（覆盖环境变量）, eg: <code>sea-orm-cli generate entity -u postgres://root:root@localhost/my_db</code>。</li>
<li><code>-s / --database-schema</code>: <strong>(PostgreSQL 特有)</strong> 指定要扫描的 Schema（默认是 public）, eg: <code>sea-orm-cli generate entity -s my_custom_schema</code>。</li>
<li><code>-o / --output-dir</code>: 指定生成文件的存放目录, eg: <code>sea-orm-cli generate entity -o src/models</code>。</li>
<li><code>--with-serde</code>: 为生成的实体自动添加 Serde 序列化/反序列化宏, eg: <code>sea-orm-cli generate entity --with-serde both</code>。</li>
<li><code>--expanded-format</code>: 使用“展开格式”生成代码（将 Column, Relation 等拆开写，更清晰）, eg: <code>sea-orm-cli generate entity --expanded-format</code>。</li>
<li><code>--compact-format</code>: 使用“紧凑格式”生成代码（默认模式）, eg: <code>sea-orm-cli generate entity --compact-format</code>。</li>
<li><code>--date-time-crate</code>: 指定时间处理库（chrono 或 time）, eg: <code>sea-orm-cli generate entity --date-time-crate time</code>。</li>
<li><code>--ignore-tables</code>: 跳过指定的表不生成实体, eg: <code>sea-orm-cli generate entity --ignore-tables seaql_migrations,secret_table</code>。</li>
<li><code>--model-extra-derives</code>: 为生成的 Model 结构体额外添加指定的 Derive 宏, eg: <code>sea-orm-cli generate entity --model-extra-derives "Default, Clone"</code>。</li>
</ul>
<hr>
<h3 id="3-postgresql-用户的实战建议"><a class="header" href="#3-postgresql-用户的实战建议">3. PostgreSQL 用户的实战建议</a></h3>
<p>当你运行生成命令时，建议带上以下参数，这在实际开发中最常用：</p>
<pre><code class="language-bash">sea-orm-cli generate entity \
    -u postgres://user:pass@localhost/my_db \
    -o src/entities \
    --with-serde both \
    --expanded-format

</code></pre>
<p><strong>参数解释：</strong></p>
<ol>
<li><strong><code>-o src/entities</code></strong>: 把代码放在专门的目录，方便管理。</li>
<li><strong><code>--with-serde both</code></strong>: 几乎所有的 Web 项目都需要把数据库结果转成 JSON 传给前端，开启这个可以省去手动加 <code>#[derive(Serialize, Deserialize)]</code>。</li>
<li><strong><code>--expanded-format</code></strong>: 虽然代码量会变多，但当你需要自定义关联关系（Relation）或者给字段加注释时，这种格式比“紧凑格式”更容易修改。</li>
</ol>
<hr>
<h2 id="entity-format"><a class="header" href="#entity-format">Entity Format</a></h2>
<p>在 SeaORM 中，一个“实体”不仅仅是一个结构体，它是 <strong>Rust 对象与数据库表之间的桥梁</strong></p>
<pre><code class="language-rust ignore">use sea_orm::entity::prelude::*;

#[sea_orm::model]
#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]
#[sea_orm(table_name = "cake")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub name: String,
    #[sea_orm(has_one)]
    pub fruit: Option&lt;super::fruit::Entity&gt;,
    #[sea_orm(has_many, via = "cake_filling")]
    pub fillings: Vec&lt;super::filling::Entity&gt;,
}

impl ActiveModelBehavior for ActiveModel {}</code></pre>
<h3 id="核心组成部分"><a class="header" href="#核心组成部分">核心组成部分</a></h3>
<ol>
<li><strong>Model (模型结构体)</strong>：这是你最常打交道的。它定义了表中每一列的名字和数据类型。当你执行 <code>SELECT</code> 查询时，结果会被填充进这个结构体。</li>
<li><strong>DeriveEntityModel 宏</strong>：这是 SeaORM 的魔法所在。你只需定义一个 <code>Model</code> 结构体并加上这个宏，它会自动在后台帮你生成：</li>
</ol>
<ul>
<li><code>Entity</code> 结构体：用于代表整张表，执行 <code>find</code> 等操作。</li>
<li><code>Column</code> 枚举：代表表中的每一列，用于过滤和排序。</li>
<li><code>PrimaryKey</code> 枚举：定义谁是主键。</li>
</ul>
<blockquote>
<p>INFO
<strong>ActiveModelBehavior (行为钩子)</strong>：它允许你在数据“落库”前或“出库”后做逻辑处理。即使你什么都不写，也必须声明它，因为 SeaORM 需要它来完成 <code>ActiveModel</code> 的闭环。</p>
</blockquote>
<h3 id="完整代码演示postgresql-风格的-user-实体"><a class="header" href="#完整代码演示postgresql-风格的-user-实体">完整代码演示：PostgreSQL 风格的 User 实体</a></h3>
<p>假设我们要为 PostgreSQL 建立一张用户表，包含主键、唯一索引、可选字段以及自动转换逻辑。</p>
<pre><code class="language-rust ignore">use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "users", schema_name = "public")] // 指定表名和 PG 的 schema
pub struct Model {
    #[sea_orm(primary_key)] // 标记为主键，默认自增
    pub id: i32,// Postgres 本身不支持无符号整数类型，不建议使用无符号类型（例如 u64 ）

    #[sea_orm(unique)] // 唯一约束
    pub username: String,

    #[sea_orm(column_type = "Text", nullable)] // 指定 PG 类型为 Text，允许为空
    pub bio: Option&lt;String&gt;,

    // 逻辑转换：数据库里存 citext（大小写不敏感），Rust 里用 String
    #[sea_orm(select_as = "text", save_as = "citext")]
    pub email: String,

    #[sea_orm(ignore)] // 这个字段不会在数据库中创建，仅供 Rust 逻辑内部使用
    pub temp_token: String,
}

// 定义关联关系（如果没有关联，写空即可）
#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

// 即使它是空的，也不要删除 ActiveModelBehavior impl 块。
// 生命周期钩子
#[async_trait::async_trait]
impl ActiveModelBehavior for ActiveModel {
    // 每次创建新的 ActiveModel（比如插入前）时触发
    fn new() -&gt; Self {
        println!("准备创建一个新的用户记录");
        Self {
            ..ActiveModelTrait::default()
        }
    }

    // Will be triggered before insert / update
    async fn before_save&lt;C&gt;(self, _db: &amp;C, insert: bool) -&gt; Result&lt;Self, DbErr&gt;
    where C: ConnectionTrait,
    {
        if insert {
            println!("正在插入新用户...");
        }
        Ok(self)
    }
    /// Will be triggered before insert / update
    async fn before_save&lt;C&gt;(self, db: &amp;C, insert: bool) -&gt; Result&lt;Self, DbErr&gt;
    where
        C: ConnectionTrait,
    {
        if self.price.as_ref() &lt;= &amp;0.0 {
            Err(DbErr::Custom(format!(
                "[before_save] Invalid Price, insert: {}",
                insert
            )))
        } else {
            Ok(self)
        }
    }

    /// Will be triggered after insert / update
    async fn after_save&lt;C&gt;(model: Model, db: &amp;C, insert: bool) -&gt; Result&lt;Model, DbErr&gt;
    where
        C: ConnectionTrait,
    {
        Ok(model)
    }

    /// Will be triggered before delete
    async fn before_delete&lt;C&gt;(self, db: &amp;C) -&gt; Result&lt;Self, DbErr&gt;
    where
        C: ConnectionTrait,
    {
        Ok(self)
    }

    /// Will be triggered after delete
    async fn after_delete&lt;C&gt;(self, db: &amp;C) -&gt; Result&lt;Self, DbErr&gt;
    where
        C: ConnectionTrait,
    {
        Ok(self)
    }
}
</code></pre>
<h3 id="核心标签attributes深度解析"><a class="header" href="#核心标签attributes深度解析">核心标签（Attributes）深度解析</a></h3>
<p>如果你手动看代码，最困惑的可能是 <code>#[sea_orm(...)]</code> 里的内容。我为你详细解释它们的<strong>设计意图</strong>：</p>
<h4 id="a-命名与映射"><a class="header" href="#a-命名与映射">A. 命名与映射</a></h4>
<p><code>#[sea_orm(table_name = "user", rename_all = "camelCase")]</code></p>
<ul>
<li><strong><code>table_name</code></strong>: 必须指定。因为 Rust 结构体习惯大驼峰（<code>UserModel</code>），而 SQL 表习惯小写蛇形（<code>users</code>）。</li>
<li><strong><code>rename_all</code></strong>: 如果你的 PostgreSQL 表全是驼峰命名（非常少见），用这个可以一次性转换，不用给每个字段写 <code>column_name</code>。</li>
</ul>
<h4 id="b-类型微调"><a class="header" href="#b-类型微调">B. 类型微调</a></h4>
<ul>
<li><strong><code>column_type</code></strong>: Rust 的 <code>String</code> 默认映射到 <code>Varchar(255)</code>。如果你在 PostgreSQL 中想用更长的 <code>TEXT</code> 类型，就必须通过这个标签明确指定。</li>
<li><strong><code>Option&lt;T&gt;</code></strong>: 这是处理 <strong>Nullable（可为空）</strong> 的唯一方式。Rust 的类型安全强制你必须用 <code>Option</code> 来包裹数据库中可能为 <code>NULL</code> 的字段。</li>
</ul>
<h4 id="c-主键逻辑"><a class="header" href="#c-主键逻辑">C. 主键逻辑</a></h4>
<ul>
<li><strong><code>primary_key</code></strong>: SeaORM 看到它后，会自动把这个字段放进生成的 <code>PrimaryKey</code> 枚举里。</li>
<li><strong><code>auto_increment</code></strong>: 对于 PostgreSQL 的 <code>SERIAL</code> 类型，默认就是 <code>true</code>。如果你用 UUID 或者手动指定 ID，记得把它设为 <code>false</code>。</li>
</ul>
<hr>
<h3 id="为什么会有-activemodelbehavior"><a class="header" href="#为什么会有-activemodelbehavior">为什么会有 ActiveModelBehavior？</a></h3>
<p>可能觉得 <code>impl ActiveModelBehavior for ActiveModel {}</code> 很多余。</p>
<p><strong>文字说明：</strong>
它是为了实现 <strong>“领域驱动设计” (DDD)</strong>。</p>
<ul>
<li>比如：你想在用户每次修改密码时，自动更新 <code>updated_at</code> 时间戳。</li>
<li>你可以把这个逻辑写在 <code>before_save</code> 钩子里。</li>
<li>这样无论你在项目的哪个位置执行 <code>user.update(db)</code>，更新时间的逻辑都会<strong>自动触发</strong>，保证了业务逻辑的内聚性，不用到处复制粘贴代码。</li>
</ul>
<p>这一章节非常关键，它详细定义了 <strong>Rust 类型</strong>与 <strong>PostgreSQL 类型</strong>之间的“翻译规则”。作为 PostgreSQL 用户，你需要特别关注那些 PG 特有的功能（如 JSONB、Array 和 Vector）。</p>
<p>以下是内容的详细拆解与文字说明：</p>
<hr>
<h2 id="列类型"><a class="header" href="#列类型">列类型</a></h2>
<h3 id="1-基础类型映射表"><a class="header" href="#1-基础类型映射表">1. 基础类型映射表</a></h3>
<p>在 SeaORM 中，大多数基础类型是自动转换的。但请注意：<strong>PostgreSQL 不支持无符号整数（Unsigned）</strong>。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Rust 类型</th><th>PostgreSQL 类型</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td><code>String</code></td><td><code>VARCHAR</code> / <code>TEXT</code></td><td>默认是 <code>varchar</code>，可用 <code>column_type="Text"</code> 改为 <code>text</code>。</td></tr>
<tr><td><code>i32</code></td><td><code>INTEGER</code></td><td>标准 4 字节整数。</td></tr>
<tr><td><code>i64</code></td><td><code>BIGINT</code></td><td>8 字节长整数。</td></tr>
<tr><td>**<code>u32</code> / <code>u64**</code></td><td><strong>不支持</strong></td><td><strong>重要：</strong> 在 PG 中请统一使用 <code>i32</code> 或 <code>i64</code>。</td></tr>
<tr><td><code>f64</code></td><td><code>DOUBLE PRECISION</code></td><td>高精度浮点数。</td></tr>
<tr><td><code>bool</code></td><td><code>BOOL</code></td><td>布尔值。</td></tr>
<tr><td><code>Vec&lt;u8&gt;</code></td><td><code>BYTEA</code></td><td>二进制大对象。</td></tr>
</tbody>
</table>
</div>
<h3 id="2-时间与特殊类型映射"><a class="header" href="#2-时间与特殊类型映射">2. 时间与特殊类型映射</a></h3>
<p>这些类型通常需要你在 <code>Cargo.toml</code> 中开启对应的 feature（如 <code>with-chrono</code> 或 <code>with-uuid</code>）。</p>
<ul>
<li>
<p><strong>UUID</strong>: <code>uuid::Uuid</code> 直接映射为 PostgreSQL 的 <code>uuid</code> 类型。</p>
</li>
<li>
<p><strong>Decimal</strong>: <code>rust_decimal::Decimal</code> 映射为 <code>decimal</code>。在定义时通常需要指定精度：</p>
</li>
<li>
<p><code>#[sea_orm(column_type = "Decimal(Some((16, 4)))")]</code></p>
</li>
<li>
<p><strong>日期时间</strong>:</p>
</li>
<li>
<p><code>chrono::NaiveDateTime</code> -&gt; <code>timestamp</code> (不带时区)。</p>
</li>
<li>
<p><code>chrono::DateTime&lt;FixedOffset&gt;</code> -&gt; <code>timestamp with time zone</code> (带时区)。</p>
</li>
</ul>
<h3 id="3-json-与自定义结构-jsonb"><a class="header" href="#3-json-与自定义结构-jsonb">3. JSON 与自定义结构 (JSONB)</a></h3>
<p>PostgreSQL 的 <code>JSONB</code> 是其最强大的特性之一。SeaORM 提供了非常优雅的处理方式。</p>
<h4 id="文字说明"><a class="header" href="#文字说明">文字说明</a></h4>
<ol>
<li><strong>基础 JSON</strong>: 使用 <code>serde_json::Value</code> 处理动态格式。</li>
<li><strong>强类型 JSON</strong>: 如果你希望 JSON 字段直接映射到 Rust 的 <code>struct</code>，只需让该结构体派生 <code>FromJsonQueryResult</code>。</li>
<li><strong>JSONB 优化</strong>: 使用 <code>#[sea_orm(column_type = "JsonBinary")]</code> 强制使用 PG 的二进制 JSON 格式，这样查询性能更高。</li>
</ol>
<h4 id="代码演示"><a class="header" href="#代码演示">代码演示</a></h4>
<pre><code class="language-rust ignore">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, FromJsonQueryResult)]
pub struct UserMeta {
    pub login_count: i32,
    pub last_ip: String,
}

#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]
#[sea_orm(table_name = "profiles")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    // 自动序列化/反序列化为 JSONB
    #[sea_orm(column_type = "JsonBinary")]
    pub meta: UserMeta, 
}
</code></pre>
<h3 id="4-postgresql-专有功能-array--vector--ip"><a class="header" href="#4-postgresql-专有功能-array--vector--ip">4. PostgreSQL 专有功能 (Array / Vector / IP)</a></h3>
<p>这是你选择 PostgreSQL 的“红利”，SeaORM 提供了原生支持：</p>
<ul>
<li><strong>数组 (Array)</strong>: 直接使用 <code>Vec&lt;T&gt;</code>。例如 <code>Vec&lt;String&gt;</code> 会自动映射为 PG 的 <code>text[]</code>。</li>
<li><strong>向量 (Vector)</strong>: 需要开启 <code>postgres-vector</code> 模式。用于 AI 向量数据库（如 pgvector 扩展），对应 <code>PgVector</code> 类型。</li>
<li><strong>IP 地址</strong>: 需要开启 <code>with-ipnetwork</code>。<code>IpNetwork</code> 类型对应 PG 的 <code>inet</code> 或 <code>cidr</code>。</li>
</ul>
<h3 id="5-unix-时间戳包装器-new-in-200"><a class="header" href="#5-unix-时间戳包装器-new-in-200">5. Unix 时间戳包装器 (New in 2.0.0)</a></h3>
<p>有时候我们不希望在数据库存 <code>Timestamp</code> 类型，而是存一个 <code>i64</code> 的数字（秒数）。SeaORM 2.0 引入了包装器：</p>
<ul>
<li><strong><code>ChronoUnixTimestamp</code></strong>: 在 Rust 里它是日期时间对象，但存入数据库时会自动转成 <code>i64</code> 整数。这对于需要高性能时间比对的场景非常有用。</li>
</ul>
<hr>
<h2 id="activeenum"><a class="header" href="#activeenum">ActiveEnum</a></h2>
<p><strong>ActiveEnum</strong> 是一个非常强大的功能。它允许你直接在 Rust 代码中使用枚举类型，并将其安全地映射到数据库的字段中。</p>
<p>简单来说，它解决了“数据库存 <code>0/1</code> 或 <code>'active'/'inactive'</code>，而 Rust 代码需要强类型”的需求。</p>
<p>以下是内容的详细拆解：</p>
<h3 id="1-三种映射策略"><a class="header" href="#1-三种映射策略">1. 三种映射策略</a></h3>
<p>根据你希望在 PostgreSQL 里的存储方式，有三种选择：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>映射方式</th><th>数据库存储类型</th><th>特点</th></tr>
</thead>
<tbody>
<tr><td><strong>String (字符串)</strong></td><td><code>VARCHAR</code> 或 <code>TEXT</code></td><td>最通用，易于阅读，但在数据库层没有硬约束。</td></tr>
<tr><td><strong>Integer (整数)</strong></td><td><code>INTEGER</code></td><td>存储空间最省，但数据库里的数字（如 <code>0</code>, <code>1</code>）不直观。</td></tr>
<tr><td><strong>Native Enum (原生)</strong></td><td><code>CREATE TYPE ... AS ENUM</code></td><td><strong>PostgreSQL 推荐</strong>。性能好，数据库层面会有严格的类型约束。</td></tr>
</tbody>
</table>
</div>
<hr>
<h3 id="2-字符串映射-string-backed"><a class="header" href="#2-字符串映射-string-backed">2. 字符串映射 (String-backed)</a></h3>
<p>如果你想把 <code>Category::BigTask</code> 存成数据库里的 <code>"bigTask"</code>：</p>
<ul>
<li><strong>自动化方式</strong>：使用 <code>rename_all</code> 自动转换大小写（如 <code>camelCase</code>）。</li>
<li><strong>手动方式</strong>：使用 <code>#[sea_orm(string_value = "xxx")]</code> 精确指定。</li>
</ul>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(EnumIter, DeriveActiveEnum)]
#[sea_orm(rs_type = "String", db_type = "String(StringLen::None)", rename_all = "camelCase")]
pub enum Category {
    BigTask,   // 存储为 "bigTask"
    SmallWork, // 存储为 "smallWork"
}

<span class="boring">}</span></code></pre>
<h3 id="3-postgresql-原生枚举-native-enum"><a class="header" href="#3-postgresql-原生枚举-native-enum">3. PostgreSQL 原生枚举 (Native Enum)</a></h3>
<p>这是 PostgreSQL 的特色功能。你需要先在数据库创建一个 <strong>自定义类型</strong>。</p>
<h4 id="第一步在迁移文件-migration-中创建类型"><a class="header" href="#第一步在迁移文件-migration-中创建类型">第一步：在迁移文件 (Migration) 中创建类型</a></h4>
<p>由于 PostgreSQL 要求先有类型再建表，你有两种写法：</p>
<ul>
<li><strong>写法 A (手动)</strong>: 直接写明类型名和值。</li>
<li><strong>写法 B (推荐)</strong>: 直接从 Rust 的枚举类生成定义。</li>
</ul>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 在 migration 的 up 函数中
let schema = Schema::new(DbBackend::Postgres);
manager.create_type(
    schema.create_enum_from_active_enum::&lt;Tea&gt;()
).await?;

<span class="boring">}</span></code></pre>
<hr>
<h3 id="4-在-model-中使用"><a class="header" href="#4-在-model-中使用">4. 在 Model 中使用</a></h3>
<p>定义好 <code>ActiveEnum</code> 后，你可以像使用普通类型（如 <code>i32</code>）一样在 <code>Model</code> 结构体里使用它。</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]
#[sea_orm(table_name = "tasks")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    // 直接使用枚举类型
    pub category: Category, 
    // 也可以是可选的
    pub category_opt: Option&lt;Category&gt;, 
}

<span class="boring">}</span></code></pre>
<h3 id="5-核心-api-与属性总结"><a class="header" href="#5-核心-api-与属性总结">5. 核心 API 与属性总结</a></h3>
<ul>
<li><strong><code>rs_type</code></strong>: 指定在 Rust 中对应的基础类型（通常是 <code>String</code> 或 <code>i32</code>）。</li>
<li><strong><code>db_type</code></strong>: 指定在数据库中的存储格式（<code>String</code>, <code>Integer</code> 或 <code>Enum</code>）。</li>
<li><strong><code>enum_name</code></strong>: 仅用于原生枚举，指定 PostgreSQL 中该类型的名称（如 <code>CREATE TYPE "tea"</code>）。</li>
<li><strong><code>DeriveValueType</code></strong>: 如果你只需要简单的字符串映射且不想写复杂的宏，可以用这个更轻量级的替代方案（需手动实现 <code>to_str</code>）。</li>
</ul>
<h2 id="entity-first"><a class="header" href="#entity-first">Entity First</a></h2>
<p>这是 SeaORM 2.0 引入的重磅功能：<strong>Entity First（实体优先）</strong> 工作流。</p>
<p>简单来说，以前你需要先写 SQL/Migration 建表，再写 Rust 代码；现在你<strong>只需写 Rust 的 Entity 结构体</strong>，SeaORM 会自动帮你把 PostgreSQL 里的表结构同步好。这非常适合快速迭代。</p>
<h3 id="1-基础配置开启自动同步"><a class="header" href="#1-基础配置开启自动同步">1. 基础配置：开启自动同步</a></h3>
<p>要在项目中使用“实体优先”，首先要在 <code>Cargo.toml</code> 中开启功能，并在 <code>main.rs</code> 连接数据库后调用同步指令。</p>
<ul>
<li><strong>Cargo.toml 配置</strong>:</li>
</ul>
<pre><code class="language-toml">[dependencies]
sea-orm = { version = "2.0", features = ["schema-sync", "entity-registry", "sqlx-postgres", "runtime-tokio-rustls"] }

</code></pre>
<ul>
<li><strong>main.rs 启动逻辑</strong>:</li>
</ul>
<pre class="playground"><code class="language-rust edition2024">use sea_orm::{Database, EntityTrait};

#[tokio::main]
async fn main() -&gt; Result&lt;(), sea_orm::DbErr&gt; {
    let db = Database::connect("postgres://user:pass@localhost/my_db").await?;

    // 核心代码：自动同步。它会扫描当前 crate 的 entity 模块并更新 Postgres
    // "my_app" 需要替换为你 Cargo.toml 里的 package name
    db.get_schema_registry("my_app::entity::*").sync(&amp;db).await?;

    println!("数据库结构同步完成！");
    Ok(())
}
</code></pre>
<hr>
<h3 id="2-场景一新增一个表添加-entity"><a class="header" href="#2-场景一新增一个表添加-entity">2. 场景一：新增一个表（添加 Entity）</a></h3>
<p>你只需要在 <code>entity/</code> 目录下新建一个 Rust 文件，下次启动程序时，PostgreSQL 就会自动多出一张表。</p>
<ul>
<li><strong>代码示例 (<code>entity/post.rs</code>)</strong>:</li>
</ul>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sea_orm::entity::prelude::*;

#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]
#[sea_orm(table_name = "post")] // 只要写了这个，SeaORM 就会去建表
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub title: String,
    pub content: String,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}

<span class="boring">}</span></code></pre>
<p><strong>结果</strong>：启动后，Postgres 会执行 <code>CREATE TABLE "post" (...)</code>。</p>
<hr>
<h3 id="3-场景二增加新字段修改-model"><a class="header" href="#3-场景二增加新字段修改-model">3. 场景二：增加新字段（修改 Model）</a></h3>
<p>如果你想给用户表加一个“出生日期”字段，直接改 Rust 代码即可。</p>
<ul>
<li><strong>代码示例</strong>:</li>
</ul>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub name: String,
    
    // 新增字段：设为 Option 则在数据库中允许为 NULL
    pub date_of_birth: Option&lt;DateTimeWithTimeZone&gt;, 
    
    // 新增字段：设置默认值，防止旧数据报错
    #[sea_orm(default_value = 0)]
    pub login_count: i32,
}

<span class="boring">}</span></code></pre>
<p><strong>结果</strong>：启动后，Postgres 会执行 <code>ALTER TABLE "user" ADD COLUMN "date_of_birth" timestamptz;</code>。</p>
<hr>
<h3 id="4-场景三重命名列关键属性"><a class="header" href="#4-场景三重命名列关键属性">4. 场景三：重命名列（关键属性）</a></h3>
<p><strong>注意</strong>：如果你直接改代码里的变量名，SeaORM 会认为你“删了一个旧列，加了一个新列”。要实现真正的“改名”，需要使用 <code>renamed_from</code>。</p>
<ul>
<li><strong>代码示例</strong>:</li>
</ul>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,

    // 将数据库中的 "user_name" 改名为 "login_name"
    #[sea_orm(renamed_from = "user_name")] 
    pub login_name: String,
}

<span class="boring">}</span></code></pre>
<p><strong>结果</strong>：启动后，Postgres 会执行 <code>ALTER TABLE "user" RENAME COLUMN "user_name" TO "login_name";</code>。</p>
<h3 id="5-场景四添加删除索引"><a class="header" href="#5-场景四添加删除索引">5. 场景四：添加/删除索引</a></h3>
<p>通过属性标签控制索引的生命周期。</p>
<ul>
<li><strong>代码示例</strong>:</li>
</ul>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,

    #[sea_orm(unique)] // 添加这一行
    pub email: String,
}

<span class="boring">}</span></code></pre>
<p><strong>结果</strong>：</p>
<ul>
<li><strong>添加时</strong>：执行 <code>CREATE UNIQUE INDEX "idx-user-email" ON "user" ("email");</code>。</li>
<li><strong>删除 <code>#[sea_orm(unique)]</code> 时</strong>：执行 <code>DROP INDEX "idx-user-email";</code>。</li>
</ul>
<h3 id="6-进阶在迁移脚本中使用-schemabuilder"><a class="header" href="#6-进阶在迁移脚本中使用-schemabuilder">6. 进阶：在迁移脚本中使用 SchemaBuilder</a></h3>
<p>如果你不想在 <code>main.rs</code> 里全自动同步，而是在特定的 Migration 里使用这个功能，可以这样做：</p>
<ul>
<li><strong>代码示例</strong>:</li>
</ul>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
impl MigrationTrait for Migration {
    async fn up(&amp;self, manager: &amp;SchemaManager) -&gt; Result&lt;(), DbErr&gt; {
        let db = manager.get_connection();

        // 注册并直接应用，不需要手动写一长串 ColumnDef
        db.get_schema_builder()
            .register(entity::user::Entity)
            .register(entity::post::Entity)
            .apply(db) // apply 是强制执行创建，sync 是智能对比
            .await
    }
}

<span class="boring">}</span></code></pre>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="curd"><a class="header" href="#curd">CURD</a></h1>
<p>我们将使用这个基本模式进行演示：</p>
<ul>
<li>cake 一对多 fruit</li>
<li>cake 多对多 filling</li>
<li>cake_filling 是 cake 和 filling 之间的连接表</li>
</ul>
<p><img src="images/基础模式.png" alt="alt text"></p>
<hr>
<h2 id="数据查询"><a class="header" href="#数据查询">数据查询</a></h2>
<h3 id="1-基础查询通过主键获取"><a class="header" href="#1-基础查询通过主键获取">1. 基础查询：通过主键获取</a></h3>
<p>这是最简单的查询方式。SeaORM 会自动生成 <code>WHERE id = ?</code> 语句。</p>
<ul>
<li><strong><code>find_by_id(id)</code></strong>: 根据主键查找。如果是复合主键，传入元组, eg: <code>Cake::find_by_id(1).one(db).await?</code>。</li>
<li><strong><code>.one(db)</code></strong>: 期待返回 0 或 1 条数据。结果会被包装在 <code>Option&lt;Model&gt;</code> 中, eg: <code>let model: Option&lt;cake::Model&gt; = ...</code>。</li>
</ul>
<pre><code class="language-rust ignore">// 查询主键为 1 的蛋糕
let cheese: Option&lt;cake::Model&gt; = Cake::find_by_id(1).one(db).await?;
// 查询复合主键 (6, 8) 的关联记录
let link: Option&lt;cake_filling::Model&gt; = CakeFilling::find_by_id((6, 8)).one(db).await?;</code></pre>
<h3 id="2-条件查询与排序"><a class="header" href="#2-条件查询与排序">2. 条件查询与排序</a></h3>
<p>当需要更复杂的过滤逻辑时，使用 <code>filter</code> 和 <code>order_by</code>。</p>
<ul>
<li><strong><code>find()</code></strong>: 开启查询构造器，默认查询所有列, eg: <code>Cake::find()</code>。</li>
<li><strong><code>.filter(condition)</code></strong>: 添加过滤条件（如包含、等于、大于等）, eg: <code>.filter(cake::Column::Name.contains("chocolate"))</code>。</li>
<li><strong><code>.order_by_asc / .order_by_desc</code></strong>: 设置排序规则, eg: <code>.order_by_asc(cake::Column::Name)</code>。</li>
<li><strong><code>.all(db)</code></strong>: 获取所有匹配的结果，返回 <code>Vec&lt;Model&gt;</code>, eg: <code>let cakes: Vec&lt;cake::Model&gt; = ...</code>。</li>
</ul>
<pre><code class="language-rust ignore">let chocolate_cakes: Vec&lt;cake::Model&gt; = Cake::find()
    .filter(cake::Column::Name.contains("chocolate")) // 名字包含 chocolate
    .order_by_asc(cake::Column::Name)                // 按名字升序
    .all(db)
    .await?;</code></pre>
<hr>
<h3 id="3-关联查询loading-related-models"><a class="header" href="#3-关联查询loading-related-models">3. 关联查询（Loading Related Models）</a></h3>
<p>SeaORM 提供了三种方式处理表与表之间的关联查询：</p>
<h4 id="a-延迟加载-lazy-loading"><a class="header" href="#a-延迟加载-lazy-loading">A. 延迟加载 (Lazy Loading)</a></h4>
<p>先查主表，需要时再查关联表。<strong>优点</strong>：逻辑清晰；<strong>缺点</strong>：会有多次数据库往返（N+1 问题）。</p>
<pre><code class="language-rust ignore">let cake = Cake::find_by_id(1).one(db).await?.unwrap();
// 仅在需要时去查关联的 fruit
let fruits: Vec&lt;fruit::Model&gt; = cake.find_related(Fruit).all(db).await?;</code></pre>
<h4 id="b-预加载-eager-loading---join"><a class="header" href="#b-预加载-eager-loading---join">B. 预加载 (Eager Loading - Join)</a></h4>
<p>使用 SQL 的 <code>JOIN</code> 一次性查出所有数据。</p>
<ul>
<li><strong><code>find_also_related</code></strong>: 用于 1-1 关系，返回元组 <code>(Model, Option&lt;RelatedModel&gt;)</code>。</li>
<li><strong><code>find_with_related</code></strong>: 用于 1-N 或 M-N 关系，返回 <code>Vec&lt;(Model, Vec&lt;RelatedModel&gt;)&gt;</code>。</li>
</ul>
<pre><code class="language-rust ignore">// 一次性查出蛋糕及其对应的水果（1-N）
let cake_with_fruits: Vec&lt;(cake::Model, Vec&lt;fruit::Model&gt;)&gt; = Cake::find()
    .find_with_related(Fruit)
    .all(db)
    .await?;</code></pre>
<h4 id="c-模型加载器-model-loader"><a class="header" href="#c-模型加载器-model-loader">C. 模型加载器 (Model Loader)</a></h4>
<p>如果你已经有一堆主表数据，想批量补全它们的关联项，<code>Loader</code> 比 <code>JOIN</code> 更节省带宽。</p>
<pre><code class="language-rust ignore">let cakes: Vec&lt;cake::Model&gt; = Cake::find().all(db).await?;
// 批量加载所有蛋糕的配料 (M-N)，SeaORM 会自动处理中间表
let fillings: Vec&lt;Vec&lt;filling::Model&gt;&gt; = cakes.load_many(Filling, db).await?;</code></pre>
<h3 id="4-分页查询-pagination"><a class="header" href="#4-分页查询-pagination">4. 分页查询 (Pagination)</a></h3>
<p>处理大量数据时，必须分页。</p>
<ul>
<li><strong><code>.paginate(db, page_size)</code></strong>: 将查询转为分页器, eg: <code>.paginate(db, 50)</code>。</li>
<li><strong><code>.fetch_and_next()</code></strong>: 获取当前页数据并指向下一页。</li>
<li><strong>游标分页 (Cursor Pagination)</strong>: 基于列值（如 ID）的翻页，性能远高于传统的 <code>OFFSET</code> 分页，适合大数据量或无限滚动界面。</li>
</ul>
<pre><code class="language-rust ignore">// 游标分页：获取 ID &gt; 1 的前 10 条数据
let mut cursor = Cake::find().cursor_by(cake::Column::Id);
cursor.after(1);
let first_pages = cursor.first(10).all(db).await?;</code></pre>
<h3 id="5-部分模型查询-partial-model"><a class="header" href="#5-部分模型查询-partial-model">5. 部分模型查询 (Partial Model)</a></h3>
<p>如果你只需要表中的几个字段（例如用户列表只需姓名，不需要加密密码），使用 <code>PartialModel</code>。</p>
<ul>
<li><strong><code>#[derive(DerivePartialModel)]</code></strong>: 定义一个只包含部分字段的结构体。</li>
<li><strong><code>.into_partial_model()</code></strong>: 告诉 SeaORM 只生成查询这些字段的 SQL，减少网络传输。</li>
</ul>
<pre><code class="language-rust ignore">#[derive(DerivePartialModel)]
#[sea_orm(entity = "cake::Entity")]
struct CakeName {
    name: String,
}
let names: Vec&lt;CakeName&gt; = Cake::find()
    .into_partial_model()
    .all(db)
    .await?;
// 生成的 SQL: SELECT "cake"."name" FROM "cake"</code></pre>
<hr>
<p>在 SeaORM 中，如果你想对数据库进行“写”操作（插入、更新、删除），你必须理解 <strong>ActiveModel</strong> 和它的核心组件 <strong>ActiveValue</strong>。</p>
<p>这是 SeaORM 最精妙的设计：它不只是存储数据，还存储了数据的<strong>状态</strong>（这个字段改没改？要不要存入数据库？）。</p>
<hr>
<h2 id="activemodel"><a class="header" href="#activemodel">ActiveModel</a></h2>
<h3 id="1-activevalue字段的三种状态"><a class="header" href="#1-activevalue字段的三种状态">1. ActiveValue：字段的三种状态</a></h3>
<p>每个字段在 <code>ActiveModel</code> 中都被包装成一个 <code>ActiveValue</code> 枚举。它决定了生成 SQL 时如何处理该字段。</p>
<ul>
<li>
<p><code>ActiveValue::Set(V)</code>：<strong>手动设置</strong>。该字段会被包含在 <code>INSERT</code> 或 <code>UPDATE</code> 语句中。</p>
<ul>
<li>eg: <code>name: Set("Apple".to_owned())</code>  SQL 中会出现 <code>"name" = 'Apple'</code>。</li>
</ul>
</li>
<li>
<p><code>ActiveValue::Unchanged(V)</code>：<strong>未改变</strong>。通常是刚从数据库查出来的原始值。它<strong>不会</strong>出现在 <code>UPDATE</code> 的 <code>SET</code> 子句中，但会作为主键用于 <code>WHERE</code> 条件。</p>
<ul>
<li>eg: 从数据库查出 ID 为 1 的数据，<code>id</code> 状态就是 <code>Unchanged(1)</code>。</li>
</ul>
</li>
<li>
<p><code>ActiveValue::NotSet</code>：<strong>未定义/忽略</strong>。该字段完全不参与 SQL 语句。</p>
<ul>
<li>eg: 插入时 <code>id: NotSet</code>  让 PostgreSQL 的 <code>SERIAL</code> 自动生成 ID。</li>
<li>eg: 更新时 <code>name: NotSet</code>  数据库里的原名字保持不变。</li>
</ul>
</li>
</ul>
<h3 id="2-activemodel可操作的表单"><a class="header" href="#2-activemodel可操作的表单">2. ActiveModel：可操作的“表单”</a></h3>
<p><code>Model</code> 是只读的快照，而 <code>ActiveModel</code> 是一个可以修改的“表单”。</p>
<ul>
<li><code>model.into()</code>: 将查询到的 <strong>Model</strong> 转换为 <strong>ActiveModel</strong>，此时所有字段状态默认为 <code>Unchanged</code>, eg: <code>let active_model: cake::ActiveModel = model.into();</code>。</li>
<li><code>is_changed()</code>: 检查 <code>ActiveModel</code> 中是否有任何字段被 <code>Set</code> 过, eg: <code>if fruit.is_changed() { ... }</code>。</li>
<li><code>set_if_not_equal()</code>: 仅当新值与旧值不同时才执行 <code>Set</code>，否则保持 <code>Unchanged</code>。这能极大减少不必要的数据库更新操作。</li>
</ul>
<h3 id="3-代码演示与用法说明"><a class="header" href="#3-代码演示与用法说明">3. 代码演示与用法说明</a></h3>
<h4 id="场景-a插入数据利用-notset"><a class="header" href="#场景-a插入数据利用-notset">场景 A：插入数据（利用 <code>NotSet</code>）</a></h4>
<p>在 PostgreSQL 中，我们通常希望 ID 由数据库自增生成。</p>
<pre><code class="language-rust ignore">let orange = fruit::ActiveModel {
    id: ActiveValue::NotSet, // 不设 ID，让 Postgres 自动生成
    name: ActiveValue::Set("Orange".to_owned()),
    cake_id: ActiveValue::Set(None), // 显式设置为 NULL
};
// 生成 SQL: INSERT INTO "fruit" ("name", "cake_id") VALUES ('Orange', NULL)
</code></pre>
<h4 id="场景-b部分更新更新某几个字段"><a class="header" href="#场景-b部分更新更新某几个字段">场景 B：部分更新（更新某几个字段）</a></h4>
<p>假设你只想改名字，不想动其他 20 个字段。</p>
<pre><code class="language-rust ignore">let update_fruit = fruit::ActiveModel {
    id: ActiveValue::Unchanged(1), // WHERE 条件
    name: ActiveValue::Set("New Apple".to_owned()), // SET 字段
    cake_id: ActiveValue::NotSet, // 忽略此字段，SQL 里不会出现
};
// 生成 SQL: UPDATE "fruit" SET "name" = 'New Apple' WHERE "id" = 1
</code></pre>
<h3 id="4-转换回-model-try_into_model"><a class="header" href="#4-转换回-model-try_into_model">4. 转换回 Model (try_into_model)</a></h3>
<p>当你完成修改并想拿到最终的实体数据时，可以将 <code>ActiveModel</code> 转回 <code>Model</code>。</p>
<ul>
<li><code>active_model.try_into_model()</code>: 尝试转换。如果字段中有 <code>NotSet</code>，转换会失败（报错 <code>AttrNotSet</code>）, eg: <code>let model = active_model.try_into_model()?;</code>。</li>
<li><code>ActiveModel::default_values()</code>: 如果你想快速生成一个用于测试的模型，可以使用此方法给所有 <code>NotSet</code> 字段填充默认值（如空字符串或 0）。</li>
</ul>
<hr>
<h2 id="insert"><a class="header" href="#insert">Insert</a></h2>
<p>在掌握了 <code>ActiveModel</code> 的状态（Set, Unchanged, NotSet）之后，来到了**“写入数据”**的实战阶段。在 PostgreSQL 中，SeaORM 的插入操作非常高效，特别是它对 <code>RETURNING</code> 语句的原生支持。</p>
<p>以下是关于 <strong>Insert（插入）</strong> 操作的详细说明与代码演示：</p>
<h3 id="1-插入单条数据-insert-one"><a class="header" href="#1-插入单条数据-insert-one">1. 插入单条数据 (Insert One)</a></h3>
<p>有两种方式处理单条插入，区别在于你想要获取什么结果：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>方法</th><th>返回值</th><th>场景说明</th></tr>
</thead>
<tbody>
<tr><td><strong><code>active_model.insert(db)</code></strong></td><td><code>Model</code></td><td><strong>最常用</strong>。返回一个完整的、带有数据库生成的 ID 和默认值的模型。</td></tr>
<tr><td><strong><code>Entity::insert(am).exec(db)</code></strong></td><td><code>InsertResult</code></td><td>仅返回最后插入的 ID（<code>last_insert_id</code>），性能稍高但数据不完整。</td></tr>
</tbody>
</table>
</div>
<p><strong>代码演示：</strong></p>
<pre><code class="language-rust ignore">// 方式 A：拿到完整的 Model（Postgres 内部会自动使用 RETURNING）
let pear = fruit::ActiveModel {
    name: Set("Pear".to_owned()),
    ..Default::default()
};
let model: fruit::Model = pear.insert(db).await?; 
println!("新水果的 ID 是: {}", model.id);
// 方式 B：只拿 ID
let res = Fruit::insert(pear).exec(db).await?;
println!("最后插入的 ID 是: {}", res.last_insert_id);</code></pre>
<h3 id="2-批量插入-insert-many"><a class="header" href="#2-批量插入-insert-many">2. 批量插入 (Insert Many)</a></h3>
<ul>
<li><strong>用法</strong>: 传入一个迭代器（如 <code>Vec</code> 或数组）。</li>
<li><strong>安全提示</strong>: 如果传入空列表，默认会报错。你可以使用 <code>.on_empty_do_nothing()</code> 来优雅地处理空数据。</li>
</ul>
<p><strong>代码演示：</strong></p>
<pre><code class="language-rust ignore">let fruits = vec![
    fruit::ActiveModel { name: Set("Apple".into()), ..Default::default() },
    fruit::ActiveModel { name: Set("Orange".into()), ..Default::default() },
];
// 执行批量插入
let res = Fruit::insert_many(fruits).exec(db).await?;</code></pre>
<h3 id="3-冲突处理-on-conflict--upsert"><a class="header" href="#3-冲突处理-on-conflict--upsert">3. 冲突处理 (On Conflict / Upsert)</a></h3>
<p>这是 PostgreSQL 的强项。当插入的数据违反唯一约束（比如 ID 重复）时，你可以选择“无视”或“更新”。</p>
<ul>
<li><strong><code>do_nothing()</code></strong>: 冲突时什么都不做。</li>
<li><strong><code>update_column()</code></strong>: 冲突时更新指定列（即 Upsert 操作）。</li>
</ul>
<p><strong>代码演示：</strong></p>
<pre><code class="language-rust ignore">let orange = cake::ActiveModel {
    id: Set(2),
    name: Set("Orange".to_owned()),
};
// 如果名字冲突，就更新名字
cake::Entity::insert(orange)
    .on_conflict(
        sea_query::OnConflict::column(cake::Column::Name)
            .update_column(cake::Column::Name)
            .to_owned()
    )
    .exec(db)
    .await?;</code></pre>
<blockquote>
<p><strong>注意</strong>：如果 <code>ON CONFLICT</code> 导致没有新行被插入或更新，SeaORM 默认会抛出 <code>DbErr::RecordNotInserted</code> 错误。如果你希望在这种情况下也返回 <code>Ok</code>，记得调用 <code>.do_nothing()</code> 方法。</p>
</blockquote>
<h3 id="4-postgresql-特色返回插入的模型-returning"><a class="header" href="#4-postgresql-特色返回插入的模型-returning">4. PostgreSQL 特色：返回插入的模型 (Returning)</a></h3>
<p>在 PostgreSQL 中，你可以在插入的同时要求数据库把所有字段（包括数据库自动生成的字段）直接返回，避免再次查询。</p>
<ul>
<li><strong><code>exec_with_returning</code></strong>: 返回插入后的 <code>Model</code>（单条）或 <code>Vec&lt;Model&gt;</code>（多条）。</li>
<li><strong><code>exec_with_returning_keys</code></strong>: 仅返回所有插入行的主键。</li>
</ul>
<p><strong>代码演示：</strong></p>
<pre><code class="language-rust ignore">// 批量插入并直接拿到所有生成好的 Model
let inserted_models: Vec&lt;cake::Model&gt; = cake::Entity::insert_many(vec![am1, am2])
    .exec_with_returning(db)
    .await?;
</code></pre>
<hr>
<h2 id="save"><a class="header" href="#save">Save</a></h2>
<p>在掌握了 <code>Insert</code> 和 <code>ActiveValue</code> 的状态后，<code>save</code> 方法是 SeaORM 提供的一个非常实用的**“智能助手”**。它能根据主键的状态，自动帮你判断是该执行 <code>INSERT</code> 还是 <code>UPDATE</code>。</p>
<p>以下是关于 <strong>Save</strong> 操作的详细说明与代码演示：</p>
<h3 id="1-核心逻辑它是如何判断的"><a class="header" href="#1-核心逻辑它是如何判断的">1. 核心逻辑：它是如何判断的？</a></h3>
<p><code>save</code> 方法的逻辑非常直观，它完全依赖于 <strong>主键（Primary Key）</strong> 的状态：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>主键状态 (ActiveValue)</th><th>对应操作</th><th>背后原因</th></tr>
</thead>
<tbody>
<tr><td><strong><code>NotSet</code></strong></td><td><strong>INSERT</strong></td><td>数据库中还没有这个 ID，说明是新数据。</td></tr>
<tr><td><strong><code>Set</code></strong> 或 <strong><code>Unchanged</code></strong></td><td><strong>UPDATE</strong></td><td>已经有了明确的主键值，说明数据已存在，执行更新。</td></tr>
</tbody>
</table>
</div>
<h3 id="2-代码演示从新增到修改"><a class="header" href="#2-代码演示从新增到修改">2. 代码演示：从“新增”到“修改”</a></h3>
<p>这个方法最强大的地方在于，你可以对同一个 <code>ActiveModel</code> 连续调用 <code>save</code>，它会处理好一切。</p>
<pre><code class="language-rust ignore">use sea_orm::ActiveValue::{NotSet, Set};

// --- 第一阶段：插入 ---
let mut banana = fruit::ActiveModel {
    id: NotSet, // 主键是 NotSet，准备插入
    name: Set("Banana".to_owned()),
    ..Default::default()
};
// 执行 save，此时内部运行的是 INSERT
// 注意：PostgreSQL 会利用 RETURNING 自动把生成的 ID 填回 banana 里
let mut banana: fruit::ActiveModel = banana.save(db).await?; 
println!("插入成功，生成的 ID 为: {:?}", banana.id); 

// --- 第二阶段：更新 ---
// 修改模型中的值
banana.name = Set("Banana Mongo".to_owned());

// 再次执行 save
// 此时主键 id 是从数据库查回来的（状态为 Unchanged），所以内部运行的是 UPDATE
let banana: fruit::ActiveModel = banana.save(db).await?;
println!("更新成功！");</code></pre>
<h3 id="3-深度解析与注意事项"><a class="header" href="#3-深度解析与注意事项">3. 深度解析与注意事项</a></h3>
<h4 id="a-自动刷新数据"><a class="header" href="#a-自动刷新数据">A. 自动刷新数据</a></h4>
<p>当你调用 <code>save</code> 后，它会返回一个新的 <code>ActiveModel</code>。</p>
<ul>
<li>在 <strong>PostgreSQL</strong> 中，SeaORM 会在 SQL 末尾加上 <code>RETURNING *</code>。</li>
<li>这意味着插入/更新后，数据库中任何自动生成的字段（比如 <code>created_at</code> 时间戳、自增 ID、触发器修改的值）都会<strong>实时同步</strong>回你返回的那个 <code>ActiveModel</code> 中。</li>
</ul>
<h4 id="b-与-insert-方法的区别"><a class="header" href="#b-与-insert-方法的区别">B. 与 <code>insert</code> 方法的区别</a></h4>
<ul>
<li><strong><code>insert()</code></strong>: 只能执行插入。如果主键已存在，会直接报错。返回的是 <code>Model</code>（只读）。</li>
<li><strong><code>save()</code></strong>: 具有判断能力。返回的是 <code>ActiveModel</code>（可继续编辑）。</li>
</ul>
<hr>
<h2 id="update"><a class="header" href="#update">Update</a></h2>
<p>更新操作（Update）在 SeaORM 中非常灵活。它依赖于我们之前提到的 <code>ActiveModel</code> 状态机：只有被标记为 <code>Set</code>（已改变）的字段，才会出现在生成的 <code>UPDATE</code> SQL 语句中。</p>
<p>以下是关于 <strong>Update</strong> 操作的详细拆解与代码演示：</p>
<hr>
<h3 id="1-更新单条记录-update-one"><a class="header" href="#1-更新单条记录-update-one">1. 更新单条记录 (Update One)</a></h3>
<p>通常的流程是：先查询出数据（<code>Model</code>），修改后存回数据库。</p>
<ul>
<li><strong><code>model.into()</code></strong>: 将查询到的 <code>Model</code> 转换为 <code>ActiveModel</code>。此时所有字段状态均为 <code>Unchanged</code>。</li>
<li><strong><code>.update(db)</code></strong>: 仅更新那些状态为 <code>Set</code> 的字段, eg: <code>active_model.update(db).await?</code>。</li>
<li><strong><code>.reset_all()</code></strong>: 如果你想强制数据库覆盖所有字段（即使值没变），可以使用 <code>reset_all</code> 将所有字段强制转为 <code>Set</code> 状态。</li>
</ul>
<pre><code class="language-rust ignore">// 1. 获取模型
let pear: Option&lt;fruit::Model&gt; = Fruit::find_by_id(28).one(db).await?;
let mut pear: fruit::ActiveModel = pear.unwrap().into();

// 2. 修改属性（状态变为 Set）
pear.name = Set("Sweet pear".to_owned());

// 3. 执行更新
// SQL: UPDATE "fruit" SET "name" = 'Sweet pear' WHERE "id" = 28
let pear: fruit::Model = pear.update(db).await?;</code></pre>
<h3 id="2-批量更新-update-many"><a class="header" href="#2-批量更新-update-many">2. 批量更新 (Update Many)</a></h3>
<p>当你需要根据特定条件（如“给所有苹果分类”）进行更新时，不需要先查询出每一个对象。</p>
<ul>
<li><strong><code>.set(active_model)</code></strong>: 使用一个 <code>ActiveModel</code> 模板来定义要更新的字段和值。</li>
<li><strong><code>.col_expr(col, expr)</code></strong>: 使用表达式进行更新，比如将某列设为固定值, eg: <code>.col_expr(Column::Price, Expr::value(10.0))</code>。</li>
<li><strong><code>.filter()</code></strong>: 限制更新的范围，否则会更新全表。</li>
</ul>
<pre><code class="language-rust ignore">// 将所有名字包含 "Apple" 的水果的 cake_id 改为 1
let update_res: UpdateResult = Fruit::update_many()
    .col_expr(fruit::Column::CakeId, Expr::value(1))
    .filter(fruit::Column::Name.contains("Apple"))
    .exec(db)
    .await?;

println!("更新了 {} 行数据", update_res.rows_affected);</code></pre>
<h3 id="3-postgresql-专有功能返回更新后的数据"><a class="header" href="#3-postgresql-专有功能返回更新后的数据">3. PostgreSQL 专有功能：返回更新后的数据</a></h3>
<p>这是 <strong>PostgreSQL</strong> 的一大杀器。在执行批量更新的同时，你可以直接拿回受影响行的最新数据。</p>
<ul>
<li><strong><code>exec_with_returning</code></strong>: 更新并返回 <code>Vec&lt;Model&gt;</code>，让你省去一次额外的查询, eg: <code>Fruit::update_many()...exec_with_returning(db).await?</code>。</li>
<li><strong><code>eq_any</code> (Postgres Only)</strong>: 2.0 版本新增的快捷操作，对应 SQL 中的 <code>= ANY</code>，性能优于多次 <code>OR</code>。</li>
</ul>
<pre><code class="language-rust ignore">// 批量更新并直接获取更新后的完整模型列表
let updated_fruits: Vec&lt;fruit::Model&gt; = Fruit::update_many()
    .col_expr(fruit::Column::CakeId, Expr::value(1))
    .filter(fruit::Column::Name.contains("Apple"))
    .exec_with_returning(db)
    .await?;
assert_eq!(updated_fruits[0].cake_id, Some(1));</code></pre>
<h3 id="4-字段状态的强制重置"><a class="header" href="#4-字段状态的强制重置">4. 字段状态的强制重置</a></h3>
<p>有时候你可能希望确保某些字段被写入数据库，即便在 Rust 逻辑中它们看起来没变：</p>
<ul>
<li><strong><code>pear.reset(fruit::Column::Name)</code></strong>: 将 <code>name</code> 列标记为“脏（dirty）”，强制包含在 UPDATE 语句中。</li>
<li><strong><code>pear.not_set(fruit::Column::Name)</code></strong>: 将 <code>name</code> 列从 UPDATE 语句中彻底剔除，无论它之前是什么状态。</li>
</ul>
<p><strong>核心总结：</strong></p>
<ul>
<li><strong>单条更新</strong>：<code>model.into() -&gt; set -&gt; update()</code>。</li>
<li><strong>条件批量更新</strong>：<code>update_many().set().filter().exec()</code>。</li>
<li><strong>Postgres 特权</strong>：<code>exec_with_returning()</code>。</li>
</ul>
<p><strong>恭喜你！到这里，你已经完整学习了 CRUD 的每一个环节（增、删、改、查、同步、JSON、原生 SQL）。你已经准备好构建完整的 Rust 后端了。你想了解如何处理复杂的“关联关系 (Relations)”或者“连接池配置”吗？</strong></p>
<h2 id="delete"><a class="header" href="#delete">Delete</a></h2>
<p>在掌握了“增、改、查”之后，我们最后来看**删除（Delete）**操作。在 SeaORM 中，删除同样可以针对单条记录或多条记录执行，而且针对 <strong>PostgreSQL</strong>，它还支持极其方便的 <code>RETURNING</code> 功能。</p>
<p>以下是关于 <strong>Delete</strong> 操作的详细说明与代码演示：</p>
<hr>
<h3 id="1-删除单条记录-delete-one"><a class="header" href="#1-删除单条记录-delete-one">1. 删除单条记录 (Delete One)</a></h3>
<p>删除单条记录有两种主要方式，取决于你是否已经将数据查询到了内存中。</p>
<ul>
<li><strong>通过 Model 实例删除</strong>: 如果你已经有一个查询出来的 <code>Model</code>，可以直接调用 <code>.delete()</code>。这在需要先检查数据权限、再决定是否删除的业务场景中非常有用, eg: <code>model.delete(db).await?</code>。</li>
<li><strong>根据主键直接删除</strong>: 无需先查询数据，直接发送 <code>DELETE</code> 指令。这是最直接、性能最高的方式, eg: <code>Fruit::delete_by_id(1).exec(db).await?</code>。</li>
</ul>
<pre><code class="language-rust ignore">use sea_orm::entity::ModelTrait;
// 场景 A：先查后删（适合需要前置逻辑检查的情况）
let orange: Option&lt;fruit::Model&gt; = Fruit::find_by_id(30).one(db).await?;
if let Some(model) = orange {
    let res: DeleteResult = model.delete(db).await?;
    assert_eq!(res.rows_affected, 1);
}
// 场景 B：直接删（已知 ID，追求效率）
let res: DeleteResult = Fruit::delete_by_id(38).exec(db).await?;</code></pre>
<h3 id="2-批量删除-delete-many"><a class="header" href="#2-批量删除-delete-many">2. 批量删除 (Delete Many)</a></h3>
<p>你可以像构建查询一样，通过 <code>filter</code> 来定义要删除的数据范围。</p>
<ul>
<li><strong><code>delete_many()</code></strong>: 开启批量删除构造器，配合 <code>filter</code> 限制范围。如果不加 <code>filter</code>，它会尝试删除表中的所有行, eg: <code>fruit::Entity::delete_many().filter(...).exec(db).await?</code>。</li>
</ul>
<pre><code class="language-rust ignore">// 批量删除名字包含 "Orange" 的水果
let res: DeleteResult = fruit::Entity::delete_many()
    .filter(fruit::Column::Name.contains("Orange"))
    .exec(db)
    .await?;
println!("删除了 {} 行记录", res.rows_affected);</code></pre>
<h3 id="3-postgresql-特色返回被删除的数据-returning"><a class="header" href="#3-postgresql-特色返回被删除的数据-returning">3. PostgreSQL 特色：返回被删除的数据 (Returning)</a></h3>
<p>作为 <strong>PostgreSQL</strong> 用户，这是一个非常强大的功能。在执行删除的同时，数据库可以将被删除的那一行数据完整地返回给 Rust。这在处理“回收站”功能或需要清理关联缓存时非常有用。</p>
<ul>
<li><strong><code>exec_with_returning</code></strong>: 删除并返回被删掉的模型（单条或多条）, eg: <code>Entity::delete_many().filter(...).exec_with_returning(db).await?</code>。</li>
</ul>
<pre><code class="language-rust ignore">// 删除 ID 为 3 的记录，并直接拿到被删除的数据内容
let deleted_item: Option&lt;fruit::Model&gt; = fruit::Entity::delete(fruit::ActiveModel {
        id: Set(3),
        ..Default::default()
    })
    .exec_with_returning(db)
    .await?;

// 批量删除并拿到所有被删掉的模型列表
let deleted_list: Vec&lt;order::Model&gt; = order::Entity::delete_many()
    .filter(order::Column::CustomerId.eq(22))
    .exec_with_returning(db)
    .await?;
</code></pre>
<h3 id="4-常用-api-与结果说明"><a class="header" href="#4-常用-api-与结果说明">4. 常用 API 与结果说明</a></h3>
<ul>
<li>
<p><strong><code>DeleteResult</code></strong>: 执行 <code>exec()</code> 后返回的结果对象。</p>
</li>
<li>
<p><code>.rows_affected</code>: 告诉你数据库里实际上有多少行被删除了。</p>
</li>
<li>
<p><strong><code>exec_with_returning()</code></strong>: 针对 Postgres/SQLite 的高级 API，返回 <code>Option&lt;Model&gt;</code> 或 <code>Vec&lt;Model&gt;</code>。</p>
</li>
</ul>
<hr>
<h2 id="json"><a class="header" href="#json">JSON</a></h2>
<p>在现代 Web 开发中，数据库与前端之间的数据传递几乎全是 JSON。SeaORM 提供了非常丝滑的 JSON 支持，让你能够跳过复杂的结构体映射，直接在“数据库”与“JSON”之间快速转换。</p>
<p>这对 <strong>PostgreSQL</strong> 用户尤其有用，因为 Postgres 对 JSONB 的支持非常强大。</p>
<p>以下是关于 <strong>JSON</strong> 操作的详细说明与代码演示：</p>
<hr>
<h3 id="1-将查询结果直接转为-json-select-json"><a class="header" href="#1-将查询结果直接转为-json-select-json">1. 将查询结果直接转为 JSON (Select JSON)</a></h3>
<p>当你只想把数据从数据库查出来直接丢给前端，而不需要在 Rust 里处理业务逻辑时，使用 <code>.into_json()</code> 可以显著简化代码。</p>
<ul>
<li><strong><code>.into_json()</code></strong>: 将查询构造器切换到 JSON 模式。返回的结果不再是 <code>Model</code>，而是 <code>serde_json::Value</code>, eg: <code>Cake::find().into_json().all(db).await?</code>。</li>
<li><strong>兼容性</strong>: 支持 <code>one()</code>、<code>all()</code> 以及分页 <code>paginate()</code>。</li>
</ul>
<p><strong>代码演示：</strong></p>
<pre><code class="language-rust ignore">// 查询单个蛋糕并直接以 JSON 格式返回
let cake: Option&lt;serde_json::Value&gt; = Cake::find_by_id(1)
    .into_json()
    .one(db)
    .await?;
// 带有过滤和排序的 JSON 列表查询
let cakes: Vec&lt;serde_json::Value&gt; = Cake::find()
    .filter(cake::Column::Name.contains("chocolate"))
    .into_json()
    .all(db)
    .await?;</code></pre>
<h3 id="2-从原生-sql-获取-json"><a class="header" href="#2-从原生-sql-获取-json">2. 从原生 SQL 获取 JSON</a></h3>
<p>当你编写复杂的聚合 SQL（例如 <code>GROUP BY</code> 或多表联查）时，结果集往往不符合任何现有的 <code>Model</code>。这时可以用 <code>JsonValue</code> 来承接结果。</p>
<ul>
<li><strong><code>JsonValue::find_by_statement</code></strong>: 执行原始 SQL 语句并将结果集直接映射为 JSON 数组, eg: <code>JsonValue::find_by_statement(sql).all(db).await?</code>。</li>
</ul>
<pre><code class="language-rust ignore">let sql = Statement::from_sql_and_values(
    DbBackend::Postgres,
    r#"SELECT "name", COUNT(*) FROM "cake" GROUP BY "name""#,
    [],
);
let result: Vec&lt;serde_json::Value&gt; = JsonValue::find_by_statement(sql)
    .all(db)
    .await?;</code></pre>
<h3 id="3-将输入-json-转换为-activemodel"><a class="header" href="#3-将输入-json-转换为-activemodel">3. 将输入 JSON 转换为 ActiveModel</a></h3>
<p>这是处理前端提交表单（POST/PUT 请求）的神器。你可以直接把前端传来的 JSON 映射到数据库模型中执行保存。</p>
<h4 id="a-从-json-创建新模型-from_json"><a class="header" href="#a-从-json-创建新模型-from_json">A. 从 JSON 创建新模型 (<code>from_json</code>)</a></h4>
<p>如果你要处理一个“新增”请求，可以使用 <code>from_json</code>。</p>
<ul>
<li><strong>逻辑</strong>：JSON 中存在的字段会被设为 <code>Set</code>，不存在的字段会被设为 <code>NotSet</code>（方便触发数据库默认值）, eg: <code>ActiveModel::from_json(json_data)?</code>。</li>
</ul>
<h4 id="b-用-json-更新现有模型-set_from_json"><a class="header" href="#b-用-json-更新现有模型-set_from_json">B. 用 JSON 更新现有模型 (<code>set_from_json</code>)</a></h4>
<p>如果你要处理一个“修改”请求，可以使用 <code>set_from_json</code>。</p>
<ul>
<li><strong>安全保护</strong>：这个方法会<strong>自动忽略</strong> JSON 里的主键 ID，防止前端通过恶意构造 JSON 来修改你的主键, eg: <code>active_model.set_from_json(json_data)?</code>。</li>
</ul>
<pre><code class="language-rust ignore">// 场景：处理新增
let new_fruit = fruit::ActiveModel::from_json(json!({
    "name": "Apple",
}))?; 
// id 此时是 NotSet，Postgres 会自动生成

// 场景：处理部分更新
let mut fruit = fruit::ActiveModel {
    id: Set(1), // 锁定要修改的 ID
    ..Default::default()
};

// 即使 JSON 里写了 "id": 888，set_from_json 也会忽略它，只更新 name
fruit.set_from_json(json!({
    "id": 888, 
    "name": "Super Apple",
    "cake_id": 1,
}))?;</code></pre>
<h3 id="实战避坑指南"><a class="header" href="#实战避坑指南">实战避坑指南</a></h3>
<ul>
<li><strong>字段名映射</strong>：SeaORM 在转换 JSON 时遵循你在 <code>Model</code> 里定义的 <code>rename_all</code> 规则。如果你的 Rust 字段是 <code>first_name</code> 但设置了 <code>camelCase</code> 映射，那么 JSON 里的 Key 必须是 <code>firstName</code> 才能匹配成功。</li>
<li><strong><code>Option&lt;T&gt;</code> 与 Null</strong>：
<ul>
<li>JSON 里的 <code>null</code> 会映射为 <code>ActiveValue::Set(None)</code>。</li>
<li>JSON 里完全<strong>缺失</strong>该字段会映射为 <code>ActiveValue::NotSet</code>。</li>
</ul>
</li>
<li><strong>JSONB 性能</strong>：对于 PostgreSQL 而言，虽然你可以把整个结果转为 JSON 给前端，但如果你需要对 JSON 内部的某个字段进行过滤，建议在 SQL 层面处理（利用 Postgres 的 <code>-&gt;&gt;</code> 操作符），而不是把所有数据拉到内存里再处理。</li>
</ul>
<hr>
<h2 id="原生-sql"><a class="header" href="#原生-sql">原生 SQL</a></h2>
<p>虽然 SeaORM 推荐使用强类型的查询构造器，但有时你必须编写<strong>原生 SQL (Raw SQL)</strong> 来处理复杂的查询或利用 PostgreSQL 的特殊功能（如扩展、窗口函数等）。</p>
<p>SeaORM 2.0 引入了极其方便的 <code>raw_sql!</code> 宏，极大地简化了 SQL 字符串的处理。</p>
<hr>
<h3 id="1-使用-raw_sql-宏查询模型-find-model"><a class="header" href="#1-使用-raw_sql-宏查询模型-find-model">1. 使用 <code>raw_sql!</code> 宏查询模型 (Find Model)</a></h3>
<p>如果你想写 SQL 但依然希望结果被解析为 <code>Model</code> 结构体，可以使用 <code>from_raw_sql</code> 方法。</p>
<ul>
<li><strong><code>raw_sql!</code></strong>: 该宏能自动处理参数绑定。最酷的功能是 <strong><code>({..ids})</code></strong>，它能自动把数组展开为 <code>(?, ?, ?)</code>。</li>
<li><strong>参数绑定</strong>: 使用 <code>{variable}</code> 语法，SeaORM 会安全地将其处理为占位符，防止 SQL 注入。</li>
</ul>
<p><strong>代码演示：</strong></p>
<pre><code class="language-rust ignore">let id = 1;
let ids = vec![1, 2, 3];

// 查询单条并映射回 Model
let cake: Option&lt;cake::Model&gt; = cake::Entity::find()
    .from_raw_sql(raw_sql!(
        Postgres,
        r#"SELECT "cake"."id", "cake"."name" FROM "cake" WHERE "id" = {id}"#
    ))
    .one(&amp;db)
    .await?;

// 使用数组展开功能进行批量查询
let cakes: Vec&lt;cake::Model&gt; = cake::Entity::find()
    .from_raw_sql(raw_sql!(
        Postgres,
        r#"SELECT * FROM "cake" WHERE "id" IN ({..ids})"#
    ))
    .all(&amp;db)
    .await?;</code></pre>
<h3 id="2-查询到自定义结构体"><a class="header" href="#2-查询到自定义结构体">2. 查询到自定义结构体</a></h3>
<p>当你的 SQL 涉及多表联查或计算列时，可以定义一个 <code>FromQueryResult</code> 的结构体来承接数据。</p>
<ul>
<li><strong><code>#[sea_orm(nested)]</code></strong>: 允许你在结构体中嵌套另一个结构体。</li>
<li><strong><code>#[sea_orm(alias = "...")]</code></strong>: 映射 SQL 中的别名到结构体字段。</li>
</ul>
<pre><code class="language-rust ignore">#[derive(FromQueryResult)]
struct CakeWithBakery {
    name: String,
    #[sea_orm(nested)]
    bakery: Option&lt;BakeryInfo&gt;,
}

#[derive(FromQueryResult)]
struct BakeryInfo {
    #[sea_orm(alias = "bakery_name")] // 对应 SQL 里的 AS bakery_name
    name: String,
}

let result = CakeWithBakery::find_by_statement(raw_sql!(
    Postgres,
    r#"SELECT "cake"."name", "bakery"."name" AS "bakery_name"
       FROM "cake"
       LEFT JOIN "bakery" ON "cake"."bakery_id" = "bakery"."id""#
))
.all(db)
.await?;</code></pre>
<h3 id="3-直接执行接口-query--execute"><a class="header" href="#3-直接执行接口-query--execute">3. 直接执行接口 (Query &amp; Execute)</a></h3>
<p>如果你不想映射到任何结构体，只想拿到原始结果或者执行一条不返回数据的指令（如 <code>DROP</code>），可以直接操作 <code>db</code> 连接。</p>
<ul>
<li>**<code>query_one_raw</code> / <code>query_all_raw**</code>: 返回 <code>QueryResult</code> 对象，通过 <code>.try_get</code> 获取特定列的值。</li>
<li><strong><code>execute_raw</code></strong>: 用于执行 <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> 或 DDL，返回影响的行数。</li>
<li><strong><code>execute_unprepared</code></strong>: <strong>(PostgreSQL 常用)</strong> 执行不需要参数绑定的 SQL，例如创建插件。</li>
</ul>
<pre><code class="language-rust ignore">// 执行原始 SQL 并手动取值
let res = db.query_one_raw(Statement::from_string(DbBackend::Postgres, "SELECT name FROM cake WHERE id = 1")).await?;
let name: String = res.unwrap().try_get("", "name")?;

// 执行 DDL
db.execute_raw(Statement::from_string(DbBackend::Postgres, "DROP TABLE IF EXISTS old_table")).await?;

// PostgreSQL 开启扩展专用
db.execute_unprepared("CREATE EXTENSION IF NOT EXISTS citext").await?;</code></pre>
<h3 id="4-调试利器查看-seaorm-生成的-sql"><a class="header" href="#4-调试利器查看-seaorm-生成的-sql">4. 调试利器：查看 SeaORM 生成的 SQL</a></h3>
<p>当你的 <code>filter</code> 结果不如预期时，可以随时查看 SeaORM 到底给数据库发了什么。</p>
<ul>
<li><strong><code>.build(backend).to_string()</code></strong>: 将任何查询转换成对应数据库语法的 SQL 字符串。</li>
</ul>
<pre><code class="language-rust ignore">use sea_orm::{DbBackend, QueryTrait};

let query_sql = cake::Entity::find()
    .filter(cake::Column::Id.eq(1))
    .build(DbBackend::Postgres)
    .to_string();

println!("生成的 SQL 为: {}", query_sql);
// 输出: SELECT "cake"."id", "cake"."name" FROM "cake" WHERE "cake"."id" = 1</code></pre>
<hr>
<h3 id="postgresql实战避坑指南"><a class="header" href="#postgresql实战避坑指南">PostgreSQL实战避坑指南</a></h3>
<ol>
<li><strong>引号问题</strong>: PostgreSQL 对表名和列名是大小写敏感的，建议在原生 SQL 中始终使用双引号 <code>"</code> 包裹，例如 <code>"user"."id"</code>。</li>
<li><strong>占位符一致性</strong>: 虽然 <code>raw_sql!</code> 宏会自动处理，但如果你手动写 <code>Statement</code>，记得 PostgreSQL 的占位符是 <code>$1</code>, <code>$2</code>（SeaORM 会自动帮你处理后端差异，但手动写 SQL 时需留意）。</li>
<li><strong>数组限制</strong>: <code>({..ids})</code> 非常方便，但在 PostgreSQL 中如果数组过大（超过几万个），SQL 语句长度可能会超限，此时建议使用临时表。</li>
</ol>
<p><strong>核心总结：</strong></p>
<ul>
<li><strong>模型映射</strong>：用 <code>find().from_raw_sql()</code>。</li>
<li><strong>动态参数</strong>：用 <code>raw_sql!(Postgres, "...", {val})</code>。</li>
<li><strong>快速执行</strong>：用 <code>execute_unprepared()</code>。</li>
<li><strong>调试</strong>：用 <code>.build(backend).to_string()</code>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="leetcode"><a class="header" href="#leetcode">LeetCode</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="定长滑动窗口"><a class="header" href="#定长滑动窗口">定长滑动窗口</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="定长滑动窗口-1"><a class="header" href="#定长滑动窗口-1">定长滑动窗口</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace-2a3cd908.js"></script>
        <script src="mode-rust-2c9d5c9a.js"></script>
        <script src="editor-16ca416c.js"></script>
        <script src="theme-dawn-4493f9c8.js"></script>
        <script src="theme-tomorrow_night-9dbe62a9.js"></script>

        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
