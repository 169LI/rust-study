<!DOCTYPE HTML>
<html lang="zh-CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust study</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom-7e8a6fc2.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-abfe0e6f.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-2a4c8e05.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust study</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/169li/rust-study" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<p>个人在学习Rust过程中的一些笔记记录:</p>
<ul>
<li>Rust语法基础</li>
<li>Rust算法刷题</li>
<li>…..</li>
</ul>
<p>参考的资料有：</p>
<p><a href="https://course.rs/about-book.html">Rust语言圣经(Rust Course)</a></p>
<p><a href="https://practice-zh.course.rs/why-exercise.html">练习实践</a></p>
<p><a href="https://rust-lang.github.io/api-guidelines/about.html">API编程指南</a></p>
<p><a href="https://rust.sui-book.com/01_basics/01_intro.html">Rust带学</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rust学习"><a class="header" href="#rust学习">Rust学习</a></h1>
<p>学习笔记中可能由于编译器的更新，一些地方可能与现在不一致。</p>
<p>2024年12月31日</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="基础语法"><a class="header" href="#基础语法">基础语法</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="变量"><a class="header" href="#变量">变量</a></h1>
<p>在 Rust 中，变量的处理方式与其他编程语言（如 Python 或 Java）有很大不同。其核心设计理念是<strong>安全性</strong>和<strong>内存管理</strong>。</p>
<p>以下是关于 Rust 变量的核心知识点：</p>
<h2 id="变量绑定"><a class="header" href="#变量绑定">变量绑定</a></h2>
<p>在很多编程语言中，我们会说“给变量赋值”。但在 Rust 中，官方术语通常是  <strong>“变量绑定” (Variable Binding)</strong> 。</p>
<ul>
<li><strong>语法</strong> ：<code>let x = 5;</code></li>
<li><strong>核心逻辑</strong> ：这个语句意味着我们将名字 <code>x</code> 与值 <code>5</code> <strong>绑定</strong>在一起。</li>
<li><strong>为什么叫“绑定”？</strong>
<ul>
<li><strong>模式匹配</strong> ：<code>let</code> 关键字后面跟着的实际上是一个 <strong>模式 (Pattern)</strong> 。例如，你可以这样写：<code>let (a, b) = (1, 2);</code>。这里 Rust 会把元组中的值分别绑定到 <code>a</code> 和 <code>b</code> 上。</li>
<li><strong>所有权控制</strong> ：绑定不仅仅是内存地址的赋值，它还涉及到 Rust 核心的<strong>所有权 (Ownership)</strong> 系统。当一个值绑定到一个变量名时，这个变量名就“拥有”了这个值。</li>
</ul>
</li>
</ul>
<h3 id="使用下划线忽略未使用的变量"><a class="header" href="#使用下划线忽略未使用的变量">使用下划线忽略未使用的变量</a></h3>
<p>Rust 编译器非常注重代码的整洁。如果声明了一个变量但从未使用过它，编译器会报出警告（Warning），认为这可能是代码逻辑上的疏忽。</p>
<h4 id="a-使用-_-纯下划线"><a class="header" href="#a-使用-_-纯下划线">A. 使用 <code>_</code> (纯下划线)</a></h4>
<p>如果你完全不关心某个值，可以使用 <code>_</code>。它会立即丢弃该值，不会进行任何绑定。</p>
<pre class="playground"><code class="language-rust editable edition2024"><span class="boring">fn main() {
</span>    let _ = 5; // 值被直接丢弃, 不绑定到任何名字, 你之后无法通过任何名字访问这个 5
    let _ = some_function_returns_result(); // 我调用了函数，但我不在乎返回值
}
fn some_function_returns_result() -&gt; i32 {
    42
}</code></pre>
<h4 id="b-使用下划线开头-如-_x"><a class="header" href="#b-使用下划线开头-如-_x">B. 使用下划线开头 (如 <code>_x</code>)</a></h4>
<p>如果你想保留这个变量（可能为了调试或者为了以后扩展），但现在暂时不用，又不希望看到编译器的警告，可以在变量名前加一个下划线。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 5;     // ⚠️ 编译器会警告：unused variable: `x`
    let _y = 10;   // ✅ 编译器会保持沉默，因为它看到了下划线前缀
}</code></pre>
<p>cargo run:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>warning: unused variable: `y`
 --&gt; src/main.rs:3:9
  |
3 |     let y = 10;
  |         ^ help: 如果 y 故意不被使用，请添加一个下划线前缀: `_y`
  |
  = note: `#[warn(unused_variables)]` on by default
<span class="boring">}</span></code></pre>
<hr>
<h2 id="不可变性"><a class="header" href="#不可变性">不可变性</a></h2>
<p>在 Rust 中，变量<strong>默认是不可变的</strong>。一旦你为一个变量绑定了值，就不能再修改它。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 5;
    x = 6; // ❌ 编译错误！不能对不可变变量二次赋值
}</code></pre>
<p><strong>为什么要这样做？</strong></p>
<p>通过默认不可变，Rust 保证了数据的安全性。在多线程环境下，你可以确信一个变量的值不会在你不注意的时候被其他代码修改。</p>
<hr>
<h2 id="可变变量"><a class="header" href="#可变变量">可变变量</a></h2>
<p>如果你需要修改某个变量，必须显式地加上 <code>mut</code> 关键字。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut x = 5;
    println!("x 的值是: {}", x);
    x = 6; // ✅ 允许修改
    println!("现在 x 的值是: {}", x);
}</code></pre>
<hr>
<h2 id="变量遮蔽"><a class="header" href="#变量遮蔽">变量遮蔽</a></h2>
<p>Rust 允许你声明一个与现有变量同名的新变量。这被称为“遮蔽”。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 5;
    let x = x + 1; // 遮蔽了之前的 x
  
    {
        let x = x * 2; // 在当前作用域内再次遮蔽
        println!("内部作用域中 x 的值: {}", x); // 12
    }

    println!("外部作用域中 x 的值: {}", x); // 6
}
</code></pre>
<p><strong>遮蔽与 <code>mut</code> 的区别：</strong></p>
<ol>
<li><strong>类型转换</strong>：使用 <code>let</code> 遮蔽时，你可以改变变量的类型（例如从字符串变为数字），而 <code>mut</code> 变量的类型是固定的。</li>
<li><strong>重新锁定</strong>：遮蔽后，新变量如果没有 <code>mut</code>，它依然是不可变的。</li>
</ol>
<hr>
<h2 id="常量"><a class="header" href="#常量">常量</a></h2>
<p>常量类似于不可变变量，但有严格的区别：</p>
<ul>
<li>使用 <code>const</code> 关键字。</li>
<li><strong>必须</strong>显式注明类型（例如 <code>i32</code>）。</li>
<li>可以在任何作用域声明（包括全局）。</li>
<li>只能赋值为“常量表达式”，不能是函数调用的结果或运行时计算的值。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
fn main() {
    println!("三小时的秒数: {}", THREE_HOURS_IN_SECONDS);
}</code></pre>
<h2 id="作用域"><a class="header" href="#作用域">作用域</a></h2>
<p>变量在 Rust 中是“块级作用域”的。变量在声明的大括号 <code>{}</code> 内有效，超出范围后，变量会被<strong>释放 (Drop)</strong>。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let s = "hello"; // s 进入作用域
    {
        let x = 10; // x 进入作用域
    } // x 在这里失效并释放
    println!("s 的值是: {}", s); // ✅ 可以访问 s
} // s 在这里失效并释放





</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h1>
<h2 id="1-标量类型scalar-types"><a class="header" href="#1-标量类型scalar-types">1. 标量类型(Scalar Types)</a></h2>
<p>标量类型代表一个单一的值。</p>
<h3 id="a-整数类型-integers"><a class="header" href="#a-整数类型-integers">A. 整数类型 (Integers)</a></h3>
<p>Rust 提供了非常精细的整数控制，分为有符号（<code>i</code>）和无符号（<code>u</code>）。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>长度</th><th>有符号 (Signed)</th><th>无符号 (Unsigned)</th><th>范围 (n 为位数)</th></tr>
</thead>
<tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td><td><code>i8: -(2^(8-1))</code> ~ <code>2^(8-1)-1</code>,<br /> <code>u8: 0</code> ~<code> 2^8-1</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td><td><code>i16: -(2^(16-1))</code> ~<code>2^(16-1)-1</code>,<br /><code>u16: 0</code> ~<code>2^16-1</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code> (默认)</td><td><code>u32</code></td><td><code>i32: -(2^(32-1))</code> ~<code>2^(32-1)-1</code>,<br /><code>u32: 0 </code> ~<code> 2^32-1</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td><td><code>i64: -(2^(64-1))</code> ~<code>2^(64-1)-1</code>,<br /><code>u64: 0 </code> ~<code> 2^64-1</code></td></tr>
<tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td><td><code>i128:-(2^(128-1))</code> ~<code>2^(128-1)-1</code>,<br /><code>u128: 0 </code> ~<code> 2^128-1</code></td></tr>
<tr><td>arch (平台相关)</td><td><code>isize</code></td><td><code>usize</code></td><td>取决于计算机架构 (64位或32位)</td></tr>
</tbody>
</table>
</div>
<ul>
<li>
<p><strong><code>usize</code> / <code>isize</code> 的用途</strong>：常用于集合索引、切片范围、长度（如 <code>len()</code>）、以及与内存地址大小相关的场景。</p>
</li>
<li>
<p><strong>整数字面值</strong>：可以使用 <code>_</code> 分隔增强可读性，如 <code>1_000_000</code>。支持 <code>0x</code>（十六进制）、<code>0o</code>（八进制）、<code>0b</code>（二进制）。</p>
</li>
<li>
<p><strong>类型后缀</strong>：可在字面量后加后缀明确类型，如 <code>10u8</code>、<code>20i64</code>。</p>
</li>
<li>
<p><strong>溢出行为</strong>：</p>
<ul>
<li>debug 构建：整数溢出会触发 <code>panic!</code></li>
<li>release 构建：默认按补码进行回绕（wrapping）</li>
<li>常见策略方法：<code>wrapping_add</code>、<code>checked_add</code>、<code>overflowing_add</code>、<code>saturating_add</code></li>
</ul>
</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let a: u8 = 250;
    assert_eq!(a.wrapping_add(10), 4);
    assert_eq!(a.checked_add(10), None);
}</code></pre>
<hr>
<h3 id="b-浮点类型-floating-point"><a class="header" href="#b-浮点类型-floating-point">B. 浮点类型 (Floating-Point)</a></h3>
<p>Rust 遵循 IEEE-754 标准：</p>
<ul>
<li><strong><code>f32</code></strong>：单精度。</li>
<li><strong><code>f64</code></strong>：双精度（默认，因为在现代 CPU 上速度几乎与 <code>f32</code> 一样快，但精度更高）。</li>
</ul>
<p>浮点数相关注意点：</p>
<ul>
<li><strong>精度误差</strong>：尽量避免直接用 <code>==</code> 比较业务浮点值，常用误差范围比较。</li>
<li><strong>NaN</strong>：<code>NaN != NaN</code>，这会影响比较与排序逻辑。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 0.1f64 + 0.2;
    assert!((x - 0.3).abs() &lt; 1e-10);
}</code></pre>
<hr>
<h3 id="c-布尔与字符"><a class="header" href="#c-布尔与字符">C. 布尔与字符</a></h3>
<ul>
<li><strong><code>bool</code></strong>：<code>true</code> 和 <code>false</code>。通常占用 1 个字节。</li>
<li><strong><code>char</code></strong>：占用 <strong>4 个字节</strong>，代表一个 <strong>Unicode 标量值</strong>，可以表示中文、日文、表情符号 (Emoji) 等。<code>char</code> 不是 UTF-8 的“一个字节”，也不等同于字符串的长度单位。</li>
</ul>
<hr>
<h2 id="2-复合类型-compound-types"><a class="header" href="#2-复合类型-compound-types">2. 复合类型 (Compound Types)</a></h2>
<p>将多个值组合成一个类型。</p>
<h3 id="a-元组-tuple"><a class="header" href="#a-元组-tuple">A. 元组 (Tuple)</a></h3>
<ul>
<li><strong>特点</strong>：长度固定，<strong>各元素类型可以不同</strong>。</li>
<li><strong>定义</strong>：<code>let tup: (i32, f64, u8) = (500, 6.4, 1);</code></li>
<li><strong>访问</strong>：使用点号，如 <code>tup.0</code>。</li>
<li><strong>解构</strong>：可用模式匹配直接拆开。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    let (x, y, z) = tup;
}</code></pre>
<ul>
<li><strong>单元类型 <code>()</code></strong>：不包含任何值的元组，常作为表达式的默认返回值或占位类型。</li>
</ul>
<hr>
<h3 id="b-数组-array"><a class="header" href="#b-数组-array">B. 数组 (Array)</a></h3>
<ul>
<li><strong>特点</strong>：长度固定，<strong>各元素类型必须相同</strong>。</li>
<li><strong>定义</strong>：<code>let a = [1, 2, 3, 4, 5];</code></li>
<li><strong>类型与长度声明</strong>：<code>let a: [i32; 5] = [1, 2, 3, 4, 5];</code></li>
<li><strong>重复初始化</strong>：<code>let a = [0u8; 1024];</code></li>
<li><strong>存储</strong>：数组是固定大小的值类型，作为局部变量时通常位于栈上；若被 <code>Box</code> 等包裹，则数据会位于堆上。</li>
</ul>
<p>数组访问与边界：</p>
<ul>
<li><code>a[i]</code>：越界会 <code>panic!</code></li>
<li><code>a.get(i)</code>：返回 <code>Option&lt;&amp;T&gt;</code>，更安全</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let a = [1, 2, 3];
    assert_eq!(a.get(10), None);
}</code></pre>
<hr>
<h2 id="3-序列与字符串-sequences--strings"><a class="header" href="#3-序列与字符串-sequences--strings">3. 序列与字符串 (Sequences &amp; Strings)</a></h2>
<p>这一部分常见困惑点集中在 UTF-8 与内存分配方式。</p>
<h3 id="a-字符串-strings"><a class="header" href="#a-字符串-strings">A. 字符串 (Strings)</a></h3>
<p>Rust 核心语言层面有 <code>str</code>（动态大小类型，通常以引用切片 <code>&amp;str</code> 出现），标准库提供可增长的 <code>String</code>。</p>
<ul>
<li><strong><code>String</code></strong>：拥有所有权，数据在堆上，可增长。内部包含指针、长度、容量等信息。</li>
<li><strong><code>&amp;str</code></strong>：字符串切片，是对一段 UTF-8 字节序列的借用视图。引用本身在栈上，实际数据可能来自只读区（字符串字面量）、栈或堆。</li>
</ul>
<p>常见转换：</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let s1: String = "hello".to_string();
    let s2: &amp;str = &amp;s1;           // &amp;String 自动解引用成 &amp;str
    let s3: String = s2.to_owned(); // 或 s2.to_string()
}</code></pre>
<p>字符串索引与切片规则：</p>
<ul>
<li>Rust 不支持 <code>s[0]</code> 直接索引字符，因为 UTF-8 下“字符边界”与字节下标不总一致。</li>
<li><code>&amp;s[a..b]</code> 必须落在 UTF-8 字符边界，否则运行时会 <code>panic!</code>。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let s = "中文";
    let ok = &amp;s[0..3]; // "中" 占 3 个字节
}</code></pre>
<hr>
<h3 id="b-切片-slices"><a class="header" href="#b-切片-slices">B. 切片 (Slices)</a></h3>
<p>切片引用连续的一段序列，而不是整个集合。</p>
<ul>
<li><strong>数组/向量切片</strong>：<code>&amp;[T]</code></li>
<li><strong>字符串切片</strong>：<code>&amp;str</code>（本质上也是切片）</li>
</ul>
<p>示例：</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let a = [10, 20, 30, 40, 50];
    let slice = &amp;a[1..3]; // &amp;[20, 30]
}</code></pre>
<p>切片是一种“胖指针”，通常包含地址与长度信息，因此可以安全地携带边界。</p>
<hr>
<h2 id="4-标准库集合-standard-collections"><a class="header" href="#4-标准库集合-standard-collections">4. 标准库集合 (Standard Collections)</a></h2>
<p>虽然属于标准库，但它们在实际开发中几乎被当作基础类型使用。</p>
<h3 id="a-vect-vector"><a class="header" href="#a-vect-vector">A. <code>Vec&lt;T&gt;</code> (Vector)</a></h3>
<ul>
<li>动态数组，在堆上分配，可扩容。</li>
<li>常见 API：<code>push</code>、<code>pop</code>、<code>len</code>、<code>capacity</code>、<code>get</code>、切片 <code>&amp;v[a..b]</code> 等。</li>
<li>预分配容量：<code>Vec::with_capacity(n)</code> 可减少扩容次数。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut v = Vec::new();
    v.push(1);
    v.extend([2, 3, 4]);
    println!("{:?}", v);

    let first = v.get(0);   // Option&lt;&amp;i32&gt;
    let part = &amp;v[1..3];    // &amp;[i32]
    println!("{:?}", part);
}</code></pre>
<hr>
<h3 id="b-hashmapk-v"><a class="header" href="#b-hashmapk-v">B. <code>HashMap&lt;K, V&gt;</code></a></h3>
<ul>
<li>键值对映射结构。</li>
<li>常用 <code>entry</code> 模式在“插入或更新”时更方便。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    use std::collections::HashMap;

    let mut m = HashMap::new();
    m.insert("a", 1);
    println!("{:?}", m);

    *m.entry("a").or_insert(0) += 1;
    println!("{:?}", m);
}</code></pre>
<hr>
<h2 id="5-特殊底层类型"><a class="header" href="#5-特殊底层类型">5. 特殊/底层类型</a></h2>
<h3 id="a-枚举-enums"><a class="header" href="#a-枚举-enums">A. 枚举 (Enums)</a></h3>
<p>枚举用于表示“一组有限的可能取值”。Rust 的枚举非常强大：每个变体（variant）不仅能表示不同分支，还能携带不同类型的数据，因此很适合用来建模状态机、协议消息、错误类型等。</p>
<ol>
<li>基本定义与使用</li>
</ol>
<pre class="playground"><code class="language-rust editable edition2024">enum Direction {
    Up,
    Down,
    Left,
    Right,
}
fn move_step(d: Direction) {
    match d {
        Direction::Up =&gt; println!("up"),
        Direction::Down =&gt; println!("down"),
        Direction::Left =&gt; println!("left"),
        Direction::Right =&gt; println!("right"),
    }
}

fn main() {
    let d = Direction::Up;
    move_step(d);
}</code></pre>
<p>2)变体携带数据</p>
<p>枚举变体可以携带数据，且不同变体携带的数据类型可以不同：</p>
<pre class="playground"><code class="language-rust editable edition2024">enum Message {
    Quit,
    Move { x: i32, y: i32 },  // 结构体风格
    Write(String),            // 元组风格
}
fn main() {
    let m1 = Message::Quit;
    let m2 = Message::Move { x: 3, y: 4 };
    let m3 = Message::Write("hi".to_string());
}
</code></pre>
<hr>
<h3 id="b-结构体-structs"><a class="header" href="#b-结构体-structs">B. 结构体 (Structs)</a></h3>
<p>结构体用于把多个字段组合成一个自定义类型，是“组织数据”的核心方式之一。</p>
<ol>
<li>具名字段结构体（最常用）</li>
</ol>
<pre class="playground"><code class="language-rust editable edition2024">struct User {
    name: String,
    age: u8,
    active: bool,
}
fn main() {
    let u = User {
        name: "Alice".to_string(),
        age: 18,
        active: true,
    };
    //访问字段用点号：
    println!("{:?}", u.name);
}</code></pre>
<p>2)结构体与所有权的直观规则</p>
<p>字段类型如果是 String、Vec <code>&lt;T&gt;</code> 等“拥有型”，把结构体赋值给新变量时默认会发生移动（move）。
想继续使用旧值通常需要借用（&amp;User）或让字段可复制（如 u32）或显式 clone()。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct User {
    name: String,
    age: u8,
    active: bool,
}
fn main() {
    let u1 = User { name: "A".to_string(), age: 1, active: true };
    let u2 = u1;          // u1 被 move
    // println!("{}", u1.age); // 不能用
    println!("{}", u2.age);
}</code></pre>
<hr>
<h3 id="c-指针类型pointer-types"><a class="header" href="#c-指针类型pointer-types">C. 指针类型（Pointer Types）</a></h3>
<p>根据底层的表现形式和抽象程度，可以将 Rust 的指针分为以下四大类：</p>
<h4 id="1-引用-references--最常用的指针"><a class="header" href="#1-引用-references--最常用的指针">1. 引用 (References) —— 最常用的指针</a></h4>
<p>引用是 Rust 中最常见的指针形式，它们在底层表现为指向某个内存地址的指针。</p>
<ul>
<li><strong><code>&amp;T</code>（不可变引用）</strong> ：指向类型为 <code>T</code> 的值，允许读取数据但不能修改。</li>
<li><strong><code>&amp;mut T</code>（可变引用）</strong> ：允许读取并修改指向的数据。</li>
<li><strong>内存表现</strong> ：
<ul>
<li><strong>普通引用</strong> ：对于已知大小的类型（如 <code>i32</code>），它是单字长的指针。</li>
<li><strong>切片引用（胖指针）</strong> ：对于动态大小类型（如 <code>&amp;str</code> 或 <code>&amp;[T]</code>），它由指针和长度组成，占用两个字长。</li>
</ul>
</li>
</ul>
<h4 id="2-原生指针-raw-pointers--绕过安全的底层指针"><a class="header" href="#2-原生指针-raw-pointers--绕过安全的底层指针">2. 原生指针 (Raw Pointers) —— 绕过安全的底层指针</a></h4>
<p>原生指针与 C 语言的指针非常相似。它们在语法上定义为 <code>*const T</code> 和 <code>*mut T</code>。</p>
<ul>
<li><strong>特点</strong> ：
<ul>
<li>允许忽略借用规则，可以同时拥有多个指向同一位置的可变和不可变指针。</li>
<li>不保证指向有效的内存，且允许为 <code>null</code>。</li>
<li><strong>安全性</strong> ：解引用原生指针是不安全的，必须放在 <code>unsafe</code> 块中执行。</li>
</ul>
</li>
<li><strong>用途</strong> ：主要用于与 C 语言交互（FFI）或编写底层高性能驱动。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut num = 5;

    // 1. 从引用创建原生指针
    // 虽然创建原生指针是安全的，但后续使用是不安全的
    let r1 = &amp;num as *const i32; // 不可变原生指针
    let r2 = &amp;mut num as *mut i32; // 可变原生指针

    // 2. 解引用原生指针
    // 必须放在 unsafe 块中，否则编译器会报错
    unsafe {
        println!("r1 指向的值: {}", *r1);

    // 修改原生指针指向的数据
        *r2 = 10;
        println!("修改后 r2 指向的值: {}", *r2);
    }

    // 3. 创建一个指向任意内存地址的指针（慎用！）
    let address = 0x012345usize;
    let _r3 = address as *const i32;
}</code></pre>
<h4 id="3-函数指针-fn-pointer--代码地址的载体"><a class="header" href="#3-函数指针-fn-pointer--代码地址的载体">3. 函数指针 (fn Pointer) —— 代码地址的载体</a></h4>
<p>函数指针指向的是代码段中的函数入口地址，而不是堆栈上的数据。</p>
<ul>
<li><strong>语法</strong> ：类型写作 <code>fn(参数类型) -&gt; 返回类型</code>。</li>
<li><strong>区别于闭包</strong> ：
<ul>
<li>函数指针不捕获环境变量。</li>
<li>它的长度始终是一个字长（存储地址）。</li>
<li>它可以作为参数传递给其他函数，或者存储在数据结构中。</li>
</ul>
</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    // 像正常函数一样通过指针调用
    f(arg) + f(arg)
}

fn main() {
    // 将函数名 add_one 隐式转换为函数指针类型
    let f: fn(i32) -&gt; i32 = add_one;

    let answer = do_twice(f, 5);

    println!("计算结果为: {}", answer); // 输出: 12

    // 函数指针的大小验证
    println!("函数指针的大小: {} 字节", std::mem::size_of_val(&amp;f));
}</code></pre>
<h4 id="4-智能指针-smart-pointers--携带元数据的指针"><a class="header" href="#4-智能指针-smart-pointers--携带元数据的指针">4. 智能指针 (Smart Pointers) —— 携带元数据的指针</a></h4>
<p>智能指针是拥有数据所有权的结构体，它们实现了 <code>Deref</code> 和 <code>Drop</code> 特性。</p>
<h5 id="a-boxt-堆空间分配"><a class="header" href="#a-boxt-堆空间分配">A. <code>Box&lt;T&gt;</code> (堆空间分配)</a></h5>
<ul>
<li><strong>功能</strong> ：在堆上分配空间存储类型为 <code>T</code> 的值，并在栈上保留指针。</li>
<li><strong>场景</strong> ：当数据大小在编译时未知（如递归类型），或数据量巨大不适合在栈上拷贝时使用。</li>
</ul>
<h5 id="b-rct-引用计数指针"><a class="header" href="#b-rct-引用计数指针">B. <code>Rc&lt;T&gt;</code> (引用计数指针)</a></h5>
<ul>
<li><strong>功能</strong> ：全称 Reference Counting，允许多个变量通过增加计数来共享同一个堆数据的所有权。</li>
<li><strong>场景</strong> ：用于单线程环境下，需要一个数据有多个所有者的复杂逻辑（如树或图的节点共享）。</li>
</ul>
<h5 id="c-arct-原子引用计数指针"><a class="header" href="#c-arct-原子引用计数指针">C. <code>Arc&lt;T&gt;</code> (原子引用计数指针)</a></h5>
<ul>
<li><strong>功能</strong> ：Atomic Reference Counting，是 <code>Rc&lt;T&gt;</code> 的线程安全版本。</li>
<li><strong>场景</strong> ：多线程并发环境下，安全地共享同一份数据的所有权。</li>
</ul>
<h5 id="总结对比表"><a class="header" href="#总结对比表">总结对比表</a></h5>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>指针类型</strong></th><th><strong>语法表示</strong></th><th><strong>内存位置</strong></th><th><strong>长度(64位)</strong></th><th><strong>核心特性</strong></th></tr>
</thead>
<tbody>
<tr><td><strong>引用</strong></td><td><code>&amp;T</code>/<code>&amp;mut T</code></td><td>栈/堆</td><td>8 或 16 字节</td><td>安全借用，编译器检查生命周期</td></tr>
<tr><td><strong>原生指针</strong></td><td><code>*const T</code>/<code>*mut T</code></td><td>栈/堆</td><td>8 字节</td><td>不安全，类似 C 指针</td></tr>
<tr><td><strong>函数指针</strong></td><td><code>fn(...) -&gt; ...</code></td><td>代码段</td><td>8 字节</td><td>指向函数地址</td></tr>
<tr><td><strong>智能指针</strong></td><td><code>Box&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code></td><td>堆</td><td>8 字节</td><td>管理堆内存，提供自动清理逻辑</td></tr>
</tbody>
</table>
</div>
<hr>
<h3 id="d-optiont-与-resultt-e"><a class="header" href="#d-optiont-与-resultt-e">D. <code>Option&lt;T&gt;</code> 与 <code>Result&lt;T, E&gt;</code></a></h3>
<p>Rust 不提供 <code>null</code>，用 <code>Option&lt;T&gt;</code> 表示“可能不存在”。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x: Option&lt;i32&gt; = Some(1);
    let y: Option&lt;i32&gt; = None;
}</code></pre>
<p>错误处理通常用 <code>Result&lt;T, E&gt;</code>：</p>
<pre class="playground"><code class="language-rust editable edition2024">fn parse(s: &amp;str) -&gt; Result&lt;i32, std::num::ParseIntError&gt; {
    s.parse()
}
fn main() {
    let result = parse("123");
    println!("{:?}", result);
}</code></pre>
<hr>
<h3 id="e-never-类型-"><a class="header" href="#e-never-类型-">E. <code>Never</code> 类型 (<code>!</code>)</a></h3>
<p><code>!</code> 表示永远不会返回的类型，常见于 <code>panic!</code>、无限循环等。</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn forever() -&gt; ! {
    loop {}
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="6-类型转换注意"><a class="header" href="#6-类型转换注意">6. 类型转换注意</a></h2>
<p>Rust <strong>不会</strong>进行隐式类型转换。不同整数类型之间的转换必须显式完成。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let a: u8 = 10;
    let b: u32 = a as u32;
}</code></pre>
<p><code>as</code> 转换在整数之间可能发生截断或符号变化。需要“转换失败就返回错误/None”时可用 <code>TryFrom/TryInto</code>。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    use std::convert::TryFrom;

    let x: i32 = 300;
    let y = u8::try_from(x); // Err(...)
}</code></pre>
<hr><div style="break-before: page; page-break-before: always;"></div>
<h1 id="注释和打印"><a class="header" href="#注释和打印">注释和打印</a></h1>
<p>在 Rust 中，注释是写给程序员看的“备忘录”，而打印则是程序与外界沟通的最基本方式。理解这两者能极大地提升开发和调试效率。</p>
<hr>
<h2 id="一-注释-comments"><a class="header" href="#一-注释-comments">一、 注释 (Comments)</a></h2>
<p>Rust 支持多种注释风格，除了代码解释外，Rust 的注释还深度集成了文档生成工具 <code>cargo doc</code>。</p>
<h3 id="1-常规注释"><a class="header" href="#1-常规注释">1. 常规注释</a></h3>
<ul>
<li><strong>单行注释</strong> ：使用 <code>//</code>，这是最常用的注释方式。</li>
<li><strong>块注释 (多行)</strong> ：使用 <code>/* ... */</code>。虽然 Rust 支持，但社区更倾向于在多行也使用单行注释。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    // 这是一个单行注释
    let x = 5; // 也可以在代码行末尾

    /* 这是一个块注释
       它可以跨越多行 */
    let y = 10;
}</code></pre>
<h3 id="2-文档注释-doc-comments"><a class="header" href="#2-文档注释-doc-comments">2. 文档注释 (Doc Comments)</a></h3>
<p>这是 Rust 的特色，用于生成 HTML 格式的 API 文档。</p>
<ul>
<li><strong>三斜杠 <code>///</code></strong> ：为紧随其后的 <strong>项目</strong> （如函数、结构体）生成文档。支持 Markdown 语法。</li>
<li><strong>双斜杠感叹号 <code>//!</code></strong> ：为包含该注释的 <strong>条目</strong> （如整个 crate 或模块）生成文档。</li>
</ul>
<pre><code class="language-rust ignore">//! # 核心逻辑模块
//! 这个模块包含了一些数学运算函数。

/// 将两个数字相加。
/// 
/// # Examples
/// ```
/// let res = add(1, 2);
/// ```
fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}</code></pre>
<p>在<a href="#文档">文档</a>章节会详细介绍文档注释的使用方法和注意事项。</p>
<hr>
<h2 id="二-打印-printing"><a class="header" href="#二-打印-printing">二、 打印 (Printing)</a></h2>
<p>Rust 的打印是通过一组<strong>宏 (Macros)</strong> 来实现的。宏的显著特征是名称末尾带有感叹号 <code>!</code>。</p>
<h3 id="1-核心宏"><a class="header" href="#1-核心宏">1. 核心宏</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>宏名称</strong></th><th><strong>功能描述</strong></th></tr>
</thead>
<tbody>
<tr><td><strong><code>print!</code></strong></td><td>打印到标准输出，不换行。</td></tr>
<tr><td><strong><code>println!</code></strong></td><td>打印到标准输出，<strong>自动换行</strong> 。</td></tr>
<tr><td><strong><code>format!</code></strong></td><td>不打印，而是返回一个格式化后的 <code>String</code>。</td></tr>
<tr><td><strong><code>eprintln!</code></strong></td><td>打印到<strong>标准错误输出 (stderr)</strong> ，常用于打印错误信息。</td></tr>
</tbody>
</table>
</div>
<h3 id="2-占位符"><a class="header" href="#2-占位符">2. 占位符</a></h3>
<h4 id="参数位置与命名"><a class="header" href="#参数位置与命名">参数位置与命名</a></h4>
<p>除了按顺序匹配，你还可以通过索引或名称来复用变量。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let name = "Alice";
    let age = 30;

    // 按顺序匹配
    println!("{} is {} years old.", name, age); // Alice is 30 years old.

    // 索引匹配
    println!("{0} is {1} years old.", name, age); // Alice is 30 years old.

    // 具名匹配
    println!("{name} is {age} years old."); // Alice is 30 years old.
}</code></pre>
<h4 id="格式化占位符核心语法"><a class="header" href="#格式化占位符核心语法">格式化占位符核心语法</a></h4>
<p>下表总结了占位符 <code>{}</code> 内部可以使用的所有核心语法：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>类别</th><th>语法示例</th><th>效果描述</th><th>42或“Hi“为例</th></tr>
</thead>
<tbody>
<tr><td><strong>基础展示</strong></td><td><code>{}</code></td><td>调用 <code>Display</code> 特征，普通人类可读输出。</td><td><code>42</code></td></tr>
<tr><td></td><td><code>{:?}</code></td><td>调用 <code>Debug</code> 特征，程序员调试用输出。</td><td><code>42</code></td></tr>
<tr><td></td><td><code>{:#?}</code></td><td><strong>漂亮打印 (Pretty Print)</strong>，多行缩进展示复杂结构。</td><td>(分行显示的结构)</td></tr>
<tr><td><strong>参数索引</strong></td><td><code>{0}</code></td><td>使用第 1 个位置参数（索引从 0 开始）。</td><td><code>42</code></td></tr>
<tr><td></td><td><code>{name}</code></td><td>使用具名参数。</td><td><code>Hi</code></td></tr>
<tr><td><strong>对齐与填充</strong></td><td><code>{:10}</code></td><td>设置宽度为 10，默认左对齐（字符串）或右对齐（数字）。</td><td><code>"Hi        "</code></td></tr>
<tr><td></td><td><code>{:&lt;10}</code></td><td>强制<strong>左对齐</strong>。</td><td><code>"Hi        "</code></td></tr>
<tr><td></td><td><code>{:&gt;10}</code></td><td>强制<strong>右对齐</strong>。</td><td><code>"        Hi"</code></td></tr>
<tr><td></td><td><code>{:^10}</code></td><td>强制<strong>居中对齐</strong>。</td><td><code>"    Hi    "</code></td></tr>
<tr><td></td><td><code>{:*^10}</code></td><td>使用 <code>*</code> 进行填充（填充字符必须在对齐符号前）。</td><td><code>"****Hi****"</code></td></tr>
<tr><td><strong>数字进制</strong></td><td><code>{:b}</code></td><td>转换为二进制 (Binary)。</td><td><code>101010</code></td></tr>
<tr><td></td><td><code>{:o}</code></td><td>转换为八进制 (Octal)。</td><td><code>52</code></td></tr>
<tr><td></td><td><code>{:x}</code> / <code>{:X}</code></td><td>转换为十六进制 (Hex)，大小写决定字母大小写。</td><td><code>2a</code> / <code>2A</code></td></tr>
<tr><td></td><td><code>{:#x}</code></td><td>带有进制前缀的十六进制。</td><td><code>0x2a</code></td></tr>
<tr><td><strong>精度与正负</strong></td><td><code>{:.2}</code></td><td>浮点数保留 2 位小数。</td><td><code>3.14</code></td></tr>
<tr><td></td><td><code>{:+.2}</code></td><td>强制显示正负号。</td><td><code>+42.00</code></td></tr>
<tr><td></td><td><code>{:05}</code></td><td>宽度为 5，不足部分用 <strong>0 填充</strong>。</td><td><code>00042</code></td></tr>
<tr><td><strong>特殊指针</strong></td><td><code>{:p}</code></td><td><strong>打印内存地址</strong>（适用于引用或原生指针）。</td><td><code>0x7ffee1234567</code></td></tr>
<tr><td><strong>转义</strong></td><td><code>{{</code> / <code>}}</code></td><td>在格式化字符串中显示原始的大括号。</td><td><code>{</code> / <code>}</code></td></tr>
</tbody>
</table>
</div>
<p>为了更直观地理解如何组合这些选项，请看下面的综合实例：</p>
<pre class="playground"><code class="language-rust editable edition2024">use std::mem::size_of;

#[derive(Debug)]
struct Point { x: i32, y: i32 }

fn main() {
    let p = Point { x: 10, y: 20 };
    let pi = 3.14159;
    // 1. 组合：宽度、对齐、填充、精度
    // 效果：居中对齐，宽度10，用'-'填充，保留2位小数
    println!("数值展示: {:*^10.2}", pi); 

    // 2. 指针地址展示
    // 使用 :p 查看变量在栈上的地址
    let r = &amp;p;
    println!("结构体 p 的地址: {:p}", r); 

    // 3. 进制与前缀
    let val = 255;
    println!("十六进制: {:#X}, 二进制: {:b}", val, val);

    // 4. 调试复杂结构
    // 使用 {:#?} 实现易读的缩进输出
    println!("漂亮打印结构体: {:#?}", p);
}</code></pre>
<h4 id="-核心知识点补充"><a class="header" href="#-核心知识点补充">💡 核心知识点补充</a></h4>
<ul>
<li>**<code>Debug</code> vs <code>Display**</code>：几乎所有的 Rust 标准库类型都实现了 <code>Debug</code>（用于调试），但并非都实现了 <code>Display</code>（因为某些类型没有唯一的人类可读展示方式）。</li>
<li><strong>指针长度</strong>：在 64 位系统上，使用 <code>{:p}</code> 打印出的地址通常对应一个 8 字节（单字长）的内存位置。</li>
<li><strong>内存效率</strong>：所有的 <code>print!</code> 系列宏在编译时都会被检查。如果占位符数量与参数不匹配，编译器会直接报错，这保证了运行时的类型安全。</li>
</ul>
<h4 id="结构化调试打印"><a class="header" href="#结构化调试打印">结构化调试打印</a></h4>
<ul>
<li><strong>派生 Debug</strong>： 使用 <code>#[derive(Debug)]</code> 注解结构体或枚举，自动生成 Debug 实现。
<ul>
<li><strong><code>{:?}</code></strong> ：以调试模式打印（需要类型实现 <code>std::fmt::Debug</code>）。</li>
<li><strong><code>{:#?}</code></strong> ： <strong>美化打印</strong> ，会自动分行并添加缩进，适合查看大型结构体。</li>
</ul>
</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect = Rectangle { width: 30, height: 50 };
    println!("rect 是 {:?}", rect);  // 输出: rect 是 Rectangle { width: 30, height: 50 }
    println!("rect 是 {:#?}", rect);  // 美化输出，多行缩进
}</code></pre>
<ul>
<li><strong>手动实现 Debug</strong>： 如果需要自定义格式，实现 std::fmt::Debug trait</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">use std::fmt;
struct Point {
    x: i32,
    y: i32,
}
impl fmt::Debug for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        f.debug_struct("Point")
         .field("x", &amp;self.x)
         .field("y", &amp;self.y)
         .finish()
    }
}
fn main() {
    let p = Point { x: 1, y: 2 };
    println!("{:?}", p);  // 输出: Point { x: 1, y: 2 }
}</code></pre>
<ul>
<li><strong>Debug vs Display</strong>：
<ul>
<li>Debug：用于开发者，格式如 { x: 1, y: 2 }，通过 {:?}。</li>
<li>Display：用于用户友好输出，通过 {}。需手动实现 std::fmt::Display。</li>
</ul>
</li>
</ul>
<pre><code class="language-rust ignore">impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
println!("{}", p);  // 输出: (1, 2)</code></pre>
<hr>
<h2 id="3-dbg宏"><a class="header" href="#3-dbg宏">3. dbg宏</a></h2>
<p>dbg! 宏用于调试，它打印表达式的值和源代码位置，然后返回该值。适合插入代码中快速检查，而不中断流程。</p>
<ul>
<li><strong>语法</strong>：
<ul>
<li><strong>dbg!(表达式);</strong>：打印表达式的文件名、行号、列号和值，返回表达式本身。</li>
<li>支持借用（&amp;），避免所有权转移。</li>
</ul>
</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">#[derive(Debug)] // 使用 dbg! 要求类型必须实现 Debug 特征
struct Rectangle {
    width: u32,
    height: u32,
}
fn main() {
    let rect = Rectangle { width: 30, height: 50 };
    // 1. println! 的方式：必须单独写一行，且需要手动写描述
    println!("矩形的数据是: {:?}", rect); 
    // 2. dbg! 的方式：直接包裹表达式
    // 它会打印：[src\main.rs:12:5] rect = Rectangle { width: 30, height: 50 }
    dbg!(&amp;rect); 
    // 3. 嵌套使用（逻辑不中断）
    let area = dbg!(rect.width * rect.height); // 打印计算过程并把结果赋给 area
    println!("面积是: {}", area);
}</code></pre>
<ul>
<li>
<p><strong>与结构体结合</strong>： dbg! 使用 Debug trait，如果结构体未实现 Debug，会编译错误。</p>
</li>
<li>
<p><strong>注意</strong>：dbg! 只在调试构建中有效，在发布模式下可能被优化掉。输出到 stderr，便于区分正常输出。</p>
</li>
</ul>
<h3 id="dbg-与-println-的详细对比"><a class="header" href="#dbg-与-println-的详细对比"><code>dbg!</code> 与 <code>println!</code> 的详细对比</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>特性</th><th><code>println!</code></th><th><code>dbg!</code></th></tr>
</thead>
<tbody>
<tr><td><strong>输出目标</strong></td><td>标准输出 (stdout)</td><td><strong>标准错误 (stderr)</strong></td></tr>
<tr><td><strong>占位符要求</strong></td><td>必须手动写 <code>{}</code> 或 <code>{:?}</code></td><td><strong>自动调用 <code>{:?}</code></strong></td></tr>
<tr><td><strong>信息量</strong></td><td>仅打印你指定的内容</td><td>自动包含<strong>文件名、行号、表达式</strong></td></tr>
<tr><td><strong>返回值</strong></td><td>返回单元类型 <code>()</code></td><td><strong>返回表达式的值（所有权转移）</strong></td></tr>
<tr><td><strong>典型用途</strong></td><td>最终程序输出给用户看</td><td><strong>开发过程中快速排查问题</strong></td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="所有权和借用"><a class="header" href="#所有权和借用">所有权和借用</a></h1>
<p>所有权（Ownership）是 Rust 最为独特且核心的特性。它让 Rust 能够脱离垃圾回收（GC）机制，在编译期即确保内存安全。</p>
<hr>
<h2 id="一-内存管理的三大流派"><a class="header" href="#一-内存管理的三大流派">一、 内存管理的三大流派</a></h2>
<p>在计算机科学中，管理内存通常有三种方式：</p>
<ol>
<li><strong>垃圾回收 (GC)</strong> ：如 Java、Go、Python。程序运行时自动寻找不再使用的内存。优点是开发快，缺点是运行时开销大，可能出现“停顿”。</li>
<li><strong>手动管理</strong> ：如 C/C++。程序员手动调用 <code>malloc/free</code>。优点是极致性能，缺点是极其容易出现 <strong>悬空指针</strong> 、<strong>双重释放</strong>或 <strong>内存泄漏</strong> 。</li>
<li><strong>所有权系统</strong> ：Rust 的路径。通过编译器在编译时根据一套规则检查内存管理。 <strong>零运行时开销</strong> 。</li>
</ol>
<h3 id="预备知识栈-stack-与-堆-heap"><a class="header" href="#预备知识栈-stack-与-堆-heap">预备知识：栈 (Stack) 与 堆 (Heap)</a></h3>
<h4 id="栈"><a class="header" href="#栈">栈</a></h4>
<p>栈按照顺序存储值并以相反顺序取出值，这也被称作 <strong>后进先出</strong> 。想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，再从顶部拿走。不能从中间也不能从底部增加或拿走盘子！</p>
<p>增加数据叫做 <strong>进栈</strong> ，移出数据则叫做 <strong>出栈</strong> 。</p>
<p>因为上述的实现方式，栈中的所有数据都必须占用已知且固定大小的内存空间，假设数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据。</p>
<h4 id="堆"><a class="header" href="#堆">堆</a></h4>
<p>与栈不同，对于大小未知或者可能变化的数据，我们需要将它存储在堆上。</p>
<p>当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 <strong>指针</strong> ，该过程被称为 <strong>在堆上分配内存</strong> ，有时简称为 “分配”(allocating)。</p>
<p>接着，该指针会被推入<strong>栈</strong>中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的 <strong>指针</strong> ，来获取数据在堆上的实际内存位置，进而访问该数据。</p>
<p>由上可知，堆是一种缺乏组织的数据结构。想象一下去餐馆就座吃饭：进入餐馆，告知服务员有几个人，然后服务员找到一个够大的空桌子（堆上分配的内存空间）并领你们过去。如果有人来迟了，他们也可以通过桌号（栈上的指针）来找到你们坐在哪。</p>
<h4 id="性能区别"><a class="header" href="#性能区别">性能区别</a></h4>
<p>在栈上分配内存比在堆上分配内存要快，因为入栈时操作系统无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。 因此，处理器在栈上分配数据会比在堆上分配数据更加高效。</p>
<h4 id="所有权与堆栈"><a class="header" href="#所有权与堆栈">所有权与堆栈</a></h4>
<p>当你的代码调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。</p>
<p>因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收。这就是 Rust 所有权系统为我们提供的强大保障。</p>
<p>对于其他很多编程语言，你确实无需理解堆栈的原理，但是 <strong>在 Rust 中，明白堆栈的原理，对于我们理解所有权的工作原理会有很大的帮助</strong> 。</p>
<hr>
<h2 id="二-所有权"><a class="header" href="#二-所有权">二、 所有权</a></h2>
<ul>
<li><strong>什么是所有权？</strong> ：每个值都有一个“所有者”（owner），负责在值超出作用域时释放它。Rust 使用所有权来管理堆内存，而不依赖垃圾回收器。</li>
<li><strong>为什么重要？</strong> ：防止双重释放（double free）、使用后释放（use after free）和数据竞争。</li>
<li><strong>三条铁律构建</strong> ：</li>
</ul>
<h3 id="每一个值都有一个变量称为它的所有者"><a class="header" href="#每一个值都有一个变量称为它的所有者">每一个值都有一个变量，称为它的“所有者”</a></h3>
<p>在 Rust 中，内存中的数据（值）不能孤立存在，必须绑定到一个变量上。</p>
<pre class="playground"><code class="language-rust edition">fn main() {
    // 这个 String 字符串值在堆上创建
    // 变量 s 成了这个字符串的“所有者”
    let s = String::from("hello"); 

    println!("s 拥有这个值: {}", s);
} // 函数结束，s 超出作用域，值被丢弃</code></pre>
<h3 id="同一时间内一个值只能有一个所有者"><a class="header" href="#同一时间内一个值只能有一个所有者">同一时间内，一个值只能有一个所有者</a></h3>
<p>这是 Rust 安全性的核心。如果一个堆上的值有两个所有者，就会发生“二次释放”内存错误。因此，Rust 强制执行所有权移动（Move）。</p>
<pre class="playground"><code class="language-rust edition">fn main() {
    let s1 = String::from("hello");
    
    // 所有权从 s1 转移到了 s2
    // 此时内存中仍然只有一个 "hello"，但所有者变成了 s2
    let s2 = s1; 

    // println!("{}", s1); 
    // ❌ 编译报错！s1 不再拥有该值，它已经“失效”了。
    
    println!("现在所有权在 s2 手里: {}", s2); 
}</code></pre>
<h3 id="当所有者超出作用域时该值将被丢弃drop"><a class="header" href="#当所有者超出作用域时该值将被丢弃drop">当所有者超出作用域时，该值将被丢弃（<code>drop</code>）</a></h3>
<p>Rust 自动管理内存的秘诀就在这里：通过大括号 {} 定义作用域，一旦走出大括号，变量就会被销毁，内存立即回收。</p>
<pre class="playground"><code class="language-rust edition">fn main() {
    {
        // s 从这里开始有效
        let s = String::from("hello"); 
        println!("作用域内: {}", s);
    } 
    // 💡 执行到这里，作用域结束。
    // Rust 自动调用 `drop` 函数，释放 s 占用的堆内存。

    // println!("{}", s); 
    // ❌ 编译报错！s 已经不在这里了，内存已经还给系统了。
}</code></pre>
<hr>
<h2 id="三-变量交互移动克隆与复制"><a class="header" href="#三-变量交互移动克隆与复制">三、 变量交互：移动、克隆与复制</a></h2>
<h3 id="1-移动-move"><a class="header" href="#1-移动-move">1. 移动 (Move)</a></h3>
<p>对于存储在堆上的复杂类型（如 <code>String</code>），赋值操作默认是“移动”。为了防止 <strong>双重释放</strong> ，Rust 会使原变量失效。</p>
<pre class="playground"><code class="language-rust edition">fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // 所有权移动到了 s2，s1 此时已失效

    // println!("{s1}"); // ❌ 编译错误：使用了已移动的值
    println!("{s2}");    // ✅ 有效
}</code></pre>
<h3 id="2-克隆-clone--深拷贝"><a class="header" href="#2-克隆-clone--深拷贝">2. 克隆 (Clone) —— 深拷贝</a></h3>
<p>如果你确实需要复制堆上的数据，必须显式调用 <code>clone</code>。</p>
<pre class="playground"><code class="language-rust edition">fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone(); // 在堆上产生了一份完整副本

    println!("s1 = {s1}, s2 = {s2}"); // ✅ 两者均有效
}</code></pre>
<h3 id="3-复制-copy--栈数据拷贝"><a class="header" href="#3-复制-copy--栈数据拷贝">3. 复制 (Copy) —— 栈数据拷贝</a></h3>
<p>对于简单、固定大小且完全存储在栈上的类型，Rust 会执行自动拷贝，而不会使原变量失效。常见的 <code>Copy</code> 类型包括：所有的整数、浮点数、布尔值、字符，以及只包含这些类型的元组。</p>
<pre class="playground"><code class="language-rust edition">fn main() {
    let x = 5;
    let y = x; // 栈数据直接拷贝，不涉及所有权转移
    println!("x = {x}, y = {y}"); // ✅ 两者均有效
}</code></pre>
<hr>
<h2 id="四-引用与借用-references--borrowing"><a class="header" href="#四-引用与借用-references--borrowing">四、 引用与借用 (References &amp; Borrowing)</a></h2>
<p>如果你不想转移所有权，但又想使用数据，就需要“借用”。引用（<code>&amp;</code>）就像是现实中的借书：你可以看书，但书不属于你，看完得还。</p>
<h3 id="1-不可变借用-t"><a class="header" href="#1-不可变借用-t">1. 不可变借用 (<code>&amp;T</code>)</a></h3>
<p>你可以同时拥有多个不可变引用，因为“只读”不会引起数据竞争。</p>
<pre class="playground"><code class="language-rust edition">fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
} // s 离开作用域，但因为它只是引用，所以不会发生 drop

fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&amp;s1); // 传入引用
    println!("'{s1}' 的长度是 {len}"); // ✅ s1 依然有效
}</code></pre>
<h3 id="2-可变借用-mut-t"><a class="header" href="#2-可变借用-mut-t">2. 可变借用 (<code>&amp;mut T</code>)</a></h3>
<p>如果你需要修改借用的数据，必须使用可变引用。但它有极强的限制：<strong>在同一作用域内，特定数据只能有一个可变引用。</strong></p>
<pre class="playground"><code class="language-rust edition">fn change(some_string: &amp;mut String) {
    some_string.push_str(", world");
}

fn main() {
    let mut s = String::from("hello");
    change(&amp;mut s);
    println!("{s}");
}</code></pre>
<h3 id="3-借用规则总结"><a class="header" href="#3-借用规则总结">3. 借用规则总结</a></h3>
<p>为了彻底消除 <strong>数据竞争</strong> ，Rust 强制执行以下规则：</p>
<ul>
<li><strong>在任何给定时间，你要么只能有一个可变引用，要么可以有任意数量的不可变引用。</strong></li>
<li><strong>引用必须始终有效（防止悬垂引用）。</strong></li>
</ul>
<hr>
<h2 id="五-nll更智能的借用检查"><a class="header" href="#五-nll更智能的借用检查">五、 NLL：更智能的借用检查</a></h2>
<p>在旧版 Rust 中，引用的作用域持续到大括号结束。现代 Rust 使用了  <strong>NLL (Non-Lexical Lifetimes)</strong> ，引用的作用域在<strong>最后一次使用</strong>处结束。这解决了许多“本该通过但没通过”的编译问题。</p>
<pre class="playground"><code class="language-rust edition">fn main() {
    let mut s = String::from("hello");

    let r1 = &amp;s; 
    let r2 = &amp;s;
    println!("{r1} and {r2}"); 
    // r1 和 r2 在此处之后不再使用，其作用域结束

    let r3 = &amp;mut s; // ✅ 允许，因为之前的不可变借用已失效
    println!("{r3}");
}</code></pre>
<hr>
<h2 id="六-悬垂引用-dangling-references"><a class="header" href="#六-悬垂引用-dangling-references">六、 悬垂引用 (Dangling References)</a></h2>
<p>Rust 会在编译期阻止你返回局部变量的引用，因为局部变量在函数结束时会被释放。</p>
<pre class="playground"><code class="language-rust edition">// ❌ 无法通过编译
// fn dangle() -&gt; &amp;String {
//     let s = String::from("hello");
//     &amp;s // 返回了对局部变量 s 的引用
// } 

// ✅ 正确做法：直接返回 String (移动所有权)
fn no_dangle() -&gt; String {
    let s = String::from("hello");
    s 
}

fn main() {
    let s = no_dangle();
}</code></pre>
<hr>
<h2 id="七-自动释放drop-与-raii"><a class="header" href="#七-自动释放drop-与-raii">七、 自动释放：Drop 与 RAII</a></h2>
<p>Rust 通过 <code>Drop</code> trait 实现  <strong>RAII (资源获取即初始化)</strong> 。当变量超出作用域时，Rust 自动调用 <code>drop</code> 方法释放堆内存。</p>
<pre class="playground"><code class="language-rust edition">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!("正在清理数据: `{}`", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer { data: String::from("my stuff") };
    let d = CustomSmartPointer { data: String::from("other stuff") };
    println!("CustomSmartPointers 已创建。");
} // 此处 d 先被 drop，然后 c 被 drop</code></pre>
<hr>
<h3 id="如何写出符合所有权的代码"><a class="header" href="#如何写出符合所有权的代码">如何写出符合所有权的代码？</a></h3>
<ol>
<li><strong>优先借用</strong> ：除非你确实需要获取数据的所有权（例如要把数据存入结构体中），否则优先使用引用 <code>&amp;T</code>。</li>
<li><strong>减少 Clone</strong> ：如果发现代码里到处是 <code>.clone()</code>，通常说明所有权设计有误。</li>
<li><strong>利用作用域</strong> ：可以通过手动添加 <code>{ }</code> 来缩短变量或引用的生命周期，从而解决借用冲突。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="语句与表达式"><a class="header" href="#语句与表达式">语句与表达式</a></h1>
<p>在 Rust 的设计哲学中，<strong>一切皆表达式</strong>是一个核心概念。理解<strong>语句Statements</strong> 与 <strong>表达式Expressions</strong>的区别，是掌握 Rust 函数返回值、控制流赋值以及函数式编程风格的关键。</p>
<hr>
<h2 id="一基本定义"><a class="header" href="#一基本定义">一、基本定义</a></h2>
<h3 id="1-语句-statements"><a class="header" href="#1-语句-statements">1. 语句 (Statements)</a></h3>
<p>语句是<strong>执行某种操作但不返回值</strong>的指令。</p>
<ul>
<li>在 Rust 中，最常见的语句是变量声明 <code>let x = 5;</code>。</li>
<li>语句通常以分号 <code>;</code> 结尾。</li>
<li><strong>注意</strong> ：因为语句不返回值，所以你不能把 <code>let</code> 语句赋值给另一个变量（例如 <code>let x = (let y = 5);</code> 会报错）。</li>
</ul>
<h3 id="2-表达式-expressions"><a class="header" href="#2-表达式-expressions">2. 表达式 (Expressions)</a></h3>
<p>表达式会计算并产生一个 <strong>值</strong> 。</p>
<ul>
<li>数学运算（如 <code>5 + 6</code>）、函数调用、宏调用都是表达式。</li>
<li>甚至大括号包裹的代码块 <code>{}</code> 也是表达式。</li>
<li><strong>核心规则</strong> ：表达式的结尾 <strong>没有分号</strong> 。如果你在表达式末尾加上分号，它就会变成一条语句，返回值会变成单元类型 <code>()</code>。</li>
</ul>
<hr>
<h2 id="二块表达式-block-expressions"><a class="header" href="#二块表达式-block-expressions">二、块表达式 (Block Expressions)</a></h2>
<p>在 Rust 中，我们可以使用 <code>{}</code> 创建一个作用域，这个作用域本身就是一个表达式，它的值是其中<strong>最后一行表达式</strong>的值。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let y = {
        let x = 3;
        x + 1  // 注意：这里没有分号！
    };

    println!("y 的值是: {y}"); // 输出 4
}</code></pre>
<blockquote>
<p>深度解析：</p>
<p>如果你在 x + 1 后面加了分号，变成 x + 1;，那么这个块就不再返回 4，而是返回 ()（unit 类型），编译器会因此报错（如果 y 预期是整数类型的话）。</p>
</blockquote>
<hr>
<h2 id="三函数中的应用隐式返回"><a class="header" href="#三函数中的应用隐式返回">三、函数中的应用：隐式返回</a></h2>
<p>Rust 函数不需要显式写 <code>return</code> 关键字来返回值。只要函数体的最后一行是一个 <strong>表达式</strong> （没有分号），该表达式的值就会自动作为函数的返回值。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn add_one(x: i32) -&gt; i32 {
    x + 1 // 这是一个表达式，隐式返回其结果
}

fn main() {
    let result = add_one(10);
    println!("结果是: {result}");
}</code></pre>
<p><strong>显式 return 与隐式返回的区别：</strong></p>
<ul>
<li><strong>隐式返回</strong> （不带 <code>return</code> 和分号）：Rust 推荐的标准写法，代码更简洁。</li>
<li><strong>显式 return</strong> ：通常用于函数中途提前退出（提前返回）。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn check_number(n: i32) -&gt; String {
    if n &lt; 0 {
        return String::from("错误：负数"); // 提前退出
    }
  
    String::from("正常") // 隐式返回
}
fn main() {
    let result = check_number(-10);
    println!("检查结果: {result}");
}</code></pre>
<hr>
<h2 id="四常见陷阱分号的影响"><a class="header" href="#四常见陷阱分号的影响">四、常见陷阱：分号的影响</a></h2>
<p>分号在 Rust 中不仅仅是结束符，它是 <strong>类型的转换器</strong> 。它将一个“有值”的表达式转换成一个“无值”的语句。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>示例</strong></th><th><strong>类别</strong></th><th><strong>结果/值</strong></th></tr>
</thead>
<tbody>
<tr><td><code>5 + 6</code></td><td>表达式</td><td><code>11</code></td></tr>
<tr><td><code>5 + 6;</code></td><td>语句</td><td><code>()</code>(Unit)</td></tr>
<tr><td><code>let x = 5;</code></td><td>语句</td><td>无值（报错不能被赋值）</td></tr>
<tr><td><code>if true { 1 } else { 0 }</code></td><td>表达式</td><td><code>1</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="五综合示例在一个函数中观察"><a class="header" href="#五综合示例在一个函数中观察">五、综合示例：在一个函数中观察</a></h2>
<p>下面的代码展示了如何在实际逻辑中混合使用语句和表达式：</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 5;

    // 一个复杂的赋值表达式
    let result = if x &gt; 0 {
        let temp = x * 2; // 语句
        temp + 10         // 表达式：整个 if 块的值变为 20
    } else {
        0                 // 表达式
    };

    println!("最终计算结果: {result}");

    // 调用一个只有语句的函数
    print_unit();
}

// 该函数没有返回值，或者说隐式返回 ()
fn print_unit() {
    println!("我执行了一些操作，但我返回的是单元类型 ()");
    // 这里其实隐藏了一个没有分号的 ()
}</code></pre>
<hr>
<h2 id="六操作符优先级"><a class="header" href="#六操作符优先级">六、操作符优先级</a></h2>
<p>在Rust中，一切皆表达式，那么了解表达式的优先级就非常重要了，将Rust的操作符和表达式按优先级由高到低的顺序列了出来，具有相同优先级的操作符按相关性给定的顺序进行优先级计算。</p>
<img src="images/操作符优先级.png" alt="操作符优先级" style="zoom:70%;" />
<h3 id="总结对比"><a class="header" href="#总结对比">总结对比</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>特性</strong></th><th><strong>语句 (Statements)</strong></th><th><strong>表达式 (Expressions)</strong></th></tr>
</thead>
<tbody>
<tr><td><strong>是否有分号</strong></td><td><strong>是</strong> （通常以 <code>;</code>结尾）</td><td><strong>否</strong> （末尾无 <code>;</code>）</td></tr>
<tr><td><strong>是否有返回值</strong></td><td><strong>否</strong> （返回 <code>()</code>）</td><td><strong>是</strong></td></tr>
<tr><td><strong>典型例子</strong></td><td><code>let x = 5;</code></td><td><code>x + 5</code>/<code>my_func()</code></td></tr>
<tr><td><strong>函数末尾</strong></td><td>不会作为返回值</td><td><strong>会自动作为返回值</strong></td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="条件语句"><a class="header" href="#条件语句">条件语句</a></h1>
<p>在 Rust 中，控制流和模式匹配不仅仅是逻辑的分叉口，它们更是安全性的守护者。Rust 编译器通过严格的类型检查和“穷尽性检查”，确保你在处理各种逻辑情况时不会留下漏洞。</p>
<p>以下是整理的 Rust 控制流、循环流与 <code>match</code> 表达式的详细指南。</p>
<hr>
<h2 id="一控制流conditional-control-flow"><a class="header" href="#一控制流conditional-control-flow">一、控制流（Conditional Control Flow）</a></h2>
<p>控制流是程序根据特定条件执行不同代码的能力。Rust 的 <code>if</code> 分支结构非常严谨。</p>
<h3 id="1-if--else-if--else"><a class="header" href="#1-if--else-if--else">1. <code>if / else if / else</code></a></h3>
<p>Rust 要求条件表达式必须是严格的 <code>bool</code> 类型。这意味着你不能像在 C 或 JavaScript 中那样使用数字（如 <code>if (1)</code>）来代表逻辑真。这种设计避免了因隐式类型转换导致的逻辑错误。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 10;

    if x &gt; 0 {
        println!("positive");
    } else if x == 0 {
        println!("zero");
    } else {
        println!("negative");
    }
}</code></pre>
<h3 id="2-if-是表达式可以返回值"><a class="header" href="#2-if-是表达式可以返回值">2. <code>if</code> 是表达式：可以返回值</a></h3>
<p>在 Rust 中，if 是一个表达式而不是语句。这意味着它可以产生一个值，并将其直接赋值给变量。</p>
<p><strong>注意：所有分支返回的数据类型必须完全一致，且分支末尾不要写分号，否则该分支会返回单元类型 ()。</strong></p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 7;
    // if 表达式赋值
    let y = if x % 2 == 0 { 100 } else { 200 };
    // let y = if x % 2 == 0 { 100 } else { 200; };
    println!("y 的值是: {y}"); // 输出 200
}</code></pre>
<h3 id="3-if-let只关心某一种模式"><a class="header" href="#3-if-let只关心某一种模式">3. <code>if let</code>：只关心某一种模式</a></h3>
<p>当你只想处理某一种特定的模式（例如 <code>Option</code> 中的 <code>Some</code>），而对其他情况（如 <code>None</code>）不感兴趣时，<code>if let</code> 是比 <code>match</code> 更简洁的选择。它减少了样板代码的编写。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v: Option&lt;i32&gt; = Some(10);

    // 只解构 Some，忽略 None
    if let Some(n) = v {
        println!("解构成功，n = {n}");
    } else {
        println!("这里是 None 的情况");
    }
}</code></pre>
<h3 id="4-let-else模式不匹配就提前退出"><a class="header" href="#4-let-else模式不匹配就提前退出">4. <code>let else</code>：模式不匹配就提前退出</a></h3>
<p>这是 Rust 1.65 引入的新语法，非常适合编写“守护语句（Guard Statement）”。如果在解构时失败，必须在 <code>else</code> 块中通过 <code>return</code>、<code>break</code> 或 <code>panic!</code> 强制退出当前作用域。这使得后续代码可以放心地使用解构出来的变量。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn parse_first(v: Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    // 如果无法获取第一个元素，直接返回 None
    let Some(first) = v.get(0) else {
        return None; 
    };
    // 此时 first 已经成功绑定，且作用域在外面
    Some(*first)
}

fn main() {
    let numbers = vec![1, 2, 3];
    if let Some(val) = parse_first(numbers) {
        println!("第一个值是: {val}");
    }
}</code></pre>
<hr>
<h2 id="二循环流looping-control-flow"><a class="header" href="#二循环流looping-control-flow">二、循环流（Looping Control Flow）</a></h2>
<p>Rust 提供了三种循环原语，它们在底层性能上是一致的，但在语义表达上各有侧重。</p>
<h3 id="1-loop无限循环--break-返回值"><a class="header" href="#1-loop无限循环--break-返回值">1. <code>loop</code>：无限循环 + <code>break</code> 返回值</a></h3>
<p><code>loop</code> 常用于需要反复执行直到满足某个条件（如轮询任务或重试逻辑）的场景。由于 <code>loop</code> 保证一定会运行（直到被 break），它也可以作为表达式返回一个值。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut n = 0;

    let result = loop {
        n += 1;
        if n == 5 {
            break n * 2; // 带值跳出循环
        }
    };

    println!("结果是: {result}"); // 10
}</code></pre>
<h3 id="2-while条件循环"><a class="header" href="#2-while条件循环">2. <code>while</code>：条件循环</a></h3>
<p>这是最传统的循环方式，每次迭代开始前都会检查条件。适合处理那些依赖外部状态变化的逻辑。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut n = 3;
    while n &gt; 0 {
        println!("{n}...");
        n -= 1;
    }
    println!("发射！");
}</code></pre>
<h3 id="3-for遍历迭代器最常用"><a class="header" href="#3-for遍历迭代器最常用">3. <code>for</code>：遍历迭代器（最常用）</a></h3>
<p><code>for</code> 循环通过迭代器工作，是 Rust 中最安全的选择，因为它不会出现索引越界（Out of Bounds）的问题。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>使用方法</th><th>等价使用方式</th><th>所有权</th></tr>
</thead>
<tbody>
<tr><td><code>for item in collection</code></td><td><code>for item in IntoIterator::into_iter(collection)</code></td><td>转移所有权</td></tr>
<tr><td><code>for item in &amp;collection</code></td><td><code>for item in collection.iter()</code></td><td>不可变借用</td></tr>
<tr><td><code>for item in &amp;mut collection</code></td><td><code>for item in collection.iter_mut()</code></td><td>可变借用</td></tr>
</tbody>
</table>
</div>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    // 1. 范围遍历
    for i in 0..3 { println!("范围 A: {i}"); }    // 0, 1, 2
    for i in 0..=3 { println!("范围 B: {i}"); }   // 0, 1, 2, 3

    // 2. 遍历集合（借用与移动）
    let v = vec![10, 20, 30];
    for x in &amp;v { println!("借用元素: {x}"); }    // v 依然可用

    // 3. 可变借用遍历
    let mut nums = vec![1, 2, 3];
    for x in &amp;mut nums {
        *x *= 10; // 修改原始数据
    }

    // 4. 带索引遍历
    for (i, val) in nums.iter().enumerate() {
        println!("索引 {i} 的值是 {val}");
    }
}</code></pre>
<h3 id="4-循环控制与标签"><a class="header" href="#4-循环控制与标签">4. 循环控制与标签</a></h3>
<ul>
<li><code>continue</code>：结束当前迭代，立即开始下一次。</li>
<li><code>break</code>：立即退出当前循环。</li>
<li><strong>循环标签</strong> ：在处理多层嵌套循环时，你可以给循环起名字（以单引号开头），以便在内层直接退出外层, <strong>影响可读性</strong>。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    'outer: for i in 0..10 {
        'inner: for j in 0..10 {
            if i + j == 5 {
                println!("找到目标：i={}, j={}", i, j);
                break 'outer; // 跳出最外层循环
            }
        }
    }
}</code></pre>
<hr>
<h2 id="三match-表达式pattern-matching"><a class="header" href="#三match-表达式pattern-matching">三、<code>match</code> 表达式（Pattern Matching）</a></h2>
<p><code>match</code> 是 Rust 的“核心杀手锏”，它非常类似于多分支的 <code>switch</code>，但功能要强大得多。它强制要求 <strong>穷尽性检查</strong> ，即你必须处理所有可能的情况。</p>
<h3 id="1-基本用法与模式"><a class="header" href="#1-基本用法与模式">1. 基本用法与模式</a></h3>
<p><code>match</code> 的每个分支被称为一个“臂（Arm）”。<code>_</code> 是通配符，用于捕获所有未明确列出的情况。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let n = 3;
    match n {
        1 =&gt; println!("一"),
        2 =&gt; println!("二"),
        3 =&gt; println!("三"),
        _ =&gt; println!("其他数字"), // 必须有这一行，除非 n 的所有可能已被覆盖
    }
}</code></pre>
<h3 id="2-范围与多重匹配"><a class="header" href="#2-范围与多重匹配">2. 范围与多重匹配</a></h3>
<p>你可以使用 <code>|</code> 匹配多个值，或使用 <code>..=</code> 匹配一个闭区间。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let score = 85;
    match score {
        0..=59 =&gt; println!("不及格"),
        60..=80 =&gt; println!("合格"),
        81..=100 =&gt; println!("优秀"),
        _ =&gt; println!("无效分数"),
    }

    let day = 6;
    match day {
        1 | 2 | 3 | 4 | 5 =&gt; println!("工作日"),
        6 | 7 =&gt; println!("周末"),
        _ =&gt; println!("火星日?"),
    }
}</code></pre>
<h3 id="3-解构复合类型元组结构体枚举"><a class="header" href="#3-解构复合类型元组结构体枚举">3. 解构复合类型（元组/结构体/枚举）</a></h3>
<p><code>match</code> 最强大的地方在于它可以“拆解”数据结构。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct Point { x: i32, y: i32 }
enum Message { Quit, Write(String) }

fn main() {
    // 1. 解构元组
    let pair = (0, -2);
    match pair {
        (0, y) =&gt; println!("在 Y 轴上: {y}"),
        (x, 0) =&gt; println!("在 X 轴上: {x}"),
        _ =&gt; println!("在象限内"),
    }

    // 2. 解构结构体
    let p = Point { x: 10, y: 0 };
    match p {
        Point { x, y: 0 } =&gt; println!("X 轴上的点，x = {x}"),
        Point { x, y } =&gt; println!("普通点 ({x}, {y})"),
    }

    // 3. 解构枚举
    let msg = Message::Write(String::from("Hello"));
    match msg {
        Message::Quit =&gt; println!("退出"),
        Message::Write(s) =&gt; println!("消息内容: {s}"),
    }
}</code></pre>
<h3 id="4-进阶匹配守卫与--绑定"><a class="header" href="#4-进阶匹配守卫与--绑定">4. 进阶：匹配守卫与 <code>@</code> 绑定</a></h3>
<ul>
<li><strong>匹配守卫 (Match Guard)</strong> ：在模式匹配的基础上增加 <code>if</code> 条件，用于更细粒度的过滤。</li>
<li><strong><code>@</code> 绑定</strong> ：允许你在匹配一个值的同时，将其绑定到一个变量上，方便后续使用。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    // 匹配守卫
    let num = Some(10);
    match num {
        Some(x) if x &gt; 5 =&gt; println!("大于 5 的数字: {x}"),
        Some(x) =&gt; println!("普通数字: {x}"),
        None =&gt; (),
    }

    // @ 绑定
    let age = 7;
    match age {
        v @ 1..=12 =&gt; println!("小孩，年龄是: {v}"),
        v @ 13..=19 =&gt; println!("青少年，年龄是: {v}"),
        _ =&gt; println!("成年人"),
    }
}</code></pre>
<h3 id="5-核心应用option-和-result"><a class="header" href="#5-核心应用option-和-result">5. 核心应用：<code>Option</code> 和 <code>Result</code></a></h3>
<p>这是 <code>match</code> 在 Rust 中最高频的出现场景，用于安全地处理可能为空或可能出错的值。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let res: Result&lt;i32, &amp;str&gt; = Ok(200);
    match res {
        Ok(code) =&gt; println!("请求成功，状态码: {code}"),
        Err(msg) =&gt; println!("请求失败: {msg}"),
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="函数与闭包"><a class="header" href="#函数与闭包">函数与闭包</a></h1>
<h2 id="一-函数-functions"><a class="header" href="#一-函数-functions">一、 函数 (Functions)</a></h2>
<p>函数是 Rust 代码的静态骨架。它们必须在编译时拥有明确的签名。</p>
<h3 id="1-基础语法与显式返回"><a class="header" href="#1-基础语法与显式返回">1. 基础语法与显式返回</a></h3>
<p>Rust 的函数参数必须标注类型，返回类型使用 <code>-&gt;</code> 标注。</p>
<pre class="playground"><code class="language-rust editable edition2024">// 逻辑概括：参数必须显式注明类型，最后一行表达式作为返回值
fn calculate_score(points: i32, multiplier: i32) -&gt; i32 {
    if points &lt; 0 {
        return 0; // 使用 return 提前退出
    }
    points * multiplier // 隐式返回（无分号）
}
fn main() {
    let score = calculate_score(10, 3);
    println!("最终得分: {score}");
}</code></pre>
<h3 id="2-函数指针-fn-类型"><a class="header" href="#2-函数指针-fn-类型">2. 函数指针 (<code>fn</code> 类型)</a></h3>
<p>函数本身可以作为参数传递，也可以存储在变量中。它的类型是小写的 <code>fn</code>。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn add_one(x: i32) -&gt; i32 { x + 1 }

fn do_math(f: fn(i32) -&gt; i32, value: i32) -&gt; i32 {
    f(value)
}

fn main() {
    let result = do_math(add_one, 5);
    println!("函数指针调用结果: {result}"); // 6
}</code></pre>
<hr>
<h2 id="二-闭包-closures"><a class="header" href="#二-闭包-closures">二、 闭包 (Closures)</a></h2>
<p><code>Rust</code> 中的闭包（<code>closures</code>）是一种匿名函数，可以捕获其环境中的变量。闭包类似于其他语言中的 <code>lambda</code> 表达式，但 <code>Rust</code> 的闭包系统与所有权和借用紧密集成，确保内存安全。闭包可以作为函数参数、返回值，或存储在变量中，常用于迭代器、线程和回调。<code>Rust</code> 闭包实现了<code>Fn trait</code> 家族（<code>Fn、FnMut、FnOnce</code>），根据捕获方式决定其行为。最核心的特性是 <strong>捕获环境</strong> 。它们通常比函数更简洁，且支持类型推导。</p>
<h3 id="1-语法与自动推导"><a class="header" href="#1-语法与自动推导">1. 语法与自动推导</a></h3>
<p>闭包不强制写类型，编译器会根据第一次调用的上下文锁定类型。语法：<code>|params| expression</code> 或 <code>{ body }</code>。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    // 闭包标准语法
    let closure_annotated = |x: i32| -&gt; i32 { x + 1 };
  
    // 自动推导简写
    let closure_inferred = |x| x + 1;

    println!("{}", closure_annotated(1));
    println!("{}", closure_inferred(1));
}</code></pre>
<h3 id="2-捕获方式不可变可变移动"><a class="header" href="#2-捕获方式不可变可变移动">2. 捕获方式：不可变、可变、移动</a></h3>
<p>闭包通过三种方式从作用域捕获变量：</p>
<ul>
<li><strong>不可变借用 (<code>&amp;T</code>)</strong> ：默认方式。</li>
<li><strong>可变借用 (<code>&amp;mut T</code>)</strong> ：当闭包内部修改变量时。</li>
<li><strong>移动所有权 (<code>T</code>)</strong> ：使用 <code>move</code> 关键字，常用于异步或多线程。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 4;
    let equal_to_x = |z| z == x;  // 借用 x (&amp;x)
    println!("相等？{}", equal_to_x(4));  // 输出: 相等？true
    println!("x 仍有效: {}", x);  // x 未移动
    //可变借用
    let mut count = 0;
    let mut inc = || {
        count += 1; // 自动推导为 可变借用
        println!("当前计数: {count}");
    };
    inc();
    inc();
    // 强制移动所有权
    let text = String::from("hello");
    let print_text = move || println!("移动后的文本: {text}");
    print_text();
    // println!("{text}"); // ❌ 报错：text 已移动到闭包中
}</code></pre>
<hr>
<h2 id="三-闭包特征-fn-fnmut-fnonce"><a class="header" href="#三-闭包特征-fn-fnmut-fnonce">三、 闭包特征 (Fn, FnMut, FnOnce)</a></h2>
<p>当闭包作为参数传递时，我们需要使用这三个 Trait 来约束它：</p>
<ul>
<li><strong><code>FnOnce</code></strong> ：调用一次，消耗闭包（可能移动捕获）。</li>
<li><strong><code>FnMut</code></strong> ：可多次调用，可修改捕获。</li>
<li><strong><code>Fn</code></strong> ：可多次调用，只读捕获。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn run_once&lt;F&gt;(f: F) where F: FnOnce() {
    f();
}

fn main() {
    let s = String::from("once");
    let consume_s = || drop(s); // 该闭包消费了 s 的所有权
  
    run_once(consume_s);
    // run_once(consume_s); // ❌ 报错：闭包已被消费
}</code></pre>
<hr>
<h2 id="四-高级进阶函数与闭包作为返回值"><a class="header" href="#四-高级进阶函数与闭包作为返回值">四、 高级进阶：函数与闭包作为返回值</a></h2>
<p>这是 Rust 中最具灵活性的部分。由于闭包没有具体的名字，返回它们需要特殊的处理。</p>
<h3 id="1-返回普通函数指针-fn"><a class="header" href="#1-返回普通函数指针-fn">1. 返回普通函数指针 (<code>fn</code>)</a></h3>
<p>适用于逻辑固定、不捕获外部变量的情况。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn apply&lt;F&gt;(f: F, x: i32) -&gt; i32
where
    F: FnOnce(i32) -&gt; i32,  // bound FnOnce
{
    f(x)
}

fn main() {
    let double = |n| n * 2;
    println!("结果: {}", apply(double, 5));  // 输出: 结果: 10
}</code></pre>
<h3 id="2-返回闭包静态分发-impl-trait"><a class="header" href="#2-返回闭包静态分发-impl-trait">2. 返回闭包：静态分发 (<code>impl Trait</code>)</a></h3>
<p>这是返回闭包最常用的方式。它效率高（无堆分配），但要求所有分支返回<strong>同一种</strong>闭包。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn create_multiplier(factor: i32) -&gt; impl Fn(i32) -&gt; i32 {
    // 关键：必须使用 move，将 factor 移入闭包
    // 否则 factor 会在函数结束时释放，导致引用失效
    move |x| x * factor
}

fn main() {
    let double = create_multiplier(2);
    println!("3 的两倍是: {}", double(3));
}</code></pre>
<h3 id="3-返回闭包动态分发-boxdyn-trait"><a class="header" href="#3-返回闭包动态分发-boxdyn-trait">3. 返回闭包：动态分发 (<code>Box&lt;dyn Trait&gt;</code>)</a></h3>
<p>如果你需要根据逻辑返回不同的闭包（比如在 <code>if/else</code> 分支中返回不同的闭包代码块），必须使用 <code>Box</code>。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn get_closure(mode: bool) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    if mode {
        Box::new(|x| x + 1)
    } else {
        Box::new(|x| x * 2)
    }
}

fn main() {
    let f = get_closure(false);
    println!("执行结果: {}", f(5)); // 10
}</code></pre>
<hr>
<h2 id="总结对比-1"><a class="header" href="#总结对比-1">总结对比</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>特性</strong></th><th><strong>普通函数 (fn)</strong></th><th><strong>impl Trait 闭包</strong></th><th><strong><code>Box&lt;dyn Trait&gt;</code> 闭包</strong></th></tr>
</thead>
<tbody>
<tr><td><strong>捕获变量</strong></td><td>不支持</td><td>支持（需用 <code>move</code>）</td><td>支持（需用 <code>move</code>）</td></tr>
<tr><td><strong>返回类型</strong></td><td><code>fn(A) -&gt; B</code></td><td><code>impl Fn(A) -&gt; B</code></td><td><code>Box&lt;dyn Fn(A) -&gt; B&gt;</code></td></tr>
<tr><td><strong>内存位置</strong></td><td>代码段</td><td>栈</td><td>堆</td></tr>
<tr><td><strong>性能</strong></td><td>极高（静态）</td><td>高（静态）</td><td>略低（动态寻址）</td></tr>
<tr><td><strong>适用场景</strong></td><td>简单、纯粹的逻辑</td><td>性能敏感、单一返回路径</td><td>需要根据条件返回不同闭包</td></tr>
</tbody>
</table>
</div>
<hr>
<h3 id="-核心避坑指南"><a class="header" href="#-核心避坑指南">💡 核心避坑指南</a></h3>
<p>在返回闭包时，<strong>忘记写 <code>move</code></strong> 是新手最常见的错误。</p>
<blockquote>
<p><strong>记住</strong> ：闭包默认会尝试通过“引用”来捕获环境中的变量。但当函数结束时，这些变量会被销毁，所以闭包必须通过 <code>move</code> 把它们“打包带走”，否则你会得到一个“悬垂引用”的报错。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h1>
<p>Rust 的错误处理体系以其<strong>严谨性</strong>著称。它不使用传统的 <code>try-catch</code> 异常机制，而是通过类型系统将错误显式化，强制开发者在编译期就面对可能的失败。</p>
<hr>
<h2 id="一-不可恢复错误panic"><a class="header" href="#一-不可恢复错误panic">一、 不可恢复错误：<code>panic!</code></a></h2>
<p>当程序遇到无法恢复的错误时（如数组越界或断言失败），Rust 使用 panic! 宏来终止执行。这会 unwind 栈（清理资源）或直接 abort（不清理，适合嵌入式系统）。</p>
<h3 id="1-发生什么"><a class="header" href="#1-发生什么">1. 发生什么？</a></h3>
<ol>
<li>程序打印错误信息。</li>
<li><strong>展开（Unwinding）</strong> ：Rust 沿着栈往回走，清理每个函数的数据（释放所有权）。</li>
<li>程序退出。</li>
</ol>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    // 主动触发 panic
    // panic!("这里发生了不可预见的灾难！");

    let v = vec![1, 2, 3];
    v[99]; // ❌ 被动触发 panic：索引越界
}</code></pre>
<p>当你取到了一个不属于你的值，这在很多时候会导致程序上的逻辑 BUG！ 有编程经验的人都知道这种逻辑上的 BUG 是多么难被发现和修复！因此程序直接崩溃，然后告诉我们问题发生的位置，最后我们对此进行修复，这才是最合理的软件开发流程，而不是把问题藏着掖着：</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thread 'main' (12) panicked at src/main.rs:6:6:
index out of bounds: the len is 3 but the index is 99
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
<span class="boring">}</span></code></pre>
<p>好的，现在成功知道问题发生的位置，但是如果我们想知道该问题之前经过了哪些调用环节，该怎么办？那就按照提示使用 <code>RUST_BACKTRACE=1 cargo run</code> 或 <code>$env:RUST_BACKTRACE=1 ; cargo run</code> 来再一次运行程序</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:6:6
stack backtrace:
   0: rust_begin_unwind
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/std/src/panicking.rs:517:5
   1: core::panicking::panic_fmt
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:101:14
   2: core::panicking::panic_bounds_check
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:77:5
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:184:10
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:15:9
   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/alloc/src/vec/mod.rs:2465:9
   6: world_hello::main
             at ./src/main.rs:4:5
   7: core::ops::function::FnOnce::call_once
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/ops/function.rs:227:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
<span class="boring">}</span></code></pre>
<p>上面的代码就是一次栈展开（也称栈回溯），它包含了函数调用的顺序，当然按照逆序排列：最近调用的函数排在列表的最上方。因为咱们的 main 函数基本是最先调用的函数了，所以排在了倒数第二位，还有一个关注点，排在最顶部最后一个调用的函数是 rust_begin_unwind，该函数的目的就是进行栈展开，呈现这些列表信息给我们。</p>
<p>要获取到栈回溯信息，你还需要开启 debug 标志，该标志在使用 cargo run 或者 cargo build 时自动开启（这两个操作默认是 Debug 运行方式）。同时，栈展开信息在不同操作系统或者 Rust 版本上也有所不同。</p>
<h3 id="2-何时使用"><a class="header" href="#2-何时使用">2. 何时使用？</a></h3>
<ul>
<li><strong>示例代码或原型</strong> ：快速展示逻辑。</li>
<li><strong>测试代码</strong> ：断言失败。</li>
<li><strong>逻辑不可达</strong> ：你确信这段代码永远不会运行到，除非有严重的 Bug。</li>
</ul>
<hr>
<h2 id="二-可恢复错误option-与-result"><a class="header" href="#二-可恢复错误option-与-result">二、 可恢复错误：<code>Option</code> 与 <code>Result</code></a></h2>
<p>这是 Rust 错误处理的核心，通过两个枚举来包裹“可能不存在的值”或“可能失败的操作”。Rust 不使用异常，而是返回枚举类型：</p>
<ul>
<li><strong>Option</strong>：表示可能为空的值。<strong>Some(T) 或 None</strong>。</li>
<li><strong>Result&lt;T, E&gt;</strong>：表示成功或失败。<strong>Ok(T) 或 Err(E)</strong>。</li>
</ul>
<h3 id="1-optiont值可能不存在"><a class="header" href="#1-optiont值可能不存在">1. <code>Option&lt;T&gt;</code>：值可能不存在</a></h3>
<p>用于表示一个值要么有（<code>Some(T)</code>），要么没有（<code>None</code>）。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn find_index(target: i32, list: Vec&lt;i32&gt;) -&gt; Option&lt;usize&gt; {
    for (i, &amp;item) in list.iter().enumerate() {
        if item == target { return Some(i); }
    }
    None
}

fn main() {
    let list = vec![10, 20, 30];
    match find_index(20, list) {
        Some(index) =&gt; println!("找到索引: {index}"),
        None =&gt; println!("未找到"),
    }
}</code></pre>
<h3 id="2-resultt-e操作可能失败"><a class="header" href="#2-resultt-e操作可能失败">2. <code>Result&lt;T, E&gt;</code>：操作可能失败</a></h3>
<p>用于表示一个操作要么成功（<code>Ok(T)</code>），要么失败（<code>Err(E)</code>）。</p>
<pre class="playground"><code class="language-rust editable edition2024">use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let _file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!("打开文件失败: {:?}", error),
    };
}</code></pre>
<h3 id="模式匹配和-unwrap"><a class="header" href="#模式匹配和-unwrap">模式匹配和 unwrap</a></h3>
<ul>
<li><strong>match</strong>：最安全的方式。</li>
<li><strong>unwrap()</strong>：如果 Ok 返回值，否则 panic!（不推荐生产环境）。</li>
<li><strong>expect(“消息”)</strong>：类似 unwrap，但自定义 panic 消息。</li>
<li><strong>unwrap_or(default)</strong>：为 Option/Result 提供默认值。</li>
<li><strong>unwrap_or_else(closure)</strong>：懒惰计算默认值。</li>
</ul>
<hr>
<h2 id="三-常用组合器-combinators"><a class="header" href="#三-常用组合器-combinators">三、 常用组合器 (Combinators)</a></h2>
<p>组合器允许你以<strong>函数式</strong>的风格链式处理 <code>Option</code> 和 <code>Result</code>，避免层层嵌套的 <code>match</code>。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>组合器</strong></th><th><strong>作用描述</strong></th></tr>
</thead>
<tbody>
<tr><td><strong><code>.map()</code></strong></td><td>仅对成功（<code>Some</code>/<code>Ok</code>）的值进行转换</td></tr>
<tr><td><strong><code>.and_then()</code></strong></td><td>类似 <code>map</code>，但闭包也返回 <code>Result/Option</code>（自动平铺嵌套）</td></tr>
<tr><td><strong><code>.unwrap_or()</code></strong></td><td>如果失败/缺失，则返回一个默认值</td></tr>
<tr><td><strong><code>.unwrap_or_else()</code></strong></td><td>类似 <code>unwrap_or</code>，但默认值通过闭包计算（延迟求值）</td></tr>
<tr><td><strong><code>.map_err()</code></strong></td><td>仅对 <code>Err</code> 进行转换（通常用于转换错误类型）</td></tr>
</tbody>
</table>
</div>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    // --- 1. .map(): 只转换成功的值，忽略失败 ---
    let s = Some("5");
    let n = s.map(|val| val.parse::&lt;i32&gt;().unwrap_or(0)); 
    // n 现在是 Some(5)

    // --- 2. .and_then(): 展平嵌套（类似 flat_map） ---
    // 如果转换函数也返回 Option/Result，用 and_then 防止出现 Option&lt;Option&lt;T&gt;&gt;
    let get_val = |i: i32| if i &gt; 0 { Some(i * 2) } else { None };
    let result = Some(10).and_then(get_val); 
    // result 是 Some(20)，而不是 Some(Some(20))

    // --- 3. .unwrap_or() 与 .unwrap_or_else(): 兜底默认值 ---
    let x: Option&lt;i32&gt; = None;
    let val = x.unwrap_or(0); // 如果是 None，则返回 0
  
    // or_else 接受闭包，适合计算默认值开销较大的场景（延迟求值）
    let val_lazy = x.unwrap_or_else(|| {
        // 执行复杂的计算过程...
        100 
    });

    // --- 4. .map_err(): 只处理错误，不改动成功值 ---
    let res: Result&lt;i32, i32&gt; = Err(404);
    let updated_res = res.map_err(|e| format!("Error code: {}", e));
    // updated_res 是 Err("Error code: 404")

    println!("组合器处理结果: {:?}, {}, {:?}", n, val, updated_res);
}</code></pre>
<hr>
<h2 id="四--操作符错误传播的捷径"><a class="header" href="#四--操作符错误传播的捷径">四、 <code>?</code> 操作符：错误传播的捷径</a></h2>
<p><code>?</code> 操作符是 Rust 错误传播的语法糖。它可以极大地简化代码，让逻辑保持清晰。程序几乎不太可能只有 A-&gt;B 形式的函数调用，一个设计良好的程序，一个功能涉及十几层的函数调用都有可能。而错误处理也往往不是哪里调用出错，就在哪里处理，实际应用中，大概率会把错误层层上传然后交给调用链的上游函数进行处理，错误传播将极为常见</p>
<h3 id="1-工作原理"><a class="header" href="#1-工作原理">1. 工作原理</a></h3>
<p>当你在一个返回 <code>Result</code> 的表达式后面加 <code>?</code> 时：</p>
<ol>
<li>如果结果是 <code>Ok</code>，它会<strong>自动解包</strong>出里面的值，程序继续执行。</li>
<li>如果结果是 <code>Err</code>，它会立即 <strong>提前返回</strong> （Return）整个函数，并将错误传递给调用者。</li>
</ol>
<pre class="playground"><code class="language-rust editable edition2024">use std::fs::File;
use std::io::{self, Read};

fn read_username() -&gt; Result&lt;String, io::Error&gt; {
    // 如果 open 失败，直接返回 Err；如果成功，f 绑定为 File 对象
    let mut f = File::open("name.txt")?; 
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?; // 如果读取失败，直接返回 Err
    Ok(s)
}
fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let username = read_username()?;
    println!("用户名: {}", username);
    Ok(())
}</code></pre>
<ul>
<li>解释：? 等价于</li>
</ul>
<pre><code class="language-txt">let mut file = match File::open(filename) {
    Ok(f) =&gt; f,
    Err(e) =&gt; return Err(e),
};
</code></pre>
<ul>
<li>要求：函数必须返回 <code>Result/Option</code>。</li>
<li>链式使用：支持多个 ?，错误会向上传播。</li>
<li><code>From trait</code>：如果错误类型不同，? 会自动转换（如果实现了 From）。</li>
</ul>
<h3 id="2-使用限制"><a class="header" href="#2-使用限制">2. 使用限制</a></h3>
<ul>
<li><code>?</code> 只能在返回类型与 <code>?</code> 处理的类型<strong>相兼容</strong>的函数中使用（例如在返回 <code>Result</code> 的函数中处理 <code>Result</code>）。</li>
<li>在 <code>main</code> 函数中使用 <code>?</code> 需要将 <code>main</code> 的返回类型改为 <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>。</li>
</ul>
<hr>
<h2 id="五自定义错误类型"><a class="header" href="#五自定义错误类型">五、自定义错误类型</a></h2>
<p>对于复杂应用，定义自己的错误枚举，结合 <code>thiserror</code> 或 <code>anyhow</code> crate 更加方便。</p>
<h2 id="总结概括"><a class="header" href="#总结概括">总结概括</a></h2>
<ol>
<li><strong><code>panic!</code></strong> ：用于 <strong>程序 Bug</strong> 。当你无法预见错误或错误会导致程序状态不可靠时使用。</li>
<li><strong><code>Option</code></strong> ：用于 <strong>可能缺失</strong> 。不代表失败，只是“没有”。</li>
<li><strong><code>Result</code></strong> ：用于 <strong>可能失败</strong> 。明确区分成功数据和错误信息。</li>
<li><strong><code>?</code></strong> ：用于 <strong>传播错误</strong> 。让错误处理像写直线代码一样简单。</li>
<li><strong>组合器</strong> ：用于 <strong>优雅转换</strong> 。让数据在各种状态间流动而不需要嵌套判断。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="结构体"><a class="header" href="#结构体">结构体</a></h1>
<p>在 Rust 中，<strong>结构体Structs</strong>是构建复杂程序的基石。它允许你将相关联的数据组合在一起，创建出更有意义的自定义类型。相比于元组，结构体为每个数据片段命名，因此更加灵活且意图清晰。</p>
<hr>
<h2 id="一-结构体的三种类型"><a class="header" href="#一-结构体的三种类型">一、 结构体的三种类型</a></h2>
<p>Rust 支持三种不同风格的结构体，分别适用于不同的场景。</p>
<h3 id="1-具名结构体-classic-structs"><a class="header" href="#1-具名结构体-classic-structs">1. 具名结构体 (Classic Structs)</a></h3>
<p>最常用的类型，类似于其他语言中的类或对象，每个字段都有明确的名字。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    // 实例化结构体
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someuser123"),
        active: true,
        sign_in_count: 1,
    };

    println!("用户 {} 的邮箱是 {}", user1.username, user1.email);
}</code></pre>
<p><strong>关键点：</strong></p>
<ul>
<li>结构体通常拥有其数据，使用如 String 的拥有类型，以确保数据在结构体存在期间有效。</li>
<li>如果使用引用（如 &amp;str），需要指定生命周期（lifetime），以避免悬垂引用（dangling references）。</li>
<li>字段不能单独标记为可变，整个结构体实例必须是可变的才能修改字段。</li>
</ul>
<h3 id="2-元组结构体-tuple-structs"><a class="header" href="#2-元组结构体-tuple-structs">2. 元组结构体 (Tuple Structs)</a></h3>
<p>当你想给整个元组起个名字，但不需要为内部每个字段命名时使用。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
  
    // 注意：虽然内部类型一样，但 Color 和 Point 是不同的类型！
    println!("第一个颜色分量: {}", black.0);
}</code></pre>
<h3 id="3-单元结构体-unit-like-structs"><a class="header" href="#3-单元结构体-unit-like-structs">3. 单元结构体 (Unit-like Structs)</a></h3>
<p>没有任何字段。常用于需要在某个类型上实现 <code>Trait</code>但不需要存储数据的情况。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct AlwaysEqual;

fn main() {
    let _subject = AlwaysEqual;
}</code></pre>
<hr>
<h2 id="二-实例化"><a class="header" href="#二-实例化">二、 实例化</a></h2>
<h3 id="1-字段初始化简写-field-init-shorthand"><a class="header" href="#1-字段初始化简写-field-init-shorthand">1. 字段初始化简写 (Field Init Shorthand)</a></h3>
<p>当变量名与字段名完全相同时，可以简写。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username, // 等同于 username: username
        email,    // 等同于 email: email
        sign_in_count: 1,
    }
}

fn main() {
    let user1 = build_user(String::from("a@b.com"), String::from("user1"));
    println!("用户 {} 的邮箱是 {}", user1.username, user1.email);
}</code></pre>
<h3 id="2-结构体更新语法-struct-update-syntax"><a class="header" href="#2-结构体更新语法-struct-update-syntax">2. 结构体更新语法 (Struct Update Syntax)</a></h3>
<p>当你想要创建一个新实例，但大部分数据与旧实例相同时，使用 <code>..</code> 语法。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
fn main() {
    let user1 = User {
        email: String::from("a@b.com"),
        username: String::from("user1"),
        active: true,
        sign_in_count: 1,
    };

    // 使用 user1 的部分数据创建 user2
    let user2 = User {
        email: String::from("c@d.com"),
        ..user1 // 剩余字段直接拷贝/移动自 user1
    };
    println!("用户 {} 的邮箱是 {}", user2.username, user2.email);
    // println!("用户 {} 的邮箱是 {}", user1.username, user1.email);
    // 注意：由于 String 发生了所有权转移，user1.username 此时已失效！除非那些字段实现了 Copy trait
}</code></pre>
<h3 id="3-访问和更新字段"><a class="header" href="#3-访问和更新字段">3. 访问和更新字段</a></h3>
<p>使用点号 . 访问字段。要更新，需要可变实例（mut）。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
fn main() {
    let mut user1 = User {
        email: String::from("a@b.com"),
        username: String::from("user1"),
        active: true,
        sign_in_count: 1,
    };
    user1.email = String::from("newemail@example.com");
    println!("用户 {} 的邮箱是 {}", user1.username, user1.email);
}</code></pre>
<hr>
<h2 id="三-结构体方法impl-块"><a class="header" href="#三-结构体方法impl-块">三、 结构体方法：<code>impl</code> 块</a></h2>
<p>在 Rust 中，数据定义（<code>struct</code>）和行为定义（<code>impl</code>）是分开的。</p>
<ul>
<li><strong>方法 (Methods)</strong> ：第一个参数是 <code>self</code>，通过实例调用。</li>
<li><strong>关联函数 (Associated Functions)</strong> ：没有 <code>self</code> 参数，通过 <code>类型名::</code> 调用（类似静态方法）。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">#[derive(Debug)] // 允许通过 {:?} 打印结构体
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // 关联函数：通常用于构造函数
    fn square(size: u32) -&gt; Self {
        Self { width: size, height: size }
    }

    // 方法：计算面积
    // 使用 &amp;self 借用实例，而不是获取所有权
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    // 方法：判断当前矩形是否能容纳另一个矩形
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle::square(10); // 调用关联函数

    println!("矩形面积: {}", rect1.area());
    println!("rect1 能容纳 rect2 吗？ {}", rect1.can_hold(&amp;rect2));
    println!("打印结构体详情: {:?}", rect1);
}</code></pre>
<h3 id="关键差异与-oop"><a class="header" href="#关键差异与-oop">关键差异与 OOP</a></h3>
<ul>
<li>Rust 无自动 getter/setter，需要手动定义。</li>
<li>方法名可与字段名相同（基于语法区分）。</li>
<li>强调借用规则，与 OOP 的封装不同。</li>
<li>Rust 自动处理引用/解引用，无需 -&gt; 操作符。</li>
</ul>
<hr>
<h2 id="四-结构体与所有权"><a class="header" href="#四-结构体与所有权">四、 结构体与所有权</a></h2>
<p>这是新手最容易困惑的地方：</p>
<ol>
<li><strong>字段的所有权</strong> ：如果结构体拥有其字段的所有权（如 <code>String</code>），那么当结构体被销毁时，字段也会被销毁。结构体字段若为拥有类型（如 String），实例移动时会转移所有权。</li>
<li><strong>在结构体中存储引用</strong> ：如果你希望结构体存储一个指向外部数据的引用（如 <code>&amp;str</code>），你需要使用 <strong>生命周期（Lifetimes）</strong> 标注。</li>
</ol>
<blockquote>
<p><em>目前建议先使用拥有所有权的类型（如 <code>String</code> 而不是 <code>&amp;str</code>），直到学习到生命周期章节。</em>
<em>优先使用借用（&amp;）以避免不必要的移动</em></p>
</blockquote>
<hr>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>特性</strong></th><th><strong>具名结构体</strong></th><th><strong>元组结构体</strong></th><th><strong>单元结构体</strong></th></tr>
</thead>
<tbody>
<tr><td><strong>访问方式</strong></td><td><code>s.field_name</code></td><td><code>s.0</code>, <code>s.1</code></td><td>不可访问</td></tr>
<tr><td><strong>语义</strong></td><td>明确的数据对象</td><td>强类型化的元组</td><td>标签或特征实现</td></tr>
<tr><td><strong>典型案例</strong></td><td>用户信息、配置项</td><td>坐标 (x, y)、颜色 (r, g, b)</td><td>状态标记、Trait 对象</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="枚举"><a class="header" href="#枚举">枚举</a></h1>
<p>如果说结构体（Struct）是将多个相关数据“打包”在一起，那么<strong>枚举Enums</strong>则是让一个变量在“多种可能”中选择其一。</p>
<p>在 Rust 中，枚举不仅是其他语言中常见的整数常量列表，它还是功能极其强大的 <strong>代数数据类型（Algebraic Data Types）</strong> 。</p>
<hr>
<h2 id="一-基础枚举简单的分类"><a class="header" href="#一-基础枚举简单的分类">一、 基础枚举：简单的分类</a></h2>
<p>这是枚举最基础的用法，用于定义一组离散的选项。</p>
<pre class="playground"><code class="language-rust editable edition2024">enum IpAddrKind {
    V4,
    V6,
}

fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;

    // 枚举可以作为函数参数
    route(four);
    route(six);
}

fn route(ip_kind: IpAddrKind) {}</code></pre>
<p><strong>关键点：</strong></p>
<ul>
<li>枚举变体（如 V4、V6）是枚举类型的成员。</li>
<li>枚举可以作为参数传递给函数，也可以在函数中返回。</li>
<li>你可以在 <code>match</code> 表达式中匹配枚举的每个变体，处理不同的情况。</li>
</ul>
<hr>
<h2 id="二-枚举的真威力携带数据"><a class="header" href="#二-枚举的真威力携带数据">二、 枚举的真威力：携带数据</a></h2>
<p>在 Rust 中，每个枚举变体（Variant）都可以关联不同类型、不同数量的数据。这让你可以用一个类型表达多种结构完全不同的信息。</p>
<pre class="playground"><code class="language-rust editable edition2024">enum Message {
    Quit,                       // 无数据
    Move { x: i32, y: i32 },    // 匿名结构体
    Write(String),              // 单个 String
    ChangeColor(i32, i32, i32), // 元组
}

impl Message {
    fn call(&amp;self) {
        // 你也可以为枚举定义方法！
    }
}

fn main() {
    let m = Message::Write(String::from("hello"));
    m.call();
}</code></pre>
<p>为什么这比结构体好用？</p>
<p>如果你用结构体来实现上面的功能，你可能需要定义 4 个不同的结构体(Rust 是一种强静态类型语言，函数在编译时必须明确知道它接收的参数是什么类型，以及该类型占用的空间大小)。而使用枚举，它们都属于 Message 类型，方便在函数间统一传递。</p>
<hr>
<h2 id="三-核心中的核心option-枚举"><a class="header" href="#三-核心中的核心option-枚举">三、 核心中的核心：<code>Option</code> 枚举</a></h2>
<p>Rust  <strong>没有空值（Null）</strong> 。为了表达“一个值可能不存在”，Rust 使用了标准库中定义的 <code>Option&lt;T&gt;</code> 枚举：</p>
<pre class="playground"><code class="language-rust editable edition2024">enum Option&lt;T&gt; {
    None,
    Some(T),
}</code></pre>
<ul>
<li><strong><code>Some(T)</code></strong> ：代表有值，值为 <code>T</code> 类型。</li>
<li><strong><code>None</code></strong> ：代表没有值。</li>
</ul>
<p>意义何在？</p>
<p>在有 Null 的语言中，你随时可能忘记检查空指针而导致崩溃。在 Rust 中，如果你有一个 Option <code>&lt;i32&gt;</code>，你必须处理 None 的情况，否则代码编译不通过。这从根本上杜绝了空指针异常。</p>
<hr>
<h2 id="四-模式匹配枚举的完美搭档"><a class="header" href="#四-模式匹配枚举的完美搭档">四、 模式匹配：枚举的完美搭档</a></h2>
<p>要获取枚举内部的数据，最常用的工具就是 <code>match</code> 表达式。</p>
<h3 id="1-match穷尽式检查"><a class="header" href="#1-match穷尽式检查">1. <code>match</code>：穷尽式检查</a></h3>
<p><code>match</code> 强制你处理枚举的每一个变体。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!("来自 {:?} 州的 25 美分", state);
            25
        },
    }
}
fn main() {
    let coin = Coin::Quarter(UsState::Alaska);
    let cents = value_in_cents(coin);
    println!("{} 美分", cents);
}</code></pre>
<h3 id="2-if-let更简洁的匹配"><a class="header" href="#2-if-let更简洁的匹配">2. <code>if let</code>：更简洁的匹配</a></h3>
<p>如果你只关心其中的一种情况，<code>if let</code> 是比 <code>match</code> 更优雅的选择。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let some_u8_value = Some(3u8);

    // 仅在值为 Some 时处理
    if let Some(value) = some_u8_value {
        println!("找到了{}！", value);
    }else{
        println!("没有找到值！");
    }
}</code></pre>
<hr>
<h2 id="五-枚举的内存布局进阶"><a class="header" href="#五-枚举的内存布局进阶">五、 枚举的内存布局（进阶）</a></h2>
<p>枚举在内存中是如何存储的？</p>
<p>Rust 会为枚举分配足够的空间来容纳最大的那个变体，此外还需要一个小的<strong>标签Tag</strong>来记录当前存的是哪一个变体。</p>
<p>对于一个枚举 $E$，其占用内存大小大致为：</p>
<p>$$
Size(E) = Size(Tag) + \max(Size(Variant_1), Size(Variant_2), \dots)
$$</p>
<blockquote>
<p>小技巧：</p>
<p>对于 Option&lt;&amp;T&gt;，因为引用（指针）永远不会为 0，Rust 会非常聪明地用 0 来表示 None。这意味着 Option&lt;&amp;T&gt; 和 &amp;T 占用的空间是一样大的！</p>
</blockquote>
<hr>
<h2 id="总结结构体-vs-枚举"><a class="header" href="#总结结构体-vs-枚举">总结：结构体 vs 枚举</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>特性</strong></th><th><strong>结构体 (Struct)</strong></th><th><strong>枚举 (Enum)</strong></th></tr>
</thead>
<tbody>
<tr><td><strong>逻辑关系</strong></td><td><strong>“和”（And）</strong>：包含 A 且包含 B</td><td><strong>“或”（Or）</strong>：要么是 A 要么是 B</td></tr>
<tr><td><strong>数据访问</strong></td><td>通过 <code>.</code> 直接访问字段</td><td>必须通过 <code>match</code> 或 <code>if let</code> 解构</td></tr>
<tr><td><strong>主要用途</strong></td><td>定义具体的数据实体</td><td>定义状态机、分类、错误处理</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="切片"><a class="header" href="#切片">切片</a></h1>
<p>Rust 中的 slice（切片）是一种引用集合中连续元素的视图，而不拥有这些元素。它类似于数组或向量的子视图，使用 <code>&amp;[T]</code> 表示不可变切片，<code>&amp;mut [T]</code> 表示可变切片。Slice 是借用的一部分，遵守借用规则，确保内存安全。Slice 常用于字符串、数组和向量，帮助避免不必要的拷贝，提高效率。</p>
<h2 id="1-slice-简介"><a class="header" href="#1-slice-简介">1. Slice 简介</a></h2>
<ul>
<li><strong>什么是 slice？</strong> ：Slice 是对数据序列的引用视图，指向连续内存块。不拥有数据，只借用。长度在运行时确定。</li>
<li><strong>语法</strong> ：<code>&amp;[T]</code>（不可变）、<code>&amp;mut [T]</code>（可变）。T 是元素类型。</li>
<li><strong>优势</strong> ：零拷贝访问子集；函数参数通用（如接受 <code>&amp;[i32]</code> 而非 Vec 或 <code>[i32; N]</code>）。</li>
<li><strong>与数组/向量的关系</strong> ：数组是固定大小，向量是动态。Slice 可以从两者创建。</li>
<li><strong>字符串 slice</strong> ：<code>&amp;str</code> 是 <code>&amp;[u8]</code> 的特殊形式，处理 UTF-8。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let s = String::from("hello world");
    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
    println!("{}", hello);  // 输出: hello
    println!("{}", world);  // 输出: world
}</code></pre>
<ul>
<li><strong>解释</strong> ：<code>[start..end]</code> 是半开区间（包括 start，不包括 end）。<code>&amp;arr[..]</code> 是全切片。Slice 借用 arr，借用规则适用。</li>
</ul>
<p>对于字符串而言，切片就是对 String 类型中某一部分的引用，它看起来像这样：</p>
<img src="images/切片.jpg" alt="切片" class="center-img" width="50%" />
<h3 id="胖指针fat-pointer"><a class="header" href="#胖指针fat-pointer">胖指针(Fat Pointer)</a></h3>
<ul>
<li>数据结构：对比普通引用（1个字长指针）与切片引用（2个字长）。</li>
<li>组成部分：
<ul>
<li>Pointer：指向数据的起始位置。</li>
<li>Length：切片包含的元素个数。</li>
</ul>
</li>
<li>内存视图：在栈上存储元数据，在堆/静态区查看数据。</li>
</ul>
<h2 id="2-创建-slice"><a class="header" href="#2-创建-slice">2. 创建 Slice</a></h2>
<p>Slice 通过借用和范围运算符创建。</p>
<ul>
<li><strong>范围语法</strong> ：
<ul>
<li><code>[start..end]</code>：从 start 到 end-1。</li>
<li><code>[..end]</code>：从 0 到 end-1。</li>
<li><code>[start..]</code>：从 start 到结束。</li>
<li><code>[..]</code> ：整个集合。</li>
</ul>
</li>
<li><strong>从向量/数组</strong> ：直接 &amp;vec[start..end]。</li>
<li><strong>边界检查</strong> ：运行时检查，如果越界 panic!（安全）。</li>
</ul>
<h3 id="示例各种创建方式"><a class="header" href="#示例各种创建方式">示例：各种创建方式</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let vec = vec![10, 20, 30, 40, 50];
  
    let full = &amp;vec[..];      // 全切片: [10, 20, 30, 40, 50]
    let first_three = &amp;vec[0..3];  // [10, 20, 30]
    let last_two = &amp;vec[3..];     // [40, 50]
  
    println!("{:?}", first_three);
}</code></pre>
<ul>
<li><strong>解释</strong> ：Vec 和数组都支持。Slice 的 len() 返回元素数，get(i) 返回 Option&lt;&amp;T&gt;（安全访问）。</li>
</ul>
<h3 id="可变-slice"><a class="header" href="#可变-slice">可变 slice</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut vec = vec![1, 2, 3];
    let slice = &amp;mut vec[1..3];  // 可变借用
  
    slice[0] = 20;  // 修改 vec[1]
    println!("{:?}", vec);  // 输出: [1, 20, 3]
}</code></pre>
<ul>
<li><strong>解释</strong> ：可变 slice 允许修改元素，但遵守独占借用规则。</li>
</ul>
<h2 id="3-字符串-slice-str"><a class="header" href="#3-字符串-slice-str">3. 字符串 Slice (&amp;str)</a></h2>
<p>字符串 slice 是常见的，处理 String 或 str。</p>
<h3 id="示例字符串-slice"><a class="header" href="#示例字符串-slice">示例：字符串 slice</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">fn first_word(s: &amp;str) -&gt; &amp;str {  // 既能接受 String 的切片，也能接受字符串字面量
    let bytes = s.as_bytes();
    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }
    &amp;s[..]
}

fn main() {
    let s = String::from("hello world");
    let word = first_word(&amp;s);  // &amp;String 隐式转为 &amp;str
    
    println!("{}", word);  // 输出: hello
    
    // s.clear();  // 错误！word 借用期间不能修改 s
}</code></pre>
<ul>
<li><strong>解释</strong> ：<code>&amp;str</code> 是 UTF-8 安全的。as_bytes() 转为 <code>&amp;[u8]</code>。切片索引必须在字符边界（否则 panic!）。用 chars() 或 bytes() 迭代以避免。</li>
</ul>
<h2 id="4-多维-slice"><a class="header" href="#4-多维-slice">4. 多维 Slice</a></h2>
<p>Slice 可以是多维的，如 <code>&amp;[[T]]</code>。</p>
<p>示例：矩阵 slice</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let matrix = vec![vec![1, 2], vec![3, 4]];
    let row = &amp;matrix[0][..];  // &amp;[i32]: [1, 2]
    
    println!("{:?}", row);
}</code></pre>
<ul>
<li>解释：嵌套借用。复杂时考虑扁平化或专用 crate。</li>
</ul>
<blockquote>
<p>注意事项：
索引越界：如果你请求的范围超出了集合边界（如 <code>&amp;s[0..100]</code>），Rust 会在运行时 panic。
UTF-8 字符：对于字符串切片，索引必须落在字符边界上。如果在多字节字符（如中文）中间切片，程序会崩溃。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="常用集合"><a class="header" href="#常用集合">常用集合</a></h1>
<p>在 Rust 标准库 <code>std::collections</code> 模块下，集合被分为四大通用类型 <strong>线性序列</strong> 、<strong>Key-Value 映射表</strong> 、<strong>集合类型</strong>和 <strong>优先队列</strong> 。这些集合存储在堆内存中，并通过指针（如引用、智能指针）进行管理。</p>
<hr>
<h2 id="一-线性序列-linear-sequences"><a class="header" href="#一-线性序列-linear-sequences">一、 线性序列 (Linear Sequences)</a></h2>
<p>这类集合按顺序存储数据，适合处理列表、队列等逻辑。</p>
<ul>
<li><strong>向量 (Vec)</strong> ：最常用的动态数组。支持快速随机访问，在末尾插入/删除效率最高。</li>
<li><strong>双端队列 (VecDeque)</strong> ：基于循环缓冲区实现。在序列的<strong>头部和尾部</strong>插入或删除数据都非常高效。</li>
<li><strong>链表 (LinkedList)</strong> ：双向链表。虽然支持快速合并和拆分，但由于内存不连续，现代硬件上性能通常不如 <code>Vec</code>。</li>
</ul>
<h3 id="代码示例vec-与-vecdeque"><a class="header" href="#代码示例vec-与-vecdeque">代码示例：Vec 与 VecDeque</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">use std::collections::VecDeque;

fn main() {
    // 1. Vec: 动态数组
    let mut v = vec![1, 2, 3];
    v.push(4); 
    println!("Vec 第三个元素: {}", v[2]); // 随机访问

    // 2. VecDeque: 双端操作
    let mut dq = VecDeque::new();
    dq.push_back(10); // 尾部插入
    dq.push_front(20); // 头部插入
    println!("Deque 头部: {:?}", dq.front()); // 输出 Some(20)
}</code></pre>
<hr>
<h2 id="二-key-value-映射表-key-value-maps"><a class="header" href="#二-key-value-映射表-key-value-maps">二、 Key-Value 映射表 (Key-Value Maps)</a></h2>
<p>映射表用于存储“键-值”对，通过键来快速查找对应的值。</p>
<ul>
<li><strong>无序哈希表 (HashMap)</strong> ：通过哈希函数存储。查找速度极快（平均 <strong>$O(1)$</strong>），但由于哈希冲突和重新分配，内部顺序是无序的。</li>
<li><strong>有序哈希表 (BTreeMap)</strong> ：基于 B 树实现。键（Key）必须实现 <code>Ord</code> 特征，数据会按键的大小<strong>自动排序</strong>存储。</li>
</ul>
<h3 id="代码示例hashmap-与-btreemap"><a class="header" href="#代码示例hashmap-与-btreemap">代码示例：HashMap 与 BTreeMap</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">use std::collections::{HashMap, BTreeMap};

fn main() {
    // 1. HashMap: 无序
    let mut scores = HashMap::new();
    scores.insert("Alice", 90);
    scores.insert("Bob", 85);

    // 2. BTreeMap: 自动排序
    let mut sorted_map = BTreeMap::new();
    sorted_map.insert(3, "c");
    sorted_map.insert(1, "a");
    sorted_map.insert(2, "b");

    // 遍历 BTreeMap 时，顺序始终是 1, 2, 3
    for (key, value) in &amp;sorted_map {
        println!("{}: {}", key, value);
    }
}</code></pre>
<hr>
<h2 id="三-集合类型-set-types"><a class="header" href="#三-集合类型-set-types">三、 集合类型 (Set Types)</a></h2>
<p>集合类型实际上是不带“值”的映射表，主要用于保证元素的 <strong>唯一性</strong> 。</p>
<ul>
<li><strong>无序集合 (HashSet)</strong> ：基于 <code>HashMap</code> 实现。用于快速去重或检查某个元素是否存在。</li>
<li><strong>有序集合 (BTreeSet)</strong> ：基于 <code>BTreeMap</code> 实现。元素会根据自身顺序进行 <strong>排序</strong> 。</li>
</ul>
<h3 id="代码示例hashset-的去重功能"><a class="header" href="#代码示例hashset-的去重功能">代码示例：HashSet 的去重功能</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">use std::collections::HashSet;

fn main() {
    let mut books = HashSet::new();
    books.insert("Rust Programming");
    books.insert("Rust Programming"); // 重复插入会被忽略

    if !books.contains("C++") {
        println!("我们没有找到关于 C++ 的书。");
    }
}</code></pre>
<hr>
<h2 id="四-优先队列-priority-queues"><a class="header" href="#四-优先队列-priority-queues">四、 优先队列 (Priority Queues)</a></h2>
<p>当需要始终优先处理“最大”或“最小”的元素时，使用此类集合。</p>
<ul>
<li><strong>二叉堆 (BinaryHeap)</strong> ：默认是 <strong>最大堆</strong> 。无论插入顺序如何，每次弹出的总是集合中最大的元素。</li>
</ul>
<h3 id="代码示例binaryheap"><a class="header" href="#代码示例binaryheap">代码示例：BinaryHeap</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">use std::collections::BinaryHeap;

fn main() {
    let mut heap = BinaryHeap::new();

    // 乱序插入
    heap.push(1);
    heap.push(5);
    heap.push(2);

    // 总是弹出当前最大的值
    println!("弹出最大值: {:?}", heap.pop()); // 输出 Some(5)
    println!("再次弹出: {:?}", heap.pop());   // 输出 Some(2)
}</code></pre>
<hr>
<h2 id="总结如何选择集合"><a class="header" href="#总结如何选择集合">总结：如何选择集合？</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>需求场景</strong></th><th><strong>推荐集合类型</strong></th></tr>
</thead>
<tbody>
<tr><td><strong>存储简单的列表、作为默认选择</strong></td><td><code>Vec</code></td></tr>
<tr><td><strong>需要频繁从头部插入数据</strong></td><td><code>VecDeque</code></td></tr>
<tr><td><strong>根据 ID 或名称快速查找数据</strong></td><td><code>HashMap</code></td></tr>
<tr><td><strong>需要查找数据且要求结果按顺序排列</strong></td><td><code>BTreeMap</code></td></tr>
<tr><td><strong>只需要去重，不关心关联值</strong></td><td><code>HashSet</code></td></tr>
<tr><td><strong>始终要处理“优先级最高”的任务</strong></td><td><code>BinaryHeap</code></td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="泛型"><a class="header" href="#泛型">泛型</a></h1>
<p>泛型是 Rust 实现 零开销抽象（Zero-cost Abstractions） 的核心，它允许你编写不依赖于具体类型的通用代码。</p>
<ul>
<li><strong>什么是泛型？</strong>：使用类型参数（如 ）定义代码，允许在不同类型上重用。T 是占位符，在使用时替换为具体类型。</li>
<li><strong>优势</strong>：代码复用、类型安全、性能高（编译时展开）。</li>
<li><strong>语法</strong>：在函数、struct 等后用 &lt;参数&gt;，如 fn foo(arg: T)。</li>
<li><strong>与 trait 的关系</strong>：泛型常结合 trait bound（如 T: Clone）限制类型。</li>
</ul>
<h2 id="1-泛型基础generics-basics"><a class="header" href="#1-泛型基础generics-basics">1. <strong>泛型基础(Generics Basics)</strong></a></h2>
<h3 id="泛型类型参数"><a class="header" href="#泛型类型参数">泛型类型参数</a></h3>
<p>Rust 中的泛型允许我们在编写函数或结构体时不指定具体类型，从而让代码更具通用性。例如：</p>
<pre class="playground"><code class="language-rust editable edition2024">fn swap&lt;T&gt;(x: T, y: T) -&gt; (T, T) {
    (y, x)
}

fn main() {
    let (a, b) = swap(1, 2);
    println!("Swapped values: {}, {}", a, b);

    let (x, y) = swap("Hello", "World");
    println!("Swapped strings: {}, {}", x, y);
}</code></pre>
<p>swap 函数接受两个相同类型的参数 x 和 y，并返回它们的交换值。T 在调用时会被具体类型替换，确保返回的元组类型与输入类型一致。</p>
<h3 id="泛型约束"><a class="header" href="#泛型约束">泛型约束</a></h3>
<p>有时我们希望泛型类型参数满足特定的条件，例如只允许实现了某个特征（<code>trait</code>）的类型。可以使用 <code>T: Trait</code> 来为泛型添加约束。</p>
<ul>
<li><strong>语法</strong>：fn foo&lt;T: Trait1 + Trait2&gt;(arg: T)</li>
<li><strong>常见 bound</strong>：Copy、Clone、Debug、PartialEq、PartialOrd 等。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn print_debug&lt;T: std::fmt::Debug&gt;(val: T) {
    println!("{:?}", val);
}
fn main() {
    print_debug(42);          // 传递整数，符合 Debug 特征
    // print_debug("Hello");  // 编译错误，因为字符串没有 Debug 特征
}</code></pre>
<h3 id="泛型方法"><a class="header" href="#泛型方法">泛型方法</a></h3>
<p>方法与函数类似，但它们是定义在<strong>结构体、枚举、trait 等类型</strong>上的。在定义方法时，你可以在<strong>impl块中</strong>使用泛型类型参数。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    // 泛型方法，接受一个泛型参数并返回其和
    fn new(x: T, y: T) -&gt; Self {
        Pair { x, y }
    }
    fn get_x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
    fn get_y(&amp;self) -&gt; &amp;T {
        &amp;self.y
    }
}
fn main() {
    let pair = Pair::new(1, 2);  // T = i32
    println!("Pair: {} and {}", pair.get_x(), pair.get_y());
    let pair_str = Pair::new("Hello", "World");  // T = &amp;str
    println!("Pair: {} and {}", pair_str.get_x(), pair_str.get_y());
}</code></pre>
<p>在这个例子中，Pair 是一个泛型结构体，new 方法和 get_x、get_y 方法都是泛型方法。它们可以处理任何类型 T，确保类型一致性。</p>
<h3 id="对于复杂-bound用-where-子句提高可读性"><a class="header" href="#对于复杂-bound用-where-子句提高可读性">对于复杂 bound，用 where 子句提高可读性</a></h3>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; U
where
    T: Debug + Clone,
    U: Clone + PartialEq,
{
    if t.clone() == u {  // 错误！T 和 U 类型不同，不能比较
        // ...
    }
    u
}
<span class="boring">}</span></code></pre>
<p>解释：where 在签名后。适用于函数、impl、trait。</p>
<h2 id="2-结构体和枚举中的泛型"><a class="header" href="#2-结构体和枚举中的泛型">2. <strong>结构体和枚举中的泛型</strong></a></h2>
<h3 id="泛型结构体"><a class="header" href="#泛型结构体">泛型结构体</a></h3>
<p>结构体也可以使用泛型类型，字段类型由泛型决定,以便存储不同类型的数据。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct Pair&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let int_float = Pair { x: 42, y: 3.14 };
    let string_int = Pair { x: "Hello", y: 100 };
    println!("int_float: ({}, {})", int_float.x, int_float.y);
    println!("string_int: ({}, {})", string_int.x, string_int.y);
}</code></pre>
<p>在这个示例中，<code>Pair</code> 结构体有两个泛型参数 <code>T</code> 和 <code>U</code>，它们可以代表不同的类型。</p>
<h3 id="泛型枚举"><a class="header" href="#泛型枚举">泛型枚举</a></h3>
<p>枚举类型也可以使用泛型，允许它们处理不同类型的数据。例如，标准库中的 <code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code> 就是泛型枚举。</p>
<pre class="playground"><code class="language-rust editable edition2024">// 定义一个泛型枚举
enum MyOption&lt;T&gt; {
    Some(T),
    None,
}

fn main() {
    let some_int = MyOption::Some(42);
    let none: MyOption&lt;i32&gt; = MyOption::None;
  
    match some_int {
        MyOption::Some(value) =&gt; println!("Some: {}", value),
        MyOption::None =&gt; println!("None"),
    }
}</code></pre>
<h2 id="3-特征trait与泛型"><a class="header" href="#3-特征trait与泛型">3. <strong>特征（Trait）与泛型</strong></a></h2>
<h3 id="泛型与特征结合"><a class="header" href="#泛型与特征结合">泛型与特征结合</a></h3>
<p>特征（trait，具体看下一节介绍)）可以与泛型结合使用，限制泛型类型必须实现特定的特征。例如：</p>
<pre class="playground"><code class="language-rust editable edition2024">// 定义一个 trait
trait Printable {
    fn print(&amp;self);
}
// 为 `i32` 实现 `Printable` 特征
impl Printable for i32 {
    fn print(&amp;self) {
        println!("Printing i32: {}", self);
    }
}
// 泛型函数，只有实现了 `Printable` 特征的类型才能使用
fn print_value&lt;T: Printable&gt;(val: T) {
    val.print();
}
fn main() {
    let x = 42;
    print_value(x);  // 可以，因为 i32 实现了 Printable 特征
}</code></pre>
<h2 id="4-生命周期lifetime与泛型"><a class="header" href="#4-生命周期lifetime与泛型">4. <strong>生命周期（Lifetime）与泛型</strong></a></h2>
<p>有时，生命周期和泛型约束会结合使用，以确保泛型类型满足特定条件。在某些情况下，泛型类型可能是引用类型，因此需要生命周期标注。（其他复杂情况见生命周期小节）</p>
<pre class="playground"><code class="language-rust editable edition2024">// 一个泛型函数，它的类型 T 必须是引用类型，并且带有生命周期标注
fn first_word&lt;'a, T&gt;(s: &amp;'a T) -&gt; &amp;'a str
where
    T: AsRef&lt;str&gt;,  // 泛型类型 T 必须实现 AsRef&lt;str&gt; 特征
{
    let str_ref: &amp;str = s.as_ref(); // 将 T 转换为 &amp;str
    let bytes = str_ref.as_bytes();
    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;str_ref[0..i];
        }
    }
    &amp;str_ref[..]
}
fn main() {
    let string = String::from("Hello world");
    let word = first_word(&amp;string);
    println!("The first word is: {}", word);
}</code></pre>
<h2 id="5-关联类型associated-types"><a class="header" href="#5-关联类型associated-types">5. <strong>关联类型（Associated Types）</strong></a></h2>
<p>Rust 允许在 trait 中定义“关联类型”，这些类型在 trait 的实现中被具体化。这样可以简化泛型的使用。</p>
<pre class="playground"><code class="language-rust editable edition2024">// 定义一个 trait，带有关联类型
trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
// 为 Vec 实现 Iterator 特征
impl&lt;T&gt; Iterator for Vec&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.pop()
    }
}
fn main() {
    let mut vec = vec![1, 2, 3];
    let mut iter = vec.into_iter();
    println!("{:?}", iter.next());  // 输出 Some(3)
}</code></pre>
<h2 id="6-泛型与性能考虑"><a class="header" href="#6-泛型与性能考虑">6. <strong>泛型与性能考虑</strong></a></h2>
<p>在 <code>Rust</code>中，泛型是非常强大的工具，它允许编写类型安全且灵活的代码。然而，许多人担心使用泛型是否会影响程序的性能。幸运的是，<code>Rust</code>的设计非常注重性能，尤其是与泛型相关的部分。让我们深入探讨泛型如何影响性能，以及如何最大程度地避免性能损失。</p>
<p><code>Rust</code>使用一种称为 单态化<code>（Monomorphization）</code> 的机制来处理泛型。单态化是指编译器在编译时将泛型类型的代码转换为具体类型的实现。这意味着泛型代码在编译期间被实例化为不同类型的具体代码，因此没有运行时的性能开销。</p>
<p>这种机制确保了泛型代码的 零成本抽象<code>（Zero-cost Abstraction）</code>。也就是说，使用泛型不会导致额外的运行时开销。</p>
<p>尽管泛型本身不会带来运行时的性能损失，但它们可能会影响 <strong>内存布局</strong> 和 <strong>大小</strong>，特别是当涉及到<strong>动态分发</strong>时。泛型类型的大小由编译器在单态化时决定。如果泛型类型的大小变化较大，可能会导致更多的内存分配或数据拷贝。编译器会为每种具体类型生成不同的内存布局，从而避免了不必要的浪费。</p>
<h2 id="7-与标准库的泛型交互"><a class="header" href="#7-与标准库的泛型交互">7. <strong>与标准库的泛型交互</strong></a></h2>
<p>标准库中的许多类型，如 <code>Vec&lt;T&gt;</code>、<code>Option&lt;T&gt;</code>、<code>Result&lt;T, E&gt;</code> 都使用泛型。你可以通过这些泛型类型来简化代码。</p>
<p>Rust 标准库几乎处处是泛型。</p>
<ul>
<li><strong>常见容器</strong>：<code>Vec&lt;T&gt;</code>（动态数组）、<code>HashMap&lt;K, V&gt;</code>（键值对）。</li>
<li><strong>错误处理</strong>：<code>Result&lt;T, E&gt;</code>是编写健壮代码的核心。</li>
<li><strong>迭代器与闭包</strong>：它们利用泛型接口实现高度灵活的数据处理流。</li>
</ul>
<h2 id="8-高级泛型使用"><a class="header" href="#8-高级泛型使用">8. <strong>高级泛型使用</strong></a></h2>
<h3 id="高阶类型hkt的模拟"><a class="header" href="#高阶类型hkt的模拟">高阶类型（HKT）的模拟</a></h3>
<ul>
<li><strong><code>HKT (Higher Kinded Types)</code></strong> 模拟：通过 <code>type alias</code> 和 <code>Trait</code> 模拟对“容器的抽象”。</li>
<li><strong>并发/异步</strong>：使用 <code>Send</code>和 <code>Sync</code>特征约束确保泛型数据在多线程间安全传递。</li>
<li><strong>宏与泛型</strong>：结合使用以生成复杂的泛型 <code>boilerplate</code> 代码。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="trait"><a class="header" href="#trait">Trait</a></h1>
<p>Rust 中的 <code>trait</code> 是一种非常强大的特性，它允许我们定义共享行为的契约，并使得不同类型可以实现这些行为。学习 Rust 中的 <code>trait</code> 是深入理解 Rust 编程语言的重要一步，尤其是在类型系统和抽象的层次上。
需掌握：</p>
<ol>
<li><strong>特征基础</strong>：定义、实现、默认实现。</li>
<li><strong>特征约束 (静态分发)</strong>：Trait Bound、<code>where</code> 子句、<code>impl Trait</code>。</li>
<li><strong>多态与分发 (核心)</strong>
<ul>
<li><strong>静态分发</strong>：泛型展开，性能最高。</li>
<li><strong>动态分发</strong>：<code>dyn Trait</code> 对象，虚函数表 。</li>
</ul>
</li>
<li><strong>进阶特性</strong>：关联类型、Supertraits（继承）、完全限定语法。</li>
<li><strong>高级规则</strong>：孤儿规则、覆盖实现。</li>
<li><strong>特殊特征</strong>
<ul>
<li><strong>标准库三巨头</strong>：<code>Debug</code>, <code>Display</code>, <code>Default</code></li>
<li><strong>所有权控制</strong>：<code>Copy</code>, <code>Clone</code>, <code>Drop</code></li>
<li><strong>标记特征</strong>：<code>Sized</code>, <code>Send</code>, <code>Sync</code></li>
<li><strong>运算符重载</strong>：<code>std::ops</code></li>
</ul>
</li>
</ol>
<p>下面是学习 <code>trait</code> 时应该掌握的主要知识点，以及相关的代码示例：</p>
<h2 id="1-定义-trait"><a class="header" href="#1-定义-trait">1. <strong>定义 Trait</strong></a></h2>
<ul>
<li><code>trait</code> 是行为的集合。你可以在 <code>trait</code> 中定义方法和关联类型，其他类型可以实现这些方法。</li>
<li><code>trait</code> 定义了一组方法的签名，但不包含具体的实现。</li>
</ul>
<h3 id="示例定义-trait"><a class="header" href="#示例定义-trait">示例：定义 Trait</a></h3>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 定义一个 trait
trait Speak {
    fn speak(&amp;self);
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="2-为类型实现-trait"><a class="header" href="#2-为类型实现-trait">2. <strong>为类型实现 Trait</strong></a></h2>
<ul>
<li>类型（例如结构体、枚举等）可以通过 <code>impl</code> 块来实现某个 <code>trait</code>。</li>
<li>一个类型可以实现多个 <code>trait</code>，每个 <code>trait</code> 都可以定义一组方法。</li>
</ul>
<h3 id="示例为结构体实现-trait"><a class="header" href="#示例为结构体实现-trait">示例：为结构体实现 Trait</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">trait Speak {
    fn speak(&amp;self);
}
struct Dog;
impl Speak for Dog {
    fn speak(&amp;self) {
        println!("Woof!");
    }
}
struct Cat;
impl Speak for Cat {
    fn speak(&amp;self) {
        println!("Meow!");
    }
}
fn main() {
    let dog = Dog;
    let cat = Cat;
    dog.speak();  // 输出 "Woof!"
    cat.speak();  // 输出 "Meow!"
}</code></pre>
<hr>
<h2 id="3-trait-默认实现"><a class="header" href="#3-trait-默认实现">3. <strong>Trait 默认实现</strong></a></h2>
<ul>
<li><code>trait</code> 可以为某些方法提供默认实现，这样某些类型可以选择不实现这些方法，而是使用默认实现。</li>
</ul>
<h3 id="示例trait-的默认实现"><a class="header" href="#示例trait-的默认实现">示例：Trait 的默认实现</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">trait Speak {
    fn speak(&amp;self) {
        println!("I can speak in a default way!");
    }
}
struct Dog;
impl Speak for Dog {
    // 不需要显式实现 speak 方法，使用默认实现
}
fn main() {
    let dog = Dog;
    dog.speak();  // 输出 "I can speak in a default way!"
}</code></pre>
<hr>
<h2 id="4-trait-和生命周期"><a class="header" href="#4-trait-和生命周期">4. <strong>Trait 和生命周期</strong></a></h2>
<ul>
<li>你可以在 <code>trait</code> 中使用生命周期标注，确保实现该 <code>trait</code> 的类型处理引用时，能够正确管理引用的生命周期。</li>
</ul>
<h3 id="示例trait-和生命周期"><a class="header" href="#示例trait-和生命周期">示例：Trait 和生命周期</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">trait PrintWithLifetime&lt;'a&gt; {
    fn print(&amp;self, s: &amp;'a str);
}

struct Printer;

impl&lt;'a&gt; PrintWithLifetime&lt;'a&gt; for Printer {
    fn print(&amp;self, s: &amp;'a str) {
        println!("{}", s);
    }
}

fn main() {
    let printer = Printer;
    let message = "Hello, world!";
    printer.print(message);
}</code></pre>
<hr>
<h2 id="5-关联类型"><a class="header" href="#5-关联类型">5. <strong>关联类型</strong></a></h2>
<ul>
<li><code>trait</code> 可以定义  <strong>关联类型</strong> ，这种类型在实现 <code>trait</code> 时需要指定。这种方式使得 <code>trait</code> 更加灵活和强大。</li>
</ul>
<h3 id="示例使用关联类型"><a class="header" href="#示例使用关联类型">示例：使用关联类型</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">trait Iterator {
    type Item;  // 关联类型
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
struct Counter {
    count: i32,
}
impl Iterator for Counter {
    type Item = i32;  // 为关联类型指定具体类型
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.count += 1;
        Some(self.count)
    }
}

fn main() {
    let mut counter = Counter { count: 0 };
    println!("{}", counter.next().unwrap()); // 输出 1
    println!("{}", counter.next().unwrap()); // 输出 2
}</code></pre>
<hr>
<h2 id="6-trait-的继承"><a class="header" href="#6-trait-的继承">6. <strong>Trait 的继承</strong></a></h2>
<ul>
<li>一个 <code>trait</code> 可以继承其他 <code>trait</code>。这使得一个 <code>trait</code> 可以继承另一个 <code>trait</code> 的方法和行为。</li>
</ul>
<h3 id="示例trait-的继承"><a class="header" href="#示例trait-的继承">示例：Trait 的继承</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">trait Animal {
    fn sound(&amp;self);
}

trait DogBehavior: Animal {  // DogBehavior 继承 Animal
    fn fetch(&amp;self);
}

struct Dog;

impl Animal for Dog {
    fn sound(&amp;self) {
        println!("Woof!");
    }
}
//实现 DogBehavior 时，必须也实现 Animal。
impl DogBehavior for Dog {
    fn fetch(&amp;self) {
        println!("Fetching the ball!");
    }
}

fn main() {
    let dog = Dog;
    dog.sound();  // 输出 "Woof!"
    dog.fetch();  // 输出 "Fetching the ball!"
}</code></pre>
<hr>
<h2 id="7-trait-bound-和泛型"><a class="header" href="#7-trait-bound-和泛型">7. <strong>Trait Bound 和泛型</strong></a></h2>
<ul>
<li><code>trait</code> 可以和泛型一起使用，通过 <strong>trait bound</strong> 来约束泛型类型，确保传入的类型实现了特定的 <code>trait</code>。</li>
</ul>
<h3 id="示例trait-bound-和泛型"><a class="header" href="#示例trait-bound-和泛型">示例：Trait Bound 和泛型</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">trait Speak {
    fn speak(&amp;self);
}
struct Dog;
impl Speak for Dog {
    fn speak(&amp;self) {
        println!("Woof!");
    }
}
fn make_speak&lt;T: Speak&gt;(animal: T) {
    animal.speak();
}
fn main() {
    let dog = Dog;
    make_speak(dog);  // 输出 "Woof!"
}</code></pre>
<p>在这个例子中，<code>make_speak</code> 函数的参数 <code>T</code> 被约束为实现了 <code>Speak</code> trait 的类型，因此它可以接受任何实现了 <code>Speak</code> 的类型作为参数。</p>
<hr>
<h2 id="8-trait-作为参数和返回类型"><a class="header" href="#8-trait-作为参数和返回类型">8. <strong>Trait 作为参数和返回类型</strong></a></h2>
<p>在 Rust 的 <code>trait</code> 系统中，将 <code>trait</code> 用作参数或返回类型是实现抽象和多态的核心手段。根据性能需求和灵活性要求，Rust 提供了**静态分发（Static Dispatch）<strong>和</strong>动态分发（Dynamic Dispatch）**两种机制。</p>
<h3 id="trait-作为参数"><a class="header" href="#trait-作为参数">Trait 作为参数</a></h3>
<p>当你希望函数能够接受多种不同类型，只要这些类型实现了特定行为时，可以使用 <code>trait</code> 作为参数。</p>
<h4 id="a-impl-trait-语法语法糖"><a class="header" href="#a-impl-trait-语法语法糖">A. <code>impl Trait</code> 语法（语法糖）</a></h4>
<p>这是最简单、最常用的方式，适用于参数较少的情况。</p>
<pre class="playground"><code class="language-rust editable edition2024">trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
// 接受任何实现了 Summary 的类型
fn notify(item: &amp;impl Summary) {
    println!("新闻更新: {}", item.summarize());
}
fn main() {
    struct Tweet { content: String }
    impl Summary for Tweet {
        fn summarize(&amp;self) -&gt; String { self.content.clone() }
    }
    let tweet = Tweet { content: String::from("Rust 是一种系统级语言") };
    notify(&amp;tweet);  // 输出 "新闻更新: Rust 是一种系统级语言"
}</code></pre>
<h4 id="b-trait-bound特征约束"><a class="header" href="#b-trait-bound特征约束">B. Trait Bound（特征约束）</a></h4>
<p><code>impl Trait</code> 实际上是泛型特征约束的简写。在复杂的场景下（例如要求两个参数必须是<strong>同一种</strong>泛型类型），必须使用特征约束。</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 强制要求 item1 和 item2 必须是相同的具体类型 T
fn notify_double&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {
    // ...
}

<span class="boring">}</span></code></pre>
<h3 id="trait-作为返回类型"><a class="header" href="#trait-作为返回类型">Trait 作为返回类型</a></h3>
<p>这是 Rust 抽象能力的高级体现，但根据返回的是“一种类型”还是“多种类型”，处理方式截然不同。</p>
<h4 id="a-静态分发impl-trait"><a class="header" href="#a-静态分发impl-trait">A. 静态分发：<code>impl Trait</code></a></h4>
<p>当你确定函数在<strong>编译时</strong>只会返回一种具体的类型，但不想写出冗长的类型名（如闭包或复杂的迭代器）时，使用 <code>impl Trait</code>。</p>
<ul>
<li><strong>优点</strong>：性能极高（零开销抽象），编译器会进行单态化处理。</li>
<li><strong>局限</strong>：函数的所有分支<strong>必须返回同一种</strong>具体类型。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">struct NewsArticle { content: String }
impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String { self.content.clone() }
}
fn returns_summarizable() -&gt; impl Summary {
    NewsArticle { content: String::from("内容...") }
}
fn main() {
    let article = returns_summarizable();
    println!("{}", article.summarize());  // 输出 "内容..."
}
</code></pre>
<h4 id="b-动态分发trait-对象-dyn-trait"><a class="header" href="#b-动态分发trait-对象-dyn-trait">B. 动态分发：Trait 对象 (<code>dyn Trait</code>)</a></h4>
<p>如果你需要在运行时根据条件返回<strong>不同类型</strong>的对象，必须使用特征对象。特征对象必须通过指针来使用，如引用 <code>&amp;dyn Trait</code> 或智能指针 <code>Box&lt;dyn Trait&gt;</code>。</p>
<ul>
<li><strong>优点</strong>：支持真正的多态，允许在同一个函数中根据逻辑返回不同的结构体。</li>
<li><strong>原理</strong>：使用虚函数表（vtable）在运行时查找方法。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">struct Dog;
struct Cat;

impl Summary for Dog { fn summarize(&amp;self) -&gt; String { "汪".into() } }
impl Summary for Cat { fn summarize(&amp;self) -&gt; String { "喵".into() } }

// 使用智能指针 Box 包装特征对象
fn get_animal(is_dog: bool) -&gt; Box&lt;dyn Summary&gt; {
    if is_dog {
        Box::new(Dog)
    } else {
        Box::new(Cat)
    }
}
fn main() {
    let animal = get_animal(true);  // 返回 Dog 的特征对象
    println!("{}", animal.summarize());  // 输出 "汪"
    
    let animal = get_animal(false);  // 返回 Cat 的特征对象
    println!("{}", animal.summarize());  // 输出 "喵"
}</code></pre>
<pre class="playground"><code class="language-rust editable edition2024">trait Speak {
    fn speak(&amp;self);
}
struct Dog;
impl Speak for Dog {
    fn speak(&amp;self) {
        println!("Woof!");
    }
}
fn make_speak(animal: &amp;dyn Speak) {
    animal.speak();
}
fn main() {
    let dog = Dog;
    make_speak(&amp;dog);  // 使用 trait 对象动态分发
}
</code></pre>
<h3 id="静态分发-vs-动态分发"><a class="header" href="#静态分发-vs-动态分发">静态分发 vs 动态分发</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>特性</th><th><code>impl Trait</code> (静态分发)</th><th><code>dyn Trait</code> (动态分发)</th></tr>
</thead>
<tbody>
<tr><td><strong>分发时机</strong></td><td>编译期 (Compile-time)</td><td>运行期 (Runtime)</td></tr>
<tr><td><strong>性能开销</strong></td><td><strong>无</strong>（类似于内联函数）</td><td><strong>有</strong>（虚表查询、无法内联优化）</td></tr>
<tr><td><strong>二进制大小</strong></td><td>较大（代码膨胀/单态化）</td><td>较小</td></tr>
<tr><td><strong>类型限制</strong></td><td>必须返回单一具体类型</td><td>可以返回多种实现了特征的类型</td></tr>
<tr><td><strong>指针需求</strong></td><td>不需要</td><td><strong>必须</strong>通过 <code>Box</code>, <code>&amp;</code> 等指针使用</td></tr>
</tbody>
</table>
</div>
<h3 id="特征对象安全-object-safety"><a class="header" href="#特征对象安全-object-safety">特征对象安全 (Object Safety)</a></h3>
<p>并非所有的 <code>trait</code> 都能转换成 <code>dyn Trait</code> 对象。为了保证对象安全，<code>trait</code> 必须满足以下条件：</p>
<ol>
<li>方法的返回类型不能是 <code>Self</code>。</li>
<li>方法不能有泛型类型参数。</li>
<li>方法的第一参数必须是 <code>&amp;self</code>, <code>&amp;mut self</code>, <code>Box&lt;Self&gt;</code> 等（不能没有 <code>self</code>）。</li>
</ol>
<blockquote>
<p><strong>笔记要点</strong>：如果一个 <code>trait</code> 不满足“对象安全”，你只能将其用作泛型约束（静态分发），而不能创建特征对象。</p>
</blockquote>
<hr>
<h2 id="9-where-子句与-trait-约束"><a class="header" href="#9-where-子句与-trait-约束">9. <strong><code>where</code> 子句与 trait 约束</strong></a></h2>
<ul>
<li><code>where</code> 子句可以用来指定泛型参数的 trait 约束，这使得代码更加清晰和可读。</li>
</ul>
<h3 id="示例where-子句和-trait-约束"><a class="header" href="#示例where-子句和-trait-约束">示例：<code>where</code> 子句和 trait 约束</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">fn print_value&lt;T&gt;(value: T) 
where
    T: std::fmt::Debug,  // 使用 where 子句进行 trait 约束
{
    println!("{:?}", value);
}

fn main() {
    print_value(42);  // 可以，因为 i32 实现了 Debug trait
    // print_value("Hello");  // 编译错误，字符串没有实现 Debug trait
}</code></pre>
<hr>
<h2 id="10-copy-和-clone-特征"><a class="header" href="#10-copy-和-clone-特征">10. <strong><code>Copy</code> 和 <code>Clone</code> 特征</strong></a></h2>
<ul>
<li><code>Copy</code> 和 <code>Clone</code> 是两个常用的 <code>trait</code>，用于控制类型的值是否可以被复制（而不是移动）。它们在处理需要复制的类型时非常重要。</li>
</ul>
<h3 id="示例使用-copy-和-clone"><a class="header" href="#示例使用-copy-和-clone">示例：使用 <code>Copy</code> 和 <code>Clone</code></a></h3>
<pre class="playground"><code class="language-rust editable edition2024">trait CustomClone {
    fn custom_clone(&amp;self) -&gt; Self;
}
#[derive(Clone)]
struct Point {
    x: i32,
    y: i32,
}
impl CustomClone for Point {
    fn custom_clone(&amp;self) -&gt; Self {
        Point { x: self.x, y: self.y }
    }
}
fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = p1.custom_clone();
    println!("p2: ({}, {})", p2.x, p2.y);
}</code></pre>
<hr>
<h2 id="11-孤儿规则-orphan-rules"><a class="header" href="#11-孤儿规则-orphan-rules">11. <strong>孤儿规则 (Orphan Rules)</strong></a></h2>
<p>这是 Rust 保证代码安全性的核心：<strong>你不能为外部类型实现外部特征</strong>。</p>
<ul>
<li><strong>规则</strong>：只有当特征或类型其中之一是在当前 crate（包）中定义的，你才能为该类型实现该特征。</li>
<li><strong>目的</strong>：防止不同库之间因为冲突的实现而导致代码行为混乱。</li>
</ul>
<p><strong>示例</strong>：你不能在自己的项目中为 <code>Vec&lt;T&gt;</code>（标准库）实现 <code>Display</code> 特征（标准库），因为两者都不是你定义的。</p>
<hr>
<h2 id="12-完全限定语法-fully-qualified-syntax"><a class="header" href="#12-完全限定语法-fully-qualified-syntax">12. <strong>完全限定语法 (Fully Qualified Syntax)</strong></a></h2>
<p>当一个类型实现的两个不同 <code>trait</code> 拥有<strong>同名方法</strong>时，Rust 需要你明确指定调用哪一个。</p>
<h3 id="示例解决同名冲突"><a class="header" href="#示例解决同名冲突">示例：解决同名冲突</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">trait Pilot {
    fn fly(&amp;self);
}
trait Wizard {
    fn fly(&amp;self);
}
struct Human;
impl Pilot for Human {
    fn fly(&amp;self) { println!("准备起飞。"); }
}
impl Wizard for Human {
    fn fly(&amp;self) { println!("飞向云端。"); }
}
fn main() {
    let person = Human;
    // person.fly(); // ❌ 报错：歧义
    
    Pilot::fly(&amp;person);  // 调用 Pilot 的实现
    Wizard::fly(&amp;person); // 调用 Wizard 的实现
}
</code></pre>
<hr>
<h2 id="13-blanket-implementations-覆盖实现"><a class="header" href="#13-blanket-implementations-覆盖实现">13. <strong>Blanket Implementations (覆盖实现)</strong></a></h2>
<p>Rust 允许你为<strong>所有</strong>满足特定特征约束的类型实现另一个特征。这在标准库中非常常见（例如 <code>ToString</code>）。</p>
<h3 id="示例覆盖实现"><a class="header" href="#示例覆盖实现">示例：覆盖实现</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">trait MyTrait {
    fn info(&amp;self);
}
// 为所有实现了 Display 的类型实现 MyTrait
impl&lt;T: std::fmt::Display&gt; MyTrait for T {
    fn info(&amp;self) {
        println!("信息: {}", self);
    }
}
fn main() {
    42.info(); // i32 实现了 Display，所以它自动拥有了 MyTrait
}</code></pre>
<hr>
<h2 id="14-标记特征-marker-traits-sized-send-sync"><a class="header" href="#14-标记特征-marker-traits-sized-send-sync">14. <strong>标记特征 (Marker Traits): <code>Sized</code>, <code>Send</code>, <code>Sync</code></strong></a></h2>
<p>标记特征没有方法定义，它们告诉编译器该类型具备某种<strong>属性</strong>。</p>
<ul>
<li><strong><code>Sized</code></strong>：编译时已知大小的类型（默认情况下泛型 <code>T</code> 都是 <code>T: Sized</code>）。</li>
<li><strong><code>?Sized</code></strong>：专门用于解除 <code>Sized</code> 限制，常用于处理 <code>dyn Trait</code> 或 <code>[T]</code>。</li>
<li><strong><code>Send</code> / <code>Sync</code></strong>：用于并发安全，标记类型是否可以安全地跨线程传递或共享。</li>
</ul>
<hr>
<h2 id="15-运算符重载-operator-overloading"><a class="header" href="#15-运算符重载-operator-overloading">15. <strong>运算符重载 (Operator Overloading)</strong></a></h2>
<p>在 Rust 中，所有的运算符（如 <code>+</code>, <code>-</code>, <code>*</code>）本质上都是通过特定的 <code>trait</code> 实现的（位于 <code>std::ops</code> 模块）。</p>
<h3 id="示例重载-"><a class="header" href="#示例重载-">示例：重载 <code>+</code></a></h3>
<pre class="playground"><code class="language-rust editable edition2024">use std::ops::Add;
#[derive(Debug, PartialEq)]
struct Point { x: i32, y: i32 }
impl Add for Point {
    type Output = Point;
    fn add(self, other: Point) -&gt; Point {
        Point { x: self.x + other.x, y: self.y + other.y }
    }
}
fn main() {
    let p1 = Point { x: 1, y: 0 } + Point { x: 2, y: 3 };
    println!("{:?}", p1); // Point { x: 3, y: 3 }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="智能指针"><a class="header" href="#智能指针">智能指针</a></h1>
<p>Rust 里“智能指针”这块，按 <strong>“它解决什么问题 + 它的所有权/借用规则 + 运行时成本”</strong> 来系统学。下面把需要掌握的知识点尽量全列出来，并按学习路径组织。</p>
<hr>
<h2 id="定义"><a class="header" href="#定义">定义</a></h2>
<h3 id="什么算智能指针"><a class="header" href="#什么算智能指针">什么算“智能指针”</a></h3>
<ul>
<li><strong>智能指针 vs 普通引用 <code>&amp;T</code> / <code>&amp;mut T</code></strong> ：智能指针是“像指针一样用（<code>Deref</code>）+ 还带管理/策略”的类型</li>
<li>三个核心 trait：
<ul>
<li><code>Deref</code> / <code>DerefMut</code>：让 <code>*p</code>、方法调用、解引用自动转换成立</li>
<li><code>Drop</code>：离开作用域时自动清理资源（RAII）</li>
<li><code>CoerceUnsized</code>/<code>DispatchFromDyn</code>（了解即可）：<code>Box&lt;T&gt;</code> 到 <code>Box&lt;dyn Trait&gt;</code> 的不定大小转换等</li>
</ul>
</li>
</ul>
<p>要理解为什么 <code>Box</code> 或 <code>String</code> 是智能指针，必须先看它们背后的两个关键特征。智能指针本质上是一个<strong>实现了 <code>Deref</code> 和 <code>Drop</code> 的结构体</strong>。</p>
<h3 id="a-deref-特征让结构体像指针"><a class="header" href="#a-deref-特征让结构体像指针">A. <code>Deref</code> 特征：让结构体“像”指针</a></h3>
<p>普通的结构体不能被解引用（即不能用 <code>*</code>）。实现了 <code>Deref</code> 之后，智能指针就可以像普通引用一样工作。</p>
<ul>
<li><strong>解引用强制转换 (Deref Coercion)</strong>：这是 <code>Rust</code> 的魔法。如果一个函数需要 <code>&amp;str</code> 参数，你传给它 <code>&amp;String</code>（<code>String</code>实现了 <code>Deref</code>），<code>Rust</code>会自动帮你转换。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">use std::ops::Deref;
struct MyBox&lt;T&gt;(T);
impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
// 实现 Deref 告诉编译器：当我对 MyBox 使用 * 时，返回内部的那个值
impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;
    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.0
    }
}
fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y); // 这里的 *y 实际上执行的是 *(y.deref())
    println!("{}", *y); 
}
</code></pre>
<h3 id="b-drop-特征自动清理的析构函数"><a class="header" href="#b-drop-特征自动清理的析构函数">B. <code>Drop</code> 特征：自动清理的“析构函数”</a></h3>
<p><code>Drop</code> 特征允许你自定义：当一个变量离开作用域时该发生什么。对于智能指针，这通常意味着<strong>释放它所拥有的堆内存</strong>。</p>
<ul>
<li><strong>自动调用</strong>：你不需要手动调用 <code>drop</code>，Rust 会自动在变量生命周期结束时插入清理代码。</li>
<li><strong>防止泄漏</strong>：有了 <code>Drop</code>，Rust 确保了即便程序在中间出错退出，堆内存也会被正确回收。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">struct CustomSmartPointer {
    data: String,
}
impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!("正在清理数据: {}！", self.data);
    }
}
fn main() {
    let c = CustomSmartPointer { data: String::from("我的数据") };
    let d = CustomSmartPointer { data: String::from("其他数据") };
    println!("智能指针已创建。");
    // 函数结束时，d 先被清理，c 后被清理（先进后出）
}
</code></pre>
<p>智能指针通过 <code>Deref</code> 让我们能方便地访问数据，通过 <code>Drop</code> 让我们不再担心内存回收。</p>
<hr>
<h2 id="1-boxt堆分配--递归类型"><a class="header" href="#1-boxt堆分配--递归类型">1. <code>Box&lt;T&gt;</code>：堆分配 &amp; 递归类型</a></h2>
<p>你要会的点：</p>
<ul>
<li><strong>什么时候需要 <code>Box</code></strong>
<ul>
<li>把值放到<strong>堆</strong>上（存储实际的数据 <code>T</code>）,而在<strong>栈</strong>(存储指针地址,64 位系统通常是8字节）上仅保留一个指向堆数据的指针</li>
<li>处理  <strong>递归类型</strong> （编译期需要知道每个类型占用多少内存空间–如：链表）</li>
<li>作为 <strong>trait object</strong> 的持有者：当你需要一个“实现了某个特征的类型”而不是具体类型时，通常使用<code>Box&lt;dyn Trait&gt;</code></li>
<li>转移大数据所有权,如果你有一个非常大的结构体或数组，将其作为参数传递给函数时，如果不使用指针，<code>Rust</code>默认会进行栈拷贝，这非常消耗性能。</li>
</ul>
</li>
<li><strong>所有权语义</strong> ：<code>Box&lt;T&gt;</code> 独占所有权，同一时间只能有一个 <code>Box</code> 指向该堆数据,移动后原变量不可用</li>
<li><strong>解引用与方法调用</strong> ：<code>Box&lt;T&gt;</code> 自动 <code>Deref</code> 到 <code>T</code></li>
</ul>
<h3 id="示例递归类型链表"><a class="header" href="#示例递归类型链表">示例：递归类型（链表）</a></h3>
<pre><code class="language-rust ignore">enum List {
    Cons(i32, List), // 错误：List 包含 List，会导致无限大小
    Nil,
}</code></pre>
<p>编译器会报错，因为 Cons 变体包含另一个 <code>List</code>，这会形成无限递归，编译器无法计算 <code>List</code> 结构的大小。解决方案： 使用<code>Box</code> 智能指针，将递归类型“在堆上间接存储”，<code>List</code>本身就有固定大小了。</p>
<pre class="playground"><code class="language-rust editable edition2024">// 递归 enum：如果没有 Box，编译器无法在编译期知道 List 的大小。
// Box&lt;List&gt; 让递归“在堆上间接存储”，List 本身就有固定大小了。
#[derive(Debug)]
enum List {
    Cons(i32, Box&lt;List&gt;),//Cons 占用：一个 i32 的空间 + 一个指针的空间
    Nil,
}
impl List {
    fn new() -&gt; Self {
        List::Nil
    }
    fn prepend(self, v: i32) -&gt; Self {
        List::Cons(v, Box::new(self))
    }
    fn len(&amp;self) -&gt; usize {
        match self {
            List::Cons(_, next) =&gt; 1 + next.len(),
            List::Nil =&gt; 0,
        }
    }
}
fn main() {
    let list = List::new().prepend(3).prepend(2).prepend(1);
    println!("{list:?}");
    println!("len = {}", list.len());
}</code></pre>
<h3 id="示例返回-trait-object动态分发"><a class="header" href="#示例返回-trait-object动态分发">示例：返回 trait object（动态分发）</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">trait Draw {
    fn draw(&amp;self);
}
struct Circle {r: f32}
impl Draw for Circle {
    fn draw(&amp;self) {
        println!("Circle radius = {}", self.r);
    }
}
struct Square {side: f32}
impl Draw for Square {
    fn draw(&amp;self) {
        println!("Square side = {}", self.side);
    }
}
// 返回 Box&lt;dyn Draw&gt;：调用者只知道“它能 draw”，不关心具体类型。
// 这会使用动态分发（vtable）。
fn make_shape(kind: &amp;str) -&gt; Box&lt;dyn Draw&gt; {
    match kind {
        "circle" =&gt; Box::new(Circle { r: 2.0 }),
        _ =&gt; Box::new(Square { side: 3.0 }),
    }
}
fn main() {
    let s1 = make_shape("circle");
    let s2 = make_shape("square");
    s1.draw();
    s2.draw();
}</code></pre>
<hr>
<h2 id="2-rct单线程引用计数共享所有权"><a class="header" href="#2-rct单线程引用计数共享所有权">2. <code>Rc&lt;T&gt;</code>：单线程引用计数共享所有权</a></h2>
<p>在 <code>Rust</code> 的所有权规则中，通常一个值只能有一个所有者。但在某些复杂的应用场景中（例如图结构、社交网络或共享配置），一个数据可能需要被多个不同的部分共同拥有。这时，<code>Box&lt;T&gt;</code> 的独占所有权就不够用了，我们需要 <code>Rc&lt;T&gt;</code>(<code>Reference Counted</code>引用计数)。</p>
<p>你要会的点：</p>
<ul>
<li><strong>为什么需要 Rc</strong> ：它允许一个数据拥有多个所有者。它在堆上存储数据，并额外记录一个“引用计数器”，用来统计目前有多少个指针指向这份数据</li>
<li><strong>只读共享</strong>：<code>Rc&lt;T&gt;</code> 默认只允许你不可变地借用数据。如果你想通过其中一个 <code>Rc</code> 修改数据，编译器会拒绝（除非配合后面要讲的 <code>RefCell</code>）。</li>
<li><strong>共享而非拷贝</strong>：当你“克隆”一个 <code>Rc&lt;T&gt;</code> 时，Rust 并不会在堆上重新分配内存并拷贝数据，而是
<ul>
<li><strong>增加引用计数</strong>：计数器加 1。</li>
<li><strong>拷贝指针地址</strong>：在栈上创建一个新的指针指向同一个堆位置。</li>
<li>只有当<strong>计数器归零</strong>时: 堆上的数据才会被真正清理。</li>
</ul>
</li>
<li><strong>强引用/弱引用</strong>
<ul>
<li><code>Rc::clone(&amp;rc)</code> 增加强引用计数（不是深拷贝）</li>
<li><code>Weak&lt;T&gt;</code> 用于打破环，避免内存泄漏</li>
</ul>
</li>
<li><strong>循环引用问题</strong> ：<code>Rc</code> 形成环会  <strong>泄漏</strong> （计数永远不为 0）</li>
<li>常用 API：<code>Rc::new</code>、<code>Rc::clone</code>、<code>Rc::strong_count</code>、<code>Rc::weak_count</code>、<code>Rc::downgrade</code></li>
</ul>
<h3 id="示例共享一段数据"><a class="header" href="#示例共享一段数据">示例：共享一段数据</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">use std::rc::Rc;
fn main() {
    // 1. 在堆上创建共享数据，初始计数为 1
    let config = Rc::new(String::from("核心配置程序"));
    
    println!("--- 初始状态 ---");
    println!("内容: {}", config);
    println!("引用计数: {}", Rc::strong_count(&amp;config));

    // 2. 共享数据：创建两个新的指针指向同一块堆内存
    // Rc::clone 仅增加计数，不会拷贝字符串文本
    let user_a = Rc::clone(&amp;config);
    let user_b = Rc::clone(&amp;config);

    println!("\n--- 共享后 ---");
    println!("User A 看到的内容: {}", user_a);
    println!("User B 看到的内容: {}", user_b);
    println!("当前总引用计数: {}", Rc::strong_count(&amp;config));

    // 3. 释放其中一个引用
    drop(user_a);
    println!("\n--- 释放 User A 后 ---");
    println!("剩余引用计数: {}", Rc::strong_count(&amp;config));
}</code></pre>
<ul>
<li><strong>内存物理表现</strong>：<code>config</code>、<code>user_a</code> 和 <code>user_b</code> 是三个存储在栈上的指针，它们内部存储的内存地* 址完全相同，都指向堆上的同一个 <code>String</code>。</li>
<li><strong>内容访问</strong>：由于实现了 <code>Deref</code> 特征，你可以像使用普通 <code>String</code> 一样直接打印 <code>user_a</code> 或 <code>user_b</code>。</li>
<li><strong>计数变化</strong>：每次调用 <code>Rc::clone</code>，计数器加 1；每次指针离开作用域（或被 <code>drop</code>），计数器减 1。</li>
</ul>
<h3 id="强引用-strong-reference-与-弱引用-weak-reference"><a class="header" href="#强引用-strong-reference-与-弱引用-weak-reference">强引用 (Strong Reference) 与 弱引用 (Weak Reference)</a></h3>
<p>这是管理 <code>Rc</code> 生命周期的两种手段：</p>
<ul>
<li>
<p><strong>强引用 (<code>Rc&lt;T&gt;</code>)</strong>：</p>
<ul>
<li><strong>行为</strong>：使用 <code>Rc::clone(&amp;rc)</code> 会增加<strong>强引用计数</strong>。</li>
<li><strong>本质</strong>：它不是深拷贝（Deep Copy），只是在栈上多了一个指向堆内存的指针，并在堆上把计数器加 1。</li>
<li><strong>作用</strong>：只要强引用计数大于 0，堆上的数据就<strong>绝对不会</strong>被销毁。</li>
</ul>
</li>
<li>
<p><strong>弱引用 (<code>Weak&lt;T&gt;</code>)</strong>：</p>
<ul>
<li><strong>行为</strong>：通过 <code>Rc::downgrade(&amp;rc)</code> 创建。</li>
<li><strong>本质</strong>：它会增加<strong>弱引用计数</strong>，但<strong>不影响</strong>强引用计数。</li>
<li><strong>作用</strong>：它不拥有数据的所有权。即便还有 100 个 <code>Weak</code> 指针指向数据，只要强引用计数归零，数据依然会被清理。</li>
<li><strong>使用</strong>：因为数据可能已被销毁，使用前必须通过 <code>weak_ptr.upgrade()</code> 将其“升级”回 <code>Option&lt;Rc&lt;T&gt;&gt;</code> 进行检查。</li>
</ul>
</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">use std::rc::Rc;
fn main() {
    // 1. 创建一个强引用 Rc
    let strong_ptr = Rc::new(String::from("Rust 智能指针"));
    
    // 2. 从强引用创建一个弱引用
    // downgrade 不会增加 strong_count
    let weak_ptr = Rc::downgrade(&amp;strong_ptr);
    let weak_ptr2 = Rc::downgrade(&amp;strong_ptr);

    println!("--- 初始状态 ---");
    println!("强引用计数: {}", Rc::strong_count(&amp;strong_ptr)); // 1
    println!("弱引用计数: {}", Rc::weak_count(&amp;strong_ptr));   // 2

    // 3. 尝试使用弱引用访问数据
    // 必须通过 upgrade() 升级为 Option&lt;Rc&lt;T&gt;&gt;
    match weak_ptr.upgrade() {
        Some(rc) =&gt; println!("弱引用升级成功，得到数据: {}", rc),
        None =&gt; println!("弱引用升级失败，数据已销毁"),
    }

    // 销毁一个弱引用
    drop(weak_ptr2);
    println!("销毁一个弱引用后强引用计数: {}", Rc::strong_count(&amp;strong_ptr)); // 1
    println!("销毁一个弱引用后弱引用计数: {}", Rc::weak_count(&amp;strong_ptr));   // 1

    println!("\n--- 销毁强引用后 ---");
    // 4. 手动销毁强引用（模拟离开作用域）
    drop(strong_ptr);

    // 5. 再次尝试使用弱引用访问数据
    // 此时强引用计数为 0，数据已被回收
    match weak_ptr.upgrade() {
        Some(rc) =&gt; println!("弱引用升级成功: {}", rc),
        None =&gt; println!("弱引用升级失败，数据已销毁"),
    }
}</code></pre>
<h3 id="rc-环"><a class="header" href="#rc-环">Rc 环</a></h3>
<p><strong>循环引用问题</strong>:这是<code>Rc</code> 最危险的陷阱。</p>
<ul>
<li><strong>成因</strong>：如果两个 <code>Rc</code> 指针互相指向对方（例如：节点 A 拥有指向节点 B 的 Rc，而节点 B 也拥有指向节点 A 的 Rc），就会形成一个环。</li>
<li><strong>后果</strong>：由于环的存在，这两个对象的强引用计数永远至少为 1。当外部作用域结束时，它们无法被清理，导致<strong>内存泄漏</strong>（<code>Memory Leak</code>）。</li>
<li><strong>解决方案</strong>：将其中一条路径改为 <code>Weak&lt;T&gt;</code>。例如：父节点用 <code>Rc</code> 指向子节点（强引用），而子节点用 <code>Weak</code> 指向父节点（弱引用）。这样环就被打破了。</li>
</ul>
<p>由于 <code>Rc&lt;T&gt;</code> 默认是只读的，为了在创建节点后能修改指针指向对方，我们需要配合使用 <code>RefCell&lt;T&gt;</code>演示环形引用。</p>
<pre class="playground"><code class="language-rust editable edition2024">use std::rc::Rc;
use std::cell::RefCell;
// 定义一个简单的 Node，它可以指向另一个 Node
#[derive(Debug)]
struct Node {
    next: RefCell&lt;Option&lt;Rc&lt;Node&gt;&gt;&gt;,
}
impl Drop for Node {
    fn drop(&amp;mut self) {
        println!("Node 被销毁了！");
    }
}
fn main() {
    // 1. 创建两个节点 A 和 B
    let a = Rc::new(Node { next: RefCell::new(None) });
    let b = Rc::new(Node { next: RefCell::new(None) });

    println!("--- 建立环之前 ---");
    println!("A 的强引用计数: {}", Rc::strong_count(&amp;a)); // 1
    println!("B 的强引用计数: {}", Rc::strong_count(&amp;b)); // 1

    // 2. 建立环：A 指向 B，B 指向 A
    *a.next.borrow_mut() = Some(Rc::clone(&amp;b));
    *b.next.borrow_mut() = Some(Rc::clone(&amp;a));

    println!("--- 建立环之后 ---");
    println!("A 的强引用计数: {}", Rc::strong_count(&amp;a)); // 2
    println!("B 的强引用计数: {}", Rc::strong_count(&amp;b)); // 2

    // 3. 函数结束前，我们尝试让 a 和 b 离开作用域
    println!("--- main 函数即将结束 ---");
} 
// 正常情况下，这里应该打印两次 "Node 被销毁了！"，但实际上什么都不会打印。</code></pre>
<blockquote>
<p>笔记：为什么会泄漏？</p>
</blockquote>
<ul>
<li><strong>计数器逻辑</strong>：当 main 函数结束时，变量 a 和 b 被丢弃。
<ul>
<li><strong>a 被丢弃</strong>，其对应的堆内存计数从 2 降到 1。</li>
<li><strong>b 被丢弃</strong>，其对应的堆内存计数从 2 降到 1。</li>
</ul>
</li>
<li><strong>死循环</strong>：堆内存 A 还在等待堆内存 B 释放以便将其计数减为 0；而堆内存 B 也在等待堆内存 A 释放。</li>
<li><strong>结果</strong>：两个内存块的计数器永远卡在 1，drop 方法永远不会被触发，这块堆内存就泄漏了。</li>
</ul>
<h4 id="解决方案"><a class="header" href="#解决方案">解决方案</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">use std::cell::RefCell;
use std::rc::{Rc, Weak};

// 一个“父-子”节点结构：
// - 子节点用 Rc 拥有（多个地方可以共享孩子）
// - 父指针用 Weak 指向父（避免形成 Rc 环）
#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,  // Weak&lt;Node&gt;：这是指向父节点的指针, Weak 不增加强引用计数
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,    // children 拥有子节点
}
impl Drop for Node {
    fn drop(&amp;mut self) {
        println!("Node 被销毁了！");
    }
}
fn main() {
    let parent = Rc::new(Node {
        value: 1,
        parent: RefCell::new(Weak::new()),// 初始化时，父节点没有“父”，设为空弱引用
        children: RefCell::new(vec![]),// 初始化时，子节点列表为空向量
    });//将 Node 实例放入堆中，并返回一个智能指针，此时 parent 的强引用计数为 1，弱计数 = 0

    let child = Rc::new(Node {
        value: 2,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });//child 的强计数 = 1，弱计数 = 0

    // 建立父 -&gt; 子 的强引用关系
    parent.children.borrow_mut().push(Rc::clone(&amp;child));
    // 通过 borrow_mut() 获取 Vec 的可变借用，然后把 child 的一个克隆存进去。
    // 此时 child 的强引用计数变为 2（一个是变量 child，一个是 parent.children 里的克隆）

    // 建立子 -&gt; 父 的弱引用关系（关键：避免环）
    *child.parent.borrow_mut() = Rc::downgrade(&amp;parent);
    //通过 Rc::downgrade 将 parent 的强引用转为弱引用并存入 child.parent
    //parent 的强计数保持为 1。parent 的弱计数变为 1。

    println!("parent strong = {}, weak = {}",
        Rc::strong_count(&amp;parent),
        Rc::weak_count(&amp;parent)
    );
    println!("child strong = {}, weak = {}",
        Rc::strong_count(&amp;child),
        Rc::weak_count(&amp;child)
    );

    // Weak::upgrade：尝试把 Weak 变回 Rc（如果父节点已释放则返回 None）
    if let Some(p) = child.parent.borrow().upgrade() {
        println!("child's parent value = {}", p.value);
    } else {
        println!("parent already dropped");
    }
}
</code></pre>
<blockquote>
<p>核心设计：为什么这样设计结构？</p>
</blockquote>
<p>在 Rust 中，指针是表示内存地址的类型。为了实现父子双向链接，代码采用了“强弱结合”的策略：</p>
<ul>
<li><code>children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;</code>(向下强引用)：
<ul>
<li>父节点需要“拥有”它的子节点，所以使用 <code>Rc&lt;Node&gt;</code>。只要父节点存在，子节点就不会被销毁。</li>
</ul>
</li>
<li><code>parent: RefCell&lt;Weak&lt;Node&gt;&gt;</code> (向上弱引用)：
<ul>
<li>这是破环关键。子节点只需要“知道”父节点是谁，但不应该“拥有”父节点。</li>
<li>使用 <code>Weak&lt;Node&gt;</code> 不会增加父节点的强引用计数，因此不会阻止父节点被回收。</li>
</ul>
</li>
<li><code>RefCell</code>(内部可变性)：
<ul>
<li>因为节点创建时是孤立的，必须在创建后修改属性（建立连接），所以需要 RefCell 绕过编译期的不可变检查。</li>
</ul>
</li>
</ul>
<div class="table-wrapper">
<table>
<thead>
<tr><th>执行阶段</th><th>Parent 计数 (Strong/Weak)</th><th>Child 计数 (Strong/Weak)</th><th>逻辑说明</th></tr>
</thead>
<tbody>
<tr><td>创建后</td><td>1 / 0</td><td>1 / 0</td><td>变量 parent 和 child 各自拥有 1 个所有权</td></tr>
<tr><td>建立父-&gt;子连接</td><td>1 / 0</td><td>2 / 0</td><td>parent.children 存了一个 Rc::clone(&amp;child)，强计数加 1</td></tr>
<tr><td>建立子-&gt;父连接</td><td>1 / 1</td><td>2 / 0</td><td>child.parent 存了一个 downgrade(&amp;parent)，仅增加弱计数</td></tr>
</tbody>
</table>
</div>
<h3 id="常用-api-速查表"><a class="header" href="#常用-api-速查表">常用 API 速查表</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>API</th><th>功能描述</th></tr>
</thead>
<tbody>
<tr><td><code>Rc::new(val)</code></td><td>创建一个新的 Rc 实例，初始强计数为 1。</td></tr>
<tr><td><code>Rc::clone(&amp;rc)</code></td><td>增加强引用计数，返回新指针。</td></tr>
<tr><td><code>Rc::strong_count(&amp;rc)</code></td><td>查看当前的强引用数量。</td></tr>
<tr><td><code>Rc::weak_count(&amp;rc)</code></td><td>查看当前的弱引用数量。</td></tr>
<tr><td><code>Rc::downgrade(&amp;rc)</code></td><td>获取一个 <code>Weak&lt;T&gt;</code> 指针。</td></tr>
<tr><td><code>weak.upgrade()</code></td><td>尝试将弱引用转回强引用，返回 <code>Option&lt;Rc&lt;T&gt;&gt;</code>。</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="3-arct多线程引用计数共享所有权"><a class="header" href="#3-arct多线程引用计数共享所有权">3. <code>Arc&lt;T&gt;</code>：多线程引用计数共享所有权</a></h2>
<p>如果在多线程环境下使用 <code>Rc&lt;T&gt;</code>，编译器会直接报错，因为 <code>Rc&lt;T&gt;</code> 内部的引用计数是非原子的，无法在多个线程间安全地更新。为了解决这个问题，<code>Rust</code> 提供了 <code>Arc&lt;T&gt;</code>（<code>Atomic Reference Counted</code> 原子引用计数）,它允许在多个线程之间安全地共享同一个堆数据的所有权。和 <code>Rc&lt;T&gt;</code> 一样，<code>Arc&lt;T&gt;</code> 默认也是只读的。如果你需要多个线程同时修改数据，你还需要配合下一阶段我们要讲的锁机制（如 Mutex）。</p>
<p>在计算机中，普通的整数加减（如 <code>count += 1</code>）并不是一个不可分割的操作。如果两个线程同时尝试修改 <code>Rc</code> 的计数器，可能会导致计数错误，进而引发提前释放内存或内存泄漏。<code>Arc&lt;T&gt;</code> 使用了 原子操作来更新计数。这是一种硬件层面的特殊指令，能确保在多线程竞争时计数器依然准确。</p>
<p>你要会的点：</p>
<ul>
<li><code>Arc</code> = Atomic Rc（线程安全，计数操作是原子的）</li>
<li>成本：比 <code>Rc</code> 更贵（原子操作），单线程场景优先 <code>Rc</code>以获得最佳性能</li>
<li>常见组合：<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>、<code>Arc&lt;RwLock&lt;T&gt;&gt;</code></li>
<li>线程安全标志：
<ul>
<li><strong><code>Rc&lt;T&gt;</code></strong> 未实现 <code>Send</code> 和 <code>Sync</code> 特征，因此不能跨线程传递</li>
<li><strong><code>Arc&lt;T&gt;</code></strong> 实现了 <code>Send</code> 和 <code>Sync</code>（前提是内部的 <code>T</code> 也是线程安全的），可以在线程间自由穿梭</li>
</ul>
</li>
</ul>
<h3 id="示例多线程共享只读"><a class="header" href="#示例多线程共享只读">示例：多线程共享只读</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">use std::sync::Arc;
use std::thread;
fn main() {
    // 1. 创建一个 Arc 指针
    let data = Arc::new(String::from("多线程共享数据"));
    println!("Arc-data 初始计数: {}", Arc::strong_count(&amp;data));
    let mut handles = vec![];
    for i in 0..5 {
        // 2. 克隆 Arc 指针：这只是增加原子计数，不拷贝字符串本身
        let data_clone = Arc::clone(&amp;data);
        let handle = thread::spawn(move || {
            // 3. 在子线程中使用数据
            println!("线程 {} 看到的数据: {}", i, data_clone);
        });
        handles.push(handle);
    }
    // 等待所有线程结束
    for handle in handles {
        handle.join().unwrap();
    }
    println!("所有线程已完成，最后计数: {}", Arc::strong_count(&amp;data));
}</code></pre>
<hr>
<h2 id="4-线程安全内部可变性mutext--rwlockt"><a class="header" href="#4-线程安全内部可变性mutext--rwlockt">4. 线程安全内部可变性：<code>Mutex&lt;T&gt;</code> / <code>RwLock&lt;T&gt;</code></a></h2>
<p>在多线程环境下，单靠 <code>Arc&lt;T&gt;</code> 只能解决“谁拥有数据”的问题，但由于 <code>Arc&lt;T&gt;</code> 提供的引用是不可变的，我们无法修改数据。为了在多线程中修改数据，我们需要使用“<strong>锁</strong>”。</p>
<p>你要会的点：</p>
<ul>
<li><code>Mutex&lt;T&gt;</code>：互斥锁，提供独占可变访问（锁守卫 <code>MutexGuard</code>）</li>
<li><code>RwLock&lt;T&gt;</code>：读写锁，多读单写</li>
<li><strong>死锁、锁粒度、持锁时间</strong> （工程上很关键）</li>
<li>常见组合：<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>、<code>Arc&lt;RwLock&lt;T&gt;&gt;</code></li>
<li>运行时成本：加锁/解锁、竞争、可能阻塞</li>
</ul>
<h3 id="示例mutext-互斥锁"><a class="header" href="#示例mutext-互斥锁">示例：<code>Mutex&lt;T&gt;</code> (互斥锁)</a></h3>
<p><code>Mutex</code> 是 <code>Mutual Exclusion</code>（互斥）的缩写。它保证在任何时刻，只有一个线程可以访问数据。</p>
<p>工作机制：</p>
<ol>
<li>线程尝试通过 <code>.lock()</code> 获取锁。</li>
<li>如果锁已被占用，线程会阻塞（等待）。</li>
<li>获取成功后，返回一个 <code>MutexGuard</code>（智能指针）。</li>
<li><strong>自动释放</strong>：由于 <code>MutexGuard</code> 实现了 <code>Drop</code> 特征，当它离开作用域时，锁会自动释放，无需手动解锁。</li>
</ol>
<pre class="playground"><code class="language-rust editable edition2024">use std::sync::Mutex;
fn main() {
    let m = Mutex::new(5);
    {
        // lock() 返回一个 Result，因为如果另一个线程在持有锁时 panic，锁会变得“中毒”
        let mut num = m.lock().unwrap(); 
        *num = 6; // 通过解引用修改内部数据
    } // num 离开作用域，锁自动释放

    println!("m = {:?}", m);
}</code></pre>
<h3 id="示例rwlockt-读写锁"><a class="header" href="#示例rwlockt-读写锁">示例：<code>RwLock&lt;T&gt;</code> (读写锁)</a></h3>
<p>RwLock 代表 <code>Read-Write Lock</code>。它比 Mutex 更灵活，遵循“多读单写”规则：</p>
<ul>
<li><strong>多读</strong>：允许多个线程同时持有只<strong>读锁</strong> (<code>.read()</code>)。</li>
<li><strong>单写</strong>：同一时间只允许一个线程持有<strong>写锁</strong> (<code>.write()</code>)。此时<strong>不允许任何读锁</strong>。</li>
</ul>
<p><strong>适用场景</strong>：适用于“<strong>读多写少</strong>”的场景，性能通常优于 <code>Mutex</code>。</p>
<p><code>Mutex&lt;T&gt;</code> 的规则很简单：任何人要用，必须排队。
而 <code>RwLock&lt;T&gt;</code> 引入了“多读”逻辑，这虽然提高了并发效率，但也让逻辑变得复杂：你不能直接把一个读锁“升级”为写锁。你必须先释放读锁，然后再去竞争写锁</p>
<pre class="playground"><code class="language-rust editable edition2024">use std::sync::{Arc, RwLock};
use std::thread;
use std::time::Duration;
fn main() {
    // 1. 使用 Arc 包装 RwLock，实现多线程共享所有权
    let lock = Arc::new(RwLock::new(5));
    let mut handles = vec![];
    // --- 模拟多个读取者 ---
    for i in 0..3 {
        let lock_clone = Arc::clone(&amp;lock);
        let handle = thread::spawn(move || {
            // 获取读锁：允许多个线程同时进入此处
            let r = lock_clone.read().unwrap();
            println!("读者 {} 读取到的值: {}", i, *r);
            // 读锁在这里自动释放
        });
        handles.push(handle);
    }
    // --- 模拟一个写入者 ---
    {
        let lock_clone = Arc::clone(&amp;lock);
        let handle = thread::spawn(move || {
            println!("写入者正在尝试获取写锁...");
            // 获取写锁：此时所有读锁和其他写锁都会被阻塞
            let mut w = lock_clone.write().unwrap();
            *w += 10;
            println!("写入者已将值修改为: {}", *w);
            // 写锁在这里自动释放
        });
        handles.push(handle);
    }
    // 等待所有线程结束
    for handle in handles {
        handle.join().unwrap();
    }

    println!("最终结果: {}", *lock.read().unwrap());
}</code></pre>
<h4 id="关键细节解析"><a class="header" href="#关键细节解析">关键细节解析</a></h4>
<ul>
<li>
<p><strong><code>.read().unwrap()</code></strong>：</p>
<ul>
<li>返回一个 <code>ReadGuard</code>。只要这个 guard 存在，其他线程也可以调用 <code>.read()</code> 获取读锁。</li>
<li><strong>限制</strong>：一旦有人持有读锁，任何尝试调用 <code>.write()</code> 的线程都会进入睡眠等待状态。</li>
</ul>
</li>
<li>
<p><strong><code>.write().unwrap()</code></strong>：</p>
<ul>
<li>返回一个 <code>WriteGuard</code>。</li>
<li><strong>排他性</strong>：只有当没有任何人持有读锁且没有任何人持有写锁时，它才能成功获取。</li>
</ul>
</li>
<li>
<p><strong>死锁风险</strong>：</p>
<ul>
<li>如果在同一个线程中，你已经持有了读锁，又尝试去获取写锁，会导致<strong>死锁</strong>。</li>
<li>在写操作频繁的场景下，可能会出现“读者饥饿”。</li>
</ul>
</li>
</ul>
<h3 id="总结对比mutex-vs-rwlock"><a class="header" href="#总结对比mutex-vs-rwlock">总结对比：<code>Mutex</code> vs <code>RwLock</code></a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>特性</th><th><code>Mutex&lt;T&gt;</code></th><th><code>RwLock&lt;T&gt;</code></th></tr>
</thead>
<tbody>
<tr><td>访问规则</td><td>一次只能一个线程访问,</td><td>多个读者 OR 一个写者</td></tr>
<tr><td>内部可变性</td><td>是（通过锁获取可变引用）</td><td>是（通过写锁获取可变引用）</td></tr>
<tr><td>线程安全</td><td>是</td><td>是</td></tr>
<tr><td>性能</td><td>简单、开销固定</td><td>读操作多时性能更好，管理成本略高</td></tr>
</tbody>
</table>
</div>
<blockquote>
<p>💡 笔记要点：为什么它们也叫“内部可变性”？</p>
</blockquote>
<p>因为即使你只有一个指向 <code>Mutex&lt;T&gt;</code> 的不可变引用 <code>&amp;Mutex&lt;T&gt;</code>，你依然可以通过调用 <code>.lock()</code> 方法来修改其内部包裹的数据。这种“<strong>外表不可变，内部可变</strong>”的特性正是它们被称为内部可变性的原因。</p>
<h3 id="示例多线程共享可变arcmutext"><a class="header" href="#示例多线程共享可变arcmutext">示例：多线程共享可变（<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>）</a></h3>
<p><strong>核心分工:</strong></p>
<ul>
<li>Arc（<strong>所有权管理者</strong>）：解决“<strong>谁拥有数据</strong>”的问题。它让多个线程可以同时持有指向同一个堆内存的指针</li>
<li>Mutex（<strong>访问权限管理者</strong>）：解决“<strong>谁能修改数据</strong>”的问题。它确保即使多个线程都有指针，同一时间也只有一个线程能真正碰到里面的数据</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">use std::sync::{Arc, Mutex};
use std::thread;
fn main() {
    let counter = Arc::new(Mutex::new(0));//最外层是 Arc，给这把锁加上引用计数功能,中间层是 Mutex，给数据加上一把锁
    let mut handles = vec![];
    for _ in 0..4 {
        let c = Arc::clone(&amp;counter);//克隆的是指针地址和计数器，锁和数据始终只有一份
        handles.push(thread::spawn(move || {
            // lock() 返回一个 guard：guard 活着就持有锁
            let mut guard = c.lock().unwrap();
            *guard += 1;
            // 不需要手动写 unlock(), guard drop 时自动解锁（RAII）
        }));
    }
    for h in handles {
        h.join().unwrap();
    }
    println!("counter = {}", *counter.lock().unwrap()); // 4
}
</code></pre>
<h3 id="示例多线程共享可变读多写少arcrwlockt"><a class="header" href="#示例多线程共享可变读多写少arcrwlockt">示例：多线程共享可变（读多写少<code>Arc&lt;RwLock&lt;T&gt;&gt;</code>）</a></h3>
<p><strong>核心分工:</strong></p>
<ul>
<li>Arc：解决“<strong>谁拥有数据</strong>”的问题，确保堆内存地址在所有线程执行完毕前保持有效。</li>
<li>RwLock：解决“<strong>如何高效访问</strong>”的问题。它允许 100 个线程同时读取（并发），但只要有 1 个线程在写，其他人都必须等待（排他）。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">use std::sync::{Arc, RwLock};
use std::thread;
use std::time::Duration;
fn main() {
    // 1. 初始化数据，Arc 负责跨线程共享，RwLock 负责并发权限
    let data = Arc::new(RwLock::new(0));
    let mut handles = vec![];
    let start_time = std::time::Instant::now();
    // 2. 开启 5 个读者线程
    for i in 0..5 {
        let d = Arc::clone(&amp;data);
        handles.push(thread::spawn(move || {
            // 获取读锁：注意！多个线程可以同时成功获取读锁
            let _guard = d.read().unwrap();
            println!("读者 {} 正在读取...", i);
            // 模拟一个耗时的读取操作（1秒）
            thread::sleep(Duration::from_secs(1)); 
            println!("读者 {} 读取完毕", i);
        }));
    }
    // 3. 开启 1 个写者线程
    let d_writer = Arc::clone(&amp;data);
    handles.push(thread::spawn(move || {
        // 模拟等待一段时间再写，确保读者们已经先拿到了锁
        thread::sleep(Duration::from_millis(500));
        println!("写者：尝试获取写锁（会被阻塞，直到所有读者读完）...");
        // 获取写锁：必须等所有读锁释放
        let mut w = d_writer.write().unwrap();
        *w += 1;
        println!("写者：修改完毕！");
    }));
    for h in handles {
        h.join().unwrap();
    }
    println!("--- 总耗时: {:?} ---", start_time.elapsed());
}</code></pre>
<h4 id="代码逻辑深度拆解"><a class="header" href="#代码逻辑深度拆解">代码逻辑深度拆解</a></h4>
<ul>
<li>读锁并发 (<code>.read().unwrap()</code>)
<ul>
<li>当 <code>reader1</code> 调用 <code>read()</code> 时，如果此时没有写线程，它会立即获得 <code>ReadGuard</code>。</li>
<li><strong>优势</strong>：如果有 <code>reader2、reader3</code> 同时进来，只要当前没有线程持有“写锁”, 它们都可以获取读锁。这比 <code>Mutex</code> 快得多，因为 <code>Mutex</code> 会强制让读者也排队。</li>
</ul>
</li>
<li>写锁独占 (<code>.write().unwrap()</code>)：
<ul>
<li>当 <code>writer</code> 调用 <code>write()</code> 时，写锁具有排他性, 它必须等待所有正在读取的线程释放读锁，且没有其他写线程在工作。反之，只要有任何读锁未释放，写锁获取也会被阻塞。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-celltcopy-类型的轻量内部可变性"><a class="header" href="#5-celltcopy-类型的轻量内部可变性">5. <code>Cell&lt;T&gt;</code>：<code>Copy</code> 类型的轻量内部可变性</a></h2>
<p>在掌握了 <code>Rc</code> 和 <code>Arc</code> 之后，你可能已经发现它们默认是<strong>不可变共享</strong>的。为了在“不可变”的外壳下修改数据，我们需要<strong>内部可变性</strong>（<code>Interior Mutability</code>）。</p>
<p>在 <code>Rust</code> 中，如果你使用普通引用，最怕的是：“<strong>我手里拿着指向数据的指针，结果别人把数据改了/删了，导致我手里的指针失效</strong>”。
但 <code>Cell</code> 完美避开了这个问题，因为它禁止你获取内部数据的指针：</p>
<ul>
<li>没有借用：你调用 <code>c.get()</code> 时，它直接给你一个全新的副本。你手里的副本和 <code>Cell</code> 里面的原始数据已经没关系了。</li>
<li>随便覆盖：既然谁也拿不到指向 <code>Cell</code> 内部的指针，那么无论你调用多少次 <code>set</code>，都只是在修改那一块内存的值，不会破坏任何人的指针（因为根本没人持有指针）。</li>
</ul>
<p>你要会的点：</p>
<ul>
<li><code>Cell&lt;T&gt;</code> 主要用于实现了 <code>Copy</code> 特征的类型（如 <code>i32, bool, f64</code> 等简单类型）</li>
<li><code>Cell</code> 的操作逻辑不是“借用”，而是“<strong>值拷贝</strong>”。它不会给你内部数据的引用，而是让你把值取出来或存进去。</li>
<li>与其它智能指针不同，<code>Cell</code> 不提供 <code>.borrow()</code> 或 <code>.borrow_mut()</code> 方法,只有两个核心动作：
<ul>
<li><code>.get()</code>：返回内部值的一个<strong>全新的副本</strong>（<code>Copy</code>）</li>
<li><code>.set(value)</code>：将新值拷贝进去，覆盖旧值</li>
</ul>
</li>
<li>应用场景:
<ul>
<li><strong>简单标志位</strong>：在结构体内部存储一些状态标记（如 <code>is_valid: Cell&lt;bool&gt;</code>），即使结构体是以不可变引用的形式传递，也能随时更新这些标记。</li>
<li><strong>性能敏感场景</strong>：如果你只需要操作简单的数字或布尔值，且不需要获取它们的引用，选 <code>Cell</code> 而不是 <code>RefCell</code>。</li>
</ul>
</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">use std::cell::Cell;
fn main() {
    // 即使变量 c 本身没有声明为 mut
    let c = Cell::new(10);
    // 我们可以通过不可变引用修改它的值
    let c_ref1 = &amp;c;
    let c_ref2 = &amp;c;
    c_ref1.set(20); 
    c_ref2.set(30);
    println!("当前值: {}", c.get()); // 输出 30
}</code></pre>
<hr>
<h2 id="6-refcellt运行时借用检查内部可变性"><a class="header" href="#6-refcellt运行时借用检查内部可变性">6. <code>RefCell&lt;T&gt;</code>：运行时借用检查（内部可变性）</a></h2>
<p>如果说 <code>Cell&lt;T&gt;</code> 是通过“不给你指针”来保证安全，那么 <code>RefCell&lt;T&gt;</code>(<code>Reference Cell</code>) 就是通过<strong>雇佣一个运行时保安</strong>来让你安全地持有指针。</p>
<p>你要会的点：</p>
<ul>
<li>用于那些不方便拷贝（非 <code>Copy</code> 类型，比如 <code>Vec</code> 或自定义结构体），且你需要获取其引用的场景</li>
<li><strong>内部可变性（Interior Mutability）</strong> ：即便外面是不可变绑定，也能在内部修改</li>
<li>借用规则从编译时延后到运行时：
<ul>
<li><code>borrow()</code> 获取一个不可变引用, 得到 <code>Ref&lt;T&gt;</code></li>
<li><code>borrow_mut()</code> 获取一个可变引用, 得到 <code>RefMut&lt;T&gt;</code></li>
<li>在程序运行时，RefCell 内部会维护一个计数器来记录当前的借用状态,运行时违反了规则则会 <strong>panic</strong></li>
</ul>
</li>
<li>与 <code>Rc</code> 组合：<code>Rc&lt;RefCell&lt;T&gt;&gt;</code> 是单线程常见共享可变方案</li>
</ul>
<h3 id="示例共享--可变单线程"><a class="header" href="#示例共享--可变单线程">示例：共享 + 可变（单线程）</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">use std::cell::RefCell;

fn main() {
    // 数据包裹在 RefCell 中
    let data = RefCell::new(vec![1, 2, 3]);
    // 即使 data 是不可变的，我们也能获取可变借用
    {
        let mut mut_ref = data.borrow_mut();
        mut_ref.push(4);
    } // mut_ref 在这里离开作用域，借用标记被释放
    // 获取两个不可变借用
    let ref1 = data.borrow();
    let ref2 = data.borrow();
    println!("数据内容: {:?}", ref1);
}</code></pre>
<h4 id="为什么会-panic违反规则的后果"><a class="header" href="#为什么会-panic违反规则的后果">为什么会 Panic？（违反规则的后果）</a></h4>
<p>如果你尝试在同一个作用域内同时进行不可变和可变借用，RefCell 就会报错：</p>
<pre><code class="language-rust ignore">let data = RefCell::new(5);
let r1 = data.borrow();     // 运行时：不可变借用计数 +1
let r2 = data.borrow_mut(); // 运行时：发现已有不可变借用，直接 PANIC！</code></pre>
<h4 id="cellt-与-refcellt-的深度对比"><a class="header" href="#cellt-与-refcellt-的深度对比"><code>Cell&lt;T&gt;</code> 与 <code>RefCell&lt;T&gt;</code> 的深度对比</a></h4>
<p>这是笔记中最重要的部分：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>特性</th><th><code>Cell&lt;T&gt;</code></th><th><code>RefCell&lt;T&gt;</code></th></tr>
</thead>
<tbody>
<tr><td><strong>适用类型</strong></td><td>实现了 <code>Copy</code> 的简单类型</td><td>任何类型（通常是较大的对象）</td></tr>
<tr><td><strong>获取方式</strong></td><td>返回值的副本（<code>.get()</code>）</td><td>返回数据的引用（<code>.borrow()</code>）</td></tr>
<tr><td><strong>性能开销</strong></td><td><strong>零开销</strong>（仅内存拷贝）</td><td><strong>有开销</strong>（运行时维护借用计数）</td></tr>
<tr><td><strong>安全性</strong></td><td>编译时安全（无引用）</td><td><strong>运行时可能 Panic</strong></td></tr>
<tr><td><strong>线程安全</strong></td><td><strong>不安全</strong> (<code>!Sync</code>)</td><td><strong>不安全</strong> (<code>!Sync</code>)</td></tr>
</tbody>
</table>
</div>
<h4 id="-为什么需要-refcell"><a class="header" href="#-为什么需要-refcell">💡 为什么需要 <code>RefCell</code>？</a></h4>
<p>最常见的场景是：<strong>你实现了一个 Trait，而该 Trait 的方法签名要求使用不可变引用 <code>&amp;self</code>，但你的具体实现却需要修改内部状态（比如缓存、日志记录等）</strong>。</p>
<h4 id="总结一句话"><a class="header" href="#总结一句话">总结一句话</a></h4>
<blockquote>
<p><strong><code>Cell</code> 是“搬家”（拷贝值），<code>RefCell</code> 是“登记处”（在运行时盯着谁拿了钥匙，违规就报警）。</strong></p>
</blockquote>
<h3 id="rcrefcellt单线程共享--可变"><a class="header" href="#rcrefcellt单线程共享--可变"><code>Rc&lt;RefCell&lt;T&gt;&gt;</code>：单线程共享 + 可变</a></h3>
<p>这是 Rust 单线程开发中最强大的<strong>组合拳</strong>。如果你理解了 <code>Rc</code>（解决所有权共享）和 <code>RefCell</code>（解决不可变外壳下的修改），那么把它们套在一起就得到了：<strong>一个可以被多个地方同时持有、且每个地方都能修改的“共享变量”。</strong></p>
<p>在 <code>Rust</code>中，指针是表示内存地址的类型。为了实现“多处读写”这种在其他语言中很常见的行为，我们需要这种“套娃”结构。</p>
<h4 id="核心逻辑"><a class="header" href="#核心逻辑">核心逻辑</a></h4>
<ul>
<li><strong>外层 <code>Rc&lt;T&gt;**</code>：负责</strong>共享**。它允许多个变量持有指向同一块堆内存的指针，解决了“谁能拿到这块内存”的问题。</li>
<li><strong>内层 <code>RefCell&lt;T&gt;**</code>：负责</strong>修改**。它允许你在只有 <code>Rc</code> 提供的不可变引用的情况下，通过运行时检查来修改内部数据。</li>
</ul>
<p>当你创建 <code>let x = Rc::new(RefCell::new(5))</code> 时，内存中发生了以下情况：</p>
<ul>
<li><strong>栈上</strong>：有一个 <code>Rc</code> 指针</li>
<li><strong>堆上</strong>：分配了一块空间，包含
<ul>
<li><code>Rc</code> 的引用计数器</li>
<li><code>RefCell</code> 的借用状态标志位</li>
<li>实际的数据 <code>T</code>。</li>
</ul>
</li>
</ul>
<h4 id="代码示例共享计数器"><a class="header" href="#代码示例共享计数器">代码示例：共享计数器</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">use std::rc::Rc;
use std::cell::RefCell;
fn main() {
    // 1. 创建共享的可变数据
    let shared_data = Rc::new(RefCell::new(vec![1, 2, 3]));
    // 2. 克隆 Rc 指针（增加强引用计数）
    let shared_data_clone = Rc::clone(&amp;shared_data);
    // 3. 在一处修改
    {
        let mut mut_ref = shared_data.borrow_mut();
        mut_ref.push(4);
    } 
    // 4. 在另一处读取，发现数据已经变了
    println!("克隆端看到的数据: {:?}", shared_data_clone.borrow());
    // 输出: [1, 2, 3, 4]
}
</code></pre>
<h4 id="深度对比单线程-vs-多线程"><a class="header" href="#深度对比单线程-vs-多线程">深度对比：单线程 vs 多线程</a></h4>
<p>这个组合有一个完美的“多线程对应版本”，请务必记在笔记中对比：</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>场景</th><th>工具组合</th><th>逻辑</th></tr>
</thead>
<tbody>
<tr><td><strong>单线程</strong></td><td><strong><code>Rc&lt;RefCell&lt;T&gt;&gt;</code></strong></td><td><strong>引用计数 + 运行时借用检查</strong></td></tr>
<tr><td><strong>多线程</strong></td><td><strong><code>Arc&lt;Mutex&lt;T&gt;&gt;</code></strong></td><td><strong>原子计数 + 互斥锁</strong></td></tr>
</tbody>
</table>
</div>
<h4 id="风险警示运行时崩溃"><a class="header" href="#风险警示运行时崩溃">风险警示：运行时崩溃</a></h4>
<p>虽然这个组合很强，但它保留了 <code>RefCell</code> 的风险：</p>
<ul>
<li>如果你在同一个线程中，通过 <code>shared_data.borrow()</code> 拿到了一个引用还没放手，又尝试用 <code>shared_data_clone.borrow_mut()</code> 去修改，<strong>程序会直接 Panic</strong>。</li>
<li>它依然不是线程安全的，不能跨线程传递。</li>
</ul>
<hr>
<h2 id="7-cowa-t写时克隆copy-on-write"><a class="header" href="#7-cowa-t写时克隆copy-on-write">7. <code>Cow&lt;'a, T&gt;</code>：写时克隆（Copy-On-Write）</a></h2>
<p>这是 <code>Rust</code> 中一个非常“聪明”且能显著提升性能的智能指针。<code>Cow</code> 的全称是 <code>Copy-On-Write</code>（写时克隆）。它的核心思想是：<strong>不到万不得已，绝不分配内存</strong>。将内存分配<strong>推迟到真正发生修改</strong>的那一刻。</p>
<h3 id="核心定义"><a class="header" href="#核心定义">核心定义</a></h3>
<p><code>Cow</code> 是一个枚举类型，包含两个变体：<code>Borrowed(&amp;'a T)</code> 和 <code>Owned(T::Owned)</code>。它允许你以一种统一的方式处理借用的数据和拥有的数据。</p>
<ul>
<li><code>Borrowed(&amp;'a T)</code>：持有数据的只读引用</li>
<li><code>Owned(T::Owned)</code>：持有数据的所有权（通常在堆上）</li>
</ul>
<h3 id="懒惰是美德"><a class="header" href="#懒惰是美德">懒惰是美德</a></h3>
<ul>
<li>初始状态: 当你创建一个 <code>Cow</code> 时，它通常从 <code>Borrowed</code> 开始。这不需要分配新内存，开销极小。</li>
<li>读取数据：当你只需要读取时，它保持 Borrowed 状态，性能损耗为 <code>O(1)</code>。</li>
<li>修改数据：当你调用 <code>.to_mut()</code> 尝试修改数据时，<code>Cow</code> 会检查：如果已经是 <code>Owned</code>，直接返回引用。如果是 <code>Borrowed</code>，此时才会执行克隆（<code>Clone</code>），将数据变为 <code>Owned</code>，然后再让你修改。</li>
</ul>
<p>你要会的点：</p>
<ul>
<li>表示“要么借用，要么拥有”</li>
<li>读操作零拷贝，写操作才会 <code>to_mut()</code> 触发克隆</li>
<li>常见场景：字符串处理、API 既接受 <code>&amp;str</code> 又能返回 <code>String</code> 的优化</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">use std::borrow::Cow;
// 如果不需要修改，就借用输入（零拷贝）；
// 如果需要修改，再转成拥有的 String。
fn normalize(s: &amp;str) -&gt; Cow&lt;'_, str&gt; {
    if s.contains(' ') {
        // 需要修改：分配新 String（Owned）
        Cow::Owned(s.replace(' ', "_"))
    } else {
        // 不需要修改：直接借用（Borrowed）
        Cow::Borrowed(s)
    }
}
fn main() {
    let a = normalize("hello");
    let b = normalize("hello world");

    println!("a = {}", a);
    println!("b = {}", b);
}</code></pre>
<hr>
<h2 id="8-pinp禁止被移动自引用异步"><a class="header" href="#8-pinp禁止被移动自引用异步">8. <code>Pin&lt;P&gt;</code>：禁止被移动（自引用/异步）</a></h2>
<p>这是 Rust 中最“玄学”但也最底层、最重要的智能指针之一。如果说 <code>Box</code> 是为了放进堆里，那么 <code>Pin</code> 就是为了<strong>锁死内存地址</strong>。</p>
<h3 id="define"><a class="header" href="#define">Define</a></h3>
<h4 id="a-核心危机自引用结构-self-referential-structs"><a class="header" href="#a-核心危机自引用结构-self-referential-structs">A. 核心危机：自引用结构 (Self-referential Structs)</a></h4>
<p>在 Rust 中，几乎所有类型都是可以移动的（<code>Move</code>）。这意味着如果你把一个变量传给另一个函数，它的<strong>内存地址可能会发生改变</strong>。但在某些特殊场景下，这种“移动”会导致程序崩溃。</p>
<p>想象一个结构体，它的一个字段是指向另一个字段的指针：</p>
<pre><code class="language-rust ignore">struct SelfRef {
    data: String,
    ptr: *const String, // 这个指针指向同一个结构体里的 data
}
</code></pre>
<ol>
<li><strong>初始状态</strong>：<code>ptr</code> 记录了 <code>data</code> 在内存中的地址（比如 <code>0x100</code>）。</li>
<li><strong>发生移动</strong>：如果你把这个结构体移动到堆上或者传给另一个线程，整个结构体的内存地址变了（变成了 <code>0x200</code>）。</li>
<li><strong>结果</strong>：<code>data</code> 的新地址是 <code>0x200</code>，但 <code>ptr</code> 仍然指着旧地址 <code>0x100</code>。<strong>指针失效了！</strong> 这会导致未定义行为。</li>
</ol>
<h4 id="b-pinp-的作用"><a class="header" href="#b-pinp-的作用">B. <code>Pin&lt;P&gt;</code> 的作用</a></h4>
<p><code>Pin</code> 的作用就是：<strong>给指针加一个约束，保证它指向的数据在内存中永远不会被移动。</strong></p>
<ul>
<li>一旦数据被 <code>Pin</code> 住，你无法再通过 <code>mem::swap</code> 或移动所有权等方式改变它的物理位置。</li>
<li>它主要配合 <code>P</code>（通常是 <code>Box</code> 或引用）使用，形成 <code>Pin&lt;Box&lt;T&gt;&gt;</code> 或 <code>Pin&lt;&amp;mut T&gt;</code>。</li>
</ul>
<h4 id="c-为什么异步asyncawait必须用它"><a class="header" href="#c-为什么异步asyncawait必须用它">C. 为什么异步（Async/Await）必须用它？</a></h4>
<p>这是 <code>Pin</code> 最主要的应用场景。</p>
<ul>
<li>当你写 <code>async</code> 块时，编译器会将其转换为一个状态机（实现了 <code>Future</code> trait）。</li>
<li>这个状态机内部经常包含自引用（例如：一个局部变量被引用后跨越了 <code>.await</code> 点）。</li>
<li>因此，<code>Future</code> 的 <code>poll</code> 方法签名必须是 <code>fn poll(self: Pin&lt;&amp;mut Self&gt;, ...)</code>。<strong>没有 <code>Pin</code>，异步代码就无法保证内存安全。</strong></li>
</ul>
<hr>
<h4 id="d-unpin-特征谁可以豁免"><a class="header" href="#d-unpin-特征谁可以豁免">D. <code>Unpin</code> 特征：谁可以豁免？</a></h4>
<p>并不是所有东西都需要被“锁死”。Rust 定义了一个标记特征 <strong><code>Unpin</code></strong>：</p>
<ul>
<li><strong><code>Unpin</code> 类型</strong>：绝大多数普通类型（如 <code>i32</code>, <code>String</code>, <code>Box</code>）。它们即便被移动也是安全的。对于这些类型，<code>Pin&lt;P&gt;</code> 没有任何实际限制，可以随意拿回可变引用。</li>
<li><strong><code>!Unpin</code> 类型</strong>：不能被移动的类型（如异步生成的 <code>Future</code>、自引用结构）。它们必须被 <code>Pin</code> 保护，否则编译器会阻止某些危险操作。</li>
</ul>
<hr>
<h4 id="如何通俗理解-pin"><a class="header" href="#如何通俗理解-pin">如何通俗理解 <code>Pin</code>？</a></h4>
<ul>
<li><strong>普通指针</strong>：像一张写着地址的便签。你可以把便签传来传去，房子（数据）也可能搬家。</li>
<li><strong><code>Pin</code> 指针</strong>：像一颗<strong>钉子</strong>。它不仅告诉你地址，还将房子死死地钉在原地，不准搬家，直到房子被拆除（Drop）为止。</li>
</ul>
<h4 id="选型指南"><a class="header" href="#选型指南">选型指南</a></h4>
<ol>
<li>如果你的数据不包含指向自身的指针，**不需要 <code>Pin**</code>。</li>
<li>如果你在手写复杂的 <code>Future</code> 或者构建自引用底层库，**必须用 <code>Pin**</code>。</li>
</ol>
<p>这个示例只是让你看到 <code>Pin&lt;Box&lt;T&gt;&gt;</code>的写法；真正需要 <code>Pin</code> 的场景主要在 <code>async/Future</code> 或自引用结构里。</p>
<pre class="playground"><code class="language-rust editable edition2024">use std::pin::Pin;
fn main() {
    let x = Box::new(123);
    // Pin&lt;Box&lt;T&gt;&gt;：把堆上的 T “固定住”，承诺之后不会再移动它的内存地址
    let pinned: Pin&lt;Box&lt;i32&gt;&gt; = Box::pin(*x);
    // 访问内部值：as_ref 得到 Pin&lt;&amp;T&gt;，get_ref 拿到 &amp;T
    let r: &amp;i32 = pinned.as_ref().get_ref();
    println!("pinned value = {}", r);
}</code></pre>
<hr>
<h2 id="9-boxdyn-trait--rcdyn-traittrait-object-与动态分发"><a class="header" href="#9-boxdyn-trait--rcdyn-traittrait-object-与动态分发">9. <code>Box&lt;dyn Trait&gt;</code> / <code>Rc&lt;dyn Trait&gt;</code>：trait object 与动态分发</a></h2>
<p>这是 Rust 智能指针系列的最后一项核心应用。如果你需要处理<strong>不同类型但实现了相同特征</strong>的对象（例如一个数组里既有“圆形”又有“正方形”），你就必须用到 <code>Box&lt;dyn Trait&gt;</code> 或 <code>Rc&lt;dyn Trait&gt;</code>。</p>
<p>在 Rust 中，指针是表示内存地址的类型。由于不同类型的大小不同，我们无法直接在栈上存储“某个特征”，必须通过智能指针将其包装成 <strong>Trait Object</strong>。</p>
<p>你要会的点：</p>
<ul>
<li><strong>静态分发（泛型） vs 动态分发（trait object）</strong></li>
<li>对象安全（object safety）限制：哪些 trait 能变成 <code>dyn Trait</code></li>
<li>fat pointer（数据指针 + vtable），大小/性能直觉</li>
</ul>
<h3 id="前置知识"><a class="header" href="#前置知识">前置知识</a></h3>
<h4 id="a-为什么必须用-box-或-rc"><a class="header" href="#a-为什么必须用-box-或-rc">A. 为什么必须用 <code>Box</code> 或 <code>Rc</code>？</a></h4>
<p>特征（Trait）本身是 <strong>DST (Dynamically Sized Type)</strong>，即“动态大小类型”。</p>
<ul>
<li>编译器在编译时不知道具体是哪个结构体实现了该特征，因此不知道它占用多少内存。</li>
<li><strong>解决方案</strong>：将对象放入堆中。<code>Box&lt;dyn Trait&gt;</code> 的大小是固定的（指针大小），无论堆上的对象实际有多大。</li>
</ul>
<h4 id="b-物理结构胖指针-fat-pointer"><a class="header" href="#b-物理结构胖指针-fat-pointer">B. 物理结构：胖指针 (Fat Pointer)</a></h4>
<p>当你使用 <code>Box&lt;dyn Trait&gt;</code> 时，这个指针在栈上占用 <strong>2 个单元</strong>（通常是 16 字节）：</p>
<ol>
<li><strong>数据指针</strong>：指向堆内存中具体的对象数据。</li>
<li><strong>vtable 指针</strong>：指向一个“虚函数表”。表中记录了该特定类型实现该 Trait 的方法地址。</li>
</ol>
<h4 id="c-静态分发-vs-动态分发"><a class="header" href="#c-静态分发-vs-动态分发">C. 静态分发 vs 动态分发</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>特性</th><th>静态分发 (Generics <code>&lt;T: Trait&gt;</code>)</th><th>动态分发 (<code>dyn Trait</code>)</th></tr>
</thead>
<tbody>
<tr><td><strong>原理</strong></td><td>编译时为每种类型生成一份代码（单态化）。</td><td>运行时通过 vtable 查找函数地址。</td></tr>
<tr><td><strong>性能</strong></td><td><strong>极快</strong>。编译器可以进行内联优化。</td><td><strong>略慢</strong>。存在指针跳转开销，无法内联。</td></tr>
<tr><td><strong>灵活性</strong></td><td>集合中只能存同一种类型。</td><td><strong>极高</strong>。集合中可以存多种不同类型。</td></tr>
</tbody>
</table>
</div>
<h4 id="d-代码示例不同类型的绘图"><a class="header" href="#d-代码示例不同类型的绘图">D. 代码示例：不同类型的“绘图”</a></h4>
<pre class="playground"><code class="language-rust editable edition2024">trait Draw {
    fn draw(&amp;self);
}

struct Button { width: u32 }
impl Draw for Button {
    fn draw(&amp;self) { println!("渲染按钮，宽度: {}", self.width); }
}

struct Image { url: String }
impl Draw for Image {
    fn draw(&amp;self) { println!("渲染图片，源自: {}", self.url); }
}

fn main() {
    // 使用 Box&lt;dyn Draw&gt; 存储不同类型的对象
    let components: Vec&lt;Box&lt;dyn Draw&gt;&gt; = vec![
        Box::new(Button { width: 100 }),
        Box::new(Image { url: String::from("logo.png") }),
    ];

    for comp in components {
        comp.draw(); // 运行时动态分发：查表并调用对应方法
    }
}
</code></pre>
<h3 id="什么时候用-boxdyn-trait"><a class="header" href="#什么时候用-boxdyn-trait">什么时候用 <code>Box&lt;dyn Trait&gt;</code>？</a></h3>
<ol>
<li><strong>异质集合</strong>：当你需要一个 <code>Vec</code> 存储多种实现了相同接口的类型时。</li>
<li><strong>解耦</strong>：当你不想在函数签名中暴露具体类型，只想表达“只要实现了这个特征就行”时。</li>
<li><strong>减少编译时间</strong>：泛型会导致代码膨胀（单态化），而 <code>dyn Trait</code> 只有一份代码，可以缩短大型项目的编译时间。</li>
</ol>
<hr>
<h2 id="10-自定义智能指针进阶"><a class="header" href="#10-自定义智能指针进阶">10. 自定义智能指针（进阶）</a></h2>
<p>你要会的点：</p>
<ul>
<li>如何实现自己的指针类型：
<ul>
<li>实现 <code>Deref/DerefMut</code>，让它像引用一样用</li>
<li>实现 <code>Drop</code>，在释放时执行资源回收</li>
</ul>
</li>
<li>RAII 模式（文件句柄、网络连接、锁守卫等）</li>
<li><code>PhantomData</code>（用于告诉编译器“我逻辑上拥有/借用某个 T”，影响 drop check/variance）——偏高级，但智能指针写多了会遇到</li>
</ul>
<p>要自定义一个智能指针，本质上是创建一个结构体，并为它实现两个核心特征（Trait）：<strong><code>Deref</code></strong> 和 <strong><code>Drop</code></strong>。在 Rust 中，正是这两个特征让普通结构体拥有了“像指针一样工作”和“自动管理资源”的超能力。</p>
<h3 id="1-自定义智能指针的核心公式"><a class="header" href="#1-自定义智能指针的核心公式">1. 自定义智能指针的核心公式</a></h3>
<ul>
<li><strong><code>Deref</code> 特征</strong>：允许你通过解引用操作符（<code>*</code>）访问内部数据。</li>
<li><strong><code>Drop</code> 特征</strong>：定义当指针离开作用域时该执行什么清理逻辑（例如释放内存、关闭文件、打印日志）。</li>
</ul>
<h3 id="2-实战演练创建一个简单的-myboxt"><a class="header" href="#2-实战演练创建一个简单的-myboxt">2. 实战演练：创建一个简单的 <code>MyBox&lt;T&gt;</code></a></h3>
<p>我们将模仿 <code>Box&lt;T&gt;</code> 的行为，创建一个能包裹数据的智能指针。</p>
<pre class="playground"><code class="language-rust editable edition2024">use std::ops::Deref;

//A. 定义结构体
struct MyBox&lt;T&gt;(T); // 元组结构体
impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}

//B. 实现 `Deref` (让它能被 `*` 解引用)
//如果不实现 `Deref`，编译器就不知道执行 `*my_box` 时该返回什么。
impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T; // 关联类型，指定解引用后得到的类型
    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0 // 返回元组中的第一个元素引用
    }
}
//C. 实现 `Drop` (赋予它自动清理的能力)
impl&lt;T&gt; Drop for MyBox&lt;T&gt; {
    fn drop(&amp;mut self) {
        println!("MyBox 指针被销毁了，资源已释放！");
    }
}

fn main() {
    let x = 5;
    let y = MyBox::new(x);
    assert_eq!(5, x);
    assert_eq!(5, *y); // 这里触发了 y.deref()
    println!("y 的值是: {}", *y);
} // y 在这里离开作用域，触发 drop() 方法</code></pre>
<h3 id="3-深度原理deref-强制转换-deref-coercion"><a class="header" href="#3-深度原理deref-强制转换-deref-coercion">3. 深度原理：Deref 强制转换 (Deref Coercion)</a></h3>
<p>这是 Rust 智能指针极其好用的秘密武器。<strong>Deref 强制转换</strong>可以将一个实现了 <code>Deref</code> 的类型的引用转换为它内部类型的引用。</p>
<p><strong>例子：</strong>
如果你有一个 <code>MyBox&lt;String&gt;</code>，Rust 可以自动将其转换为 <code>&amp;str</code>：</p>
<pre><code class="language-rust ignore">fn hello(name: &amp;str) {
    println!("Hello, {}!", name);
}
fn main() {
    let m = MyBox::new(String::from("Rust"));
    // &amp;m 是 &amp;MyBox&lt;String&gt;
    // Rust 自动调用 deref 将其变为 &amp;String
    // String 也实现了 Deref，再次调用 deref 变为 &amp;str
    hello(&amp;m); 
}</code></pre>
<hr>
<h2 id="11-选择指南"><a class="header" href="#11-选择指南">11. 选择指南</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>需求场景</th><th>推荐指针</th><th>备注</th></tr>
</thead>
<tbody>
<tr><td><strong>堆分配、大数据传递、递归类型</strong></td><td><strong><code>Box&lt;T&gt;</code></strong></td><td>唯一所有权，开销最低。</td></tr>
<tr><td><strong>单线程、多处共享只读数据</strong></td><td><strong><code>Rc&lt;T&gt;</code></strong></td><td>引用计数。</td></tr>
<tr><td><strong>多线程、多处共享只读数据</strong></td><td><strong><code>Arc&lt;T&gt;</code></strong></td><td>原子引用计数，线程安全。</td></tr>
<tr><td><strong>单线程、小对象内部可变 (Copy类型)</strong></td><td><strong><code>Cell&lt;T&gt;</code></strong></td><td>get/set 值拷贝。</td></tr>
<tr><td><strong>单线程、大对象内部可变 (非Copy)</strong></td><td><strong><code>RefCell&lt;T&gt;</code></strong></td><td>运行时借用检查。</td></tr>
<tr><td><strong>单线程、多所有权共享且可修改</strong></td><td><strong><code>Rc&lt;RefCell&lt;T&gt;&gt;</code></strong></td><td>经典套娃组合。</td></tr>
<tr><td><strong>多线程、共享且可修改</strong></td><td><strong><code>Arc&lt;Mutex&lt;T&gt;&gt;</code></strong></td><td>并发黄金搭档。</td></tr>
<tr><td><strong>避免循环引用、内存泄漏</strong></td><td><strong><code>Weak&lt;T&gt;</code></strong></td><td>配合 Rc 或 Arc 使用。</td></tr>
<tr><td><strong>性能优化、按需克隆</strong></td><td><strong><code>Cow&lt;T&gt;</code></strong></td><td>写时克隆。</td></tr>
<tr><td><strong>异步编程、锁死内存地址</strong></td><td><strong><code>Pin&lt;P&gt;</code></strong></td><td>防止自引用结构移动。</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="生命周期"><a class="header" href="#生命周期">生命周期</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="迭代器"><a class="header" href="#迭代器">迭代器</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="宏"><a class="header" href="#宏">宏</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="unsafe-code"><a class="header" href="#unsafe-code">UnSafe Code</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="项目组织及依赖管理"><a class="header" href="#项目组织及依赖管理">项目组织及依赖管理</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="项目结构"><a class="header" href="#项目结构">项目结构</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cargotoml"><a class="header" href="#cargotoml">Cargo.Toml</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="文档"><a class="header" href="#文档">文档</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cargo"><a class="header" href="#cargo">Cargo</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cargo-命令"><a class="header" href="#cargo-命令">Cargo 命令</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cargo-工具链"><a class="header" href="#cargo-工具链">Cargo 工具链</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="三方库"><a class="header" href="#三方库">三方库</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="serde"><a class="header" href="#serde">serde</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="leetcode"><a class="header" href="#leetcode">LeetCode</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="定长滑动窗口"><a class="header" href="#定长滑动窗口">定长滑动窗口</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="定长滑动窗口-1"><a class="header" href="#定长滑动窗口-1">定长滑动窗口</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace-2a3cd908.js"></script>
        <script src="mode-rust-2c9d5c9a.js"></script>
        <script src="editor-16ca416c.js"></script>
        <script src="theme-dawn-4493f9c8.js"></script>
        <script src="theme-tomorrow_night-9dbe62a9.js"></script>

        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
