<!DOCTYPE HTML>
<html lang="zh-CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust study</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom-7e8a6fc2.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-0ceb304c.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-d8ebfcf5.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust study</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/169li/rust-study" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<p>个人在学习Rust过程中的一些笔记记录:</p>
<ul>
<li>Rust语法基础</li>
<li>Rust算法刷题</li>
<li>…..</li>
</ul>
<p>参考的资料有：</p>
<p><a href="https://course.rs/about-book.html">Rust语言圣经(Rust Course)</a></p>
<p><a href="https://practice-zh.course.rs/why-exercise.html">练习实践</a></p>
<p><a href="https://rust-lang.github.io/api-guidelines/about.html">API编程指南</a></p>
<p><a href="https://rust.sui-book.com/01_basics/01_intro.html">Rust带学</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rust学习"><a class="header" href="#rust学习">Rust学习</a></h1>
<p>学习笔记中可能由于编译器的更新，一些地方可能与现在不一致。</p>
<p>2024年12月31日</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="基础语法"><a class="header" href="#基础语法">基础语法</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="变量"><a class="header" href="#变量">变量</a></h1>
<p>在 Rust 中，变量的处理方式与其他编程语言（如 Python 或 Java）有很大不同。其核心设计理念是<strong>安全性</strong>和<strong>内存管理</strong>。</p>
<p>以下是关于 Rust 变量的核心知识点：</p>
<h2 id="变量绑定"><a class="header" href="#变量绑定">变量绑定</a></h2>
<p>在很多编程语言中，我们会说“给变量赋值”。但在 Rust 中，官方术语通常是  <strong>“变量绑定” (Variable Binding)</strong> 。</p>
<ul>
<li><strong>语法</strong> ：<code>let x = 5;</code></li>
<li><strong>核心逻辑</strong> ：这个语句意味着我们将名字 <code>x</code> 与值 <code>5</code> <strong>绑定</strong>在一起。</li>
<li><strong>为什么叫“绑定”？</strong>
<ul>
<li><strong>模式匹配</strong> ：<code>let</code> 关键字后面跟着的实际上是一个 <strong>模式 (Pattern)</strong> 。例如，你可以这样写：<code>let (a, b) = (1, 2);</code>。这里 Rust 会把元组中的值分别绑定到 <code>a</code> 和 <code>b</code> 上。</li>
<li><strong>所有权控制</strong> ：绑定不仅仅是内存地址的赋值，它还涉及到 Rust 核心的<strong>所有权 (Ownership)</strong> 系统。当一个值绑定到一个变量名时，这个变量名就“拥有”了这个值。</li>
</ul>
</li>
</ul>
<h3 id="使用下划线忽略未使用的变量"><a class="header" href="#使用下划线忽略未使用的变量">使用下划线忽略未使用的变量</a></h3>
<p>Rust 编译器非常注重代码的整洁。如果声明了一个变量但从未使用过它，编译器会报出警告（Warning），认为这可能是代码逻辑上的疏忽。</p>
<h4 id="a-使用-_-纯下划线"><a class="header" href="#a-使用-_-纯下划线">A. 使用 <code>_</code> (纯下划线)</a></h4>
<p>如果你完全不关心某个值，可以使用 <code>_</code>。它会立即丢弃该值，不会进行任何绑定。</p>
<pre class="playground"><code class="language-rust editable edition2024"><span class="boring">fn main() {
</span>    let _ = 5; // 值被直接丢弃, 不绑定到任何名字, 你之后无法通过任何名字访问这个 5
    let _ = some_function_returns_result(); // 我调用了函数，但我不在乎返回值
}
fn some_function_returns_result() -&gt; i32 {
    42
}</code></pre>
<h4 id="b-使用下划线开头-如-_x"><a class="header" href="#b-使用下划线开头-如-_x">B. 使用下划线开头 (如 <code>_x</code>)</a></h4>
<p>如果你想保留这个变量（可能为了调试或者为了以后扩展），但现在暂时不用，又不希望看到编译器的警告，可以在变量名前加一个下划线。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 5;     // ⚠️ 编译器会警告：unused variable: `x`
    let _y = 10;   // ✅ 编译器会保持沉默，因为它看到了下划线前缀
}</code></pre>
<p>cargo run:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>warning: unused variable: `y`
 --&gt; src/main.rs:3:9
  |
3 |     let y = 10;
  |         ^ help: 如果 y 故意不被使用，请添加一个下划线前缀: `_y`
  |
  = note: `#[warn(unused_variables)]` on by default
<span class="boring">}</span></code></pre>
<hr>
<h2 id="不可变性"><a class="header" href="#不可变性">不可变性</a></h2>
<p>在 Rust 中，变量<strong>默认是不可变的</strong>。一旦你为一个变量绑定了值，就不能再修改它。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 5;
    x = 6; // ❌ 编译错误！不能对不可变变量二次赋值
}</code></pre>
<p><strong>为什么要这样做？</strong></p>
<p>通过默认不可变，Rust 保证了数据的安全性。在多线程环境下，你可以确信一个变量的值不会在你不注意的时候被其他代码修改。</p>
<hr>
<h2 id="可变变量"><a class="header" href="#可变变量">可变变量</a></h2>
<p>如果你需要修改某个变量，必须显式地加上 <code>mut</code> 关键字。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut x = 5;
    println!("x 的值是: {}", x);
    x = 6; // ✅ 允许修改
    println!("现在 x 的值是: {}", x);
}</code></pre>
<hr>
<h2 id="变量遮蔽"><a class="header" href="#变量遮蔽">变量遮蔽</a></h2>
<p>Rust 允许你声明一个与现有变量同名的新变量。这被称为“遮蔽”。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 5;
    let x = x + 1; // 遮蔽了之前的 x
  
    {
        let x = x * 2; // 在当前作用域内再次遮蔽
        println!("内部作用域中 x 的值: {}", x); // 12
    }

    println!("外部作用域中 x 的值: {}", x); // 6
}
</code></pre>
<p><strong>遮蔽与 <code>mut</code> 的区别：</strong></p>
<ol>
<li><strong>类型转换</strong>：使用 <code>let</code> 遮蔽时，你可以改变变量的类型（例如从字符串变为数字），而 <code>mut</code> 变量的类型是固定的。</li>
<li><strong>重新锁定</strong>：遮蔽后，新变量如果没有 <code>mut</code>，它依然是不可变的。</li>
</ol>
<hr>
<h2 id="常量"><a class="header" href="#常量">常量</a></h2>
<p>常量类似于不可变变量，但有严格的区别：</p>
<ul>
<li>使用 <code>const</code> 关键字。</li>
<li><strong>必须</strong>显式注明类型（例如 <code>i32</code>）。</li>
<li>可以在任何作用域声明（包括全局）。</li>
<li>只能赋值为“常量表达式”，不能是函数调用的结果或运行时计算的值。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
fn main() {
    println!("三小时的秒数: {}", THREE_HOURS_IN_SECONDS);
}</code></pre>
<h2 id="作用域"><a class="header" href="#作用域">作用域</a></h2>
<p>变量在 Rust 中是“块级作用域”的。变量在声明的大括号 <code>{}</code> 内有效，超出范围后，变量会被<strong>释放 (Drop)</strong>。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let s = "hello"; // s 进入作用域
    {
        let x = 10; // x 进入作用域
    } // x 在这里失效并释放
    println!("s 的值是: {}", s); // ✅ 可以访问 s
} // s 在这里失效并释放





</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h1>
<h2 id="1-标量类型scalar-types"><a class="header" href="#1-标量类型scalar-types">1. 标量类型(Scalar Types)</a></h2>
<p>标量类型代表一个单一的值。</p>
<h3 id="a-整数类型-integers"><a class="header" href="#a-整数类型-integers">A. 整数类型 (Integers)</a></h3>
<p>Rust 提供了非常精细的整数控制，分为有符号（<code>i</code>）和无符号（<code>u</code>）。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>长度</th><th>有符号 (Signed)</th><th>无符号 (Unsigned)</th><th>范围 (n 为位数)</th></tr>
</thead>
<tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td><td><code>i8: -(2^(8-1))</code> ~ <code>2^(8-1)-1</code>,<br /> <code>u8: 0</code> ~<code> 2^8-1</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td><td><code>i16: -(2^(16-1))</code> ~<code>2^(16-1)-1</code>,<br /><code>u16: 0</code> ~<code>2^16-1</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code> (默认)</td><td><code>u32</code></td><td><code>i32: -(2^(32-1))</code> ~<code>2^(32-1)-1</code>,<br /><code>u32: 0 </code> ~<code> 2^32-1</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td><td><code>i64: -(2^(64-1))</code> ~<code>2^(64-1)-1</code>,<br /><code>u64: 0 </code> ~<code> 2^64-1</code></td></tr>
<tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td><td><code>i128:-(2^(128-1))</code> ~<code>2^(128-1)-1</code>,<br /><code>u128: 0 </code> ~<code> 2^128-1</code></td></tr>
<tr><td>arch (平台相关)</td><td><code>isize</code></td><td><code>usize</code></td><td>取决于计算机架构 (64位或32位)</td></tr>
</tbody>
</table>
</div>
<ul>
<li>
<p><strong><code>usize</code> / <code>isize</code> 的用途</strong>：常用于集合索引、切片范围、长度（如 <code>len()</code>）、以及与内存地址大小相关的场景。</p>
</li>
<li>
<p><strong>整数字面值</strong>：可以使用 <code>_</code> 分隔增强可读性，如 <code>1_000_000</code>。支持 <code>0x</code>（十六进制）、<code>0o</code>（八进制）、<code>0b</code>（二进制）。</p>
</li>
<li>
<p><strong>类型后缀</strong>：可在字面量后加后缀明确类型，如 <code>10u8</code>、<code>20i64</code>。</p>
</li>
<li>
<p><strong>溢出行为</strong>：</p>
<ul>
<li>debug 构建：整数溢出会触发 <code>panic!</code></li>
<li>release 构建：默认按补码进行回绕（wrapping）</li>
<li>常见策略方法：<code>wrapping_add</code>、<code>checked_add</code>、<code>overflowing_add</code>、<code>saturating_add</code></li>
</ul>
</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let a: u8 = 250;
    assert_eq!(a.wrapping_add(10), 4);
    assert_eq!(a.checked_add(10), None);
}</code></pre>
<hr>
<h3 id="b-浮点类型-floating-point"><a class="header" href="#b-浮点类型-floating-point">B. 浮点类型 (Floating-Point)</a></h3>
<p>Rust 遵循 IEEE-754 标准：</p>
<ul>
<li><strong><code>f32</code></strong>：单精度。</li>
<li><strong><code>f64</code></strong>：双精度（默认，因为在现代 CPU 上速度几乎与 <code>f32</code> 一样快，但精度更高）。</li>
</ul>
<p>浮点数相关注意点：</p>
<ul>
<li><strong>精度误差</strong>：尽量避免直接用 <code>==</code> 比较业务浮点值，常用误差范围比较。</li>
<li><strong>NaN</strong>：<code>NaN != NaN</code>，这会影响比较与排序逻辑。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 0.1f64 + 0.2;
    assert!((x - 0.3).abs() &lt; 1e-10);
}</code></pre>
<hr>
<h3 id="c-布尔与字符"><a class="header" href="#c-布尔与字符">C. 布尔与字符</a></h3>
<ul>
<li><strong><code>bool</code></strong>：<code>true</code> 和 <code>false</code>。通常占用 1 个字节。</li>
<li><strong><code>char</code></strong>：占用 <strong>4 个字节</strong>，代表一个 <strong>Unicode 标量值</strong>，可以表示中文、日文、表情符号 (Emoji) 等。<code>char</code> 不是 UTF-8 的“一个字节”，也不等同于字符串的长度单位。</li>
</ul>
<hr>
<h2 id="2-复合类型-compound-types"><a class="header" href="#2-复合类型-compound-types">2. 复合类型 (Compound Types)</a></h2>
<p>将多个值组合成一个类型。</p>
<h3 id="a-元组-tuple"><a class="header" href="#a-元组-tuple">A. 元组 (Tuple)</a></h3>
<ul>
<li><strong>特点</strong>：长度固定，<strong>各元素类型可以不同</strong>。</li>
<li><strong>定义</strong>：<code>let tup: (i32, f64, u8) = (500, 6.4, 1);</code></li>
<li><strong>访问</strong>：使用点号，如 <code>tup.0</code>。</li>
<li><strong>解构</strong>：可用模式匹配直接拆开。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    let (x, y, z) = tup;
}</code></pre>
<ul>
<li><strong>单元类型 <code>()</code></strong>：不包含任何值的元组，常作为表达式的默认返回值或占位类型。</li>
</ul>
<hr>
<h3 id="b-数组-array"><a class="header" href="#b-数组-array">B. 数组 (Array)</a></h3>
<ul>
<li><strong>特点</strong>：长度固定，<strong>各元素类型必须相同</strong>。</li>
<li><strong>定义</strong>：<code>let a = [1, 2, 3, 4, 5];</code></li>
<li><strong>类型与长度声明</strong>：<code>let a: [i32; 5] = [1, 2, 3, 4, 5];</code></li>
<li><strong>重复初始化</strong>：<code>let a = [0u8; 1024];</code></li>
<li><strong>存储</strong>：数组是固定大小的值类型，作为局部变量时通常位于栈上；若被 <code>Box</code> 等包裹，则数据会位于堆上。</li>
</ul>
<p>数组访问与边界：</p>
<ul>
<li><code>a[i]</code>：越界会 <code>panic!</code></li>
<li><code>a.get(i)</code>：返回 <code>Option&lt;&amp;T&gt;</code>，更安全</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let a = [1, 2, 3];
    assert_eq!(a.get(10), None);
}</code></pre>
<hr>
<h2 id="3-序列与字符串-sequences--strings"><a class="header" href="#3-序列与字符串-sequences--strings">3. 序列与字符串 (Sequences &amp; Strings)</a></h2>
<p>这一部分常见困惑点集中在 UTF-8 与内存分配方式。</p>
<h3 id="a-字符串-strings"><a class="header" href="#a-字符串-strings">A. 字符串 (Strings)</a></h3>
<p>Rust 核心语言层面有 <code>str</code>（动态大小类型，通常以引用切片 <code>&amp;str</code> 出现），标准库提供可增长的 <code>String</code>。</p>
<ul>
<li><strong><code>String</code></strong>：拥有所有权，数据在堆上，可增长。内部包含指针、长度、容量等信息。</li>
<li><strong><code>&amp;str</code></strong>：字符串切片，是对一段 UTF-8 字节序列的借用视图。引用本身在栈上，实际数据可能来自只读区（字符串字面量）、栈或堆。</li>
</ul>
<p>常见转换：</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let s1: String = "hello".to_string();
    let s2: &amp;str = &amp;s1;           // &amp;String 自动解引用成 &amp;str
    let s3: String = s2.to_owned(); // 或 s2.to_string()
}</code></pre>
<p>字符串索引与切片规则：</p>
<ul>
<li>Rust 不支持 <code>s[0]</code> 直接索引字符，因为 UTF-8 下“字符边界”与字节下标不总一致。</li>
<li><code>&amp;s[a..b]</code> 必须落在 UTF-8 字符边界，否则运行时会 <code>panic!</code>。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let s = "中文";
    let ok = &amp;s[0..3]; // "中" 占 3 个字节
}</code></pre>
<hr>
<h3 id="b-切片-slices"><a class="header" href="#b-切片-slices">B. 切片 (Slices)</a></h3>
<p>切片引用连续的一段序列，而不是整个集合。</p>
<ul>
<li><strong>数组/向量切片</strong>：<code>&amp;[T]</code></li>
<li><strong>字符串切片</strong>：<code>&amp;str</code>（本质上也是切片）</li>
</ul>
<p>示例：</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let a = [10, 20, 30, 40, 50];
    let slice = &amp;a[1..3]; // &amp;[20, 30]
}</code></pre>
<p>切片是一种“胖指针”，通常包含地址与长度信息，因此可以安全地携带边界。</p>
<hr>
<h2 id="4-标准库集合-standard-collections"><a class="header" href="#4-标准库集合-standard-collections">4. 标准库集合 (Standard Collections)</a></h2>
<p>虽然属于标准库，但它们在实际开发中几乎被当作基础类型使用。</p>
<h3 id="a-vect-vector"><a class="header" href="#a-vect-vector">A. <code>Vec&lt;T&gt;</code> (Vector)</a></h3>
<ul>
<li>动态数组，在堆上分配，可扩容。</li>
<li>常见 API：<code>push</code>、<code>pop</code>、<code>len</code>、<code>capacity</code>、<code>get</code>、切片 <code>&amp;v[a..b]</code> 等。</li>
<li>预分配容量：<code>Vec::with_capacity(n)</code> 可减少扩容次数。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut v = Vec::new();
    v.push(1);
    v.extend([2, 3, 4]);
    println!("{:?}", v);

    let first = v.get(0);   // Option&lt;&amp;i32&gt;
    let part = &amp;v[1..3];    // &amp;[i32]
    println!("{:?}", part);
}</code></pre>
<hr>
<h3 id="b-hashmapk-v"><a class="header" href="#b-hashmapk-v">B. <code>HashMap&lt;K, V&gt;</code></a></h3>
<ul>
<li>键值对映射结构。</li>
<li>常用 <code>entry</code> 模式在“插入或更新”时更方便。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    use std::collections::HashMap;

    let mut m = HashMap::new();
    m.insert("a", 1);
    println!("{:?}", m);

    *m.entry("a").or_insert(0) += 1;
    println!("{:?}", m);
}</code></pre>
<hr>
<h2 id="5-特殊底层类型"><a class="header" href="#5-特殊底层类型">5. 特殊/底层类型</a></h2>
<h3 id="a-枚举-enums"><a class="header" href="#a-枚举-enums">A. 枚举 (Enums)</a></h3>
<p>枚举用于表示“一组有限的可能取值”。Rust 的枚举非常强大：每个变体（variant）不仅能表示不同分支，还能携带不同类型的数据，因此很适合用来建模状态机、协议消息、错误类型等。</p>
<ol>
<li>基本定义与使用</li>
</ol>
<pre class="playground"><code class="language-rust editable edition2024">enum Direction {
    Up,
    Down,
    Left,
    Right,
}
fn move_step(d: Direction) {
    match d {
        Direction::Up =&gt; println!("up"),
        Direction::Down =&gt; println!("down"),
        Direction::Left =&gt; println!("left"),
        Direction::Right =&gt; println!("right"),
    }
}

fn main() {
    let d = Direction::Up;
    move_step(d);
}</code></pre>
<p>2)变体携带数据</p>
<p>枚举变体可以携带数据，且不同变体携带的数据类型可以不同：</p>
<pre class="playground"><code class="language-rust editable edition2024">enum Message {
    Quit,
    Move { x: i32, y: i32 },  // 结构体风格
    Write(String),            // 元组风格
}
fn main() {
    let m1 = Message::Quit;
    let m2 = Message::Move { x: 3, y: 4 };
    let m3 = Message::Write("hi".to_string());
}
</code></pre>
<hr>
<h3 id="b-结构体-structs"><a class="header" href="#b-结构体-structs">B. 结构体 (Structs)</a></h3>
<p>结构体用于把多个字段组合成一个自定义类型，是“组织数据”的核心方式之一。</p>
<ol>
<li>具名字段结构体（最常用）</li>
</ol>
<pre class="playground"><code class="language-rust editable edition2024">struct User {
    name: String,
    age: u8,
    active: bool,
}
fn main() {
    let u = User {
        name: "Alice".to_string(),
        age: 18,
        active: true,
    };
    //访问字段用点号：
    println!("{:?}", u.name);
}</code></pre>
<p>2)结构体与所有权的直观规则</p>
<p>字段类型如果是 String、Vec<t> 等“拥有型”，把结构体赋值给新变量时默认会发生移动（move）。
想继续使用旧值通常需要借用（&amp;User）或让字段可复制（如 u32）或显式 clone()。</t></p>
<pre class="playground"><code class="language-rust editable edition2024">struct User {
    name: String,
    age: u8,
    active: bool,
}
fn main() {
    let u1 = User { name: "A".to_string(), age: 1, active: true };
    let u2 = u1;          // u1 被 move
    // println!("{}", u1.age); // 不能用
    println!("{}", u2.age);
}</code></pre>
<hr>
<h3 id="c-指针类型与所有权相关形态"><a class="header" href="#c-指针类型与所有权相关形态">C. 指针类型与所有权相关形态</a></h3>
<ul>
<li>
<p><strong>引用</strong>：<code>&amp;T</code>（不可变）与 <code>&amp;mut T</code>（可变）</p>
</li>
<li>
<p><strong>智能指针</strong>：</p>
<ul>
<li><code>Box&lt;T&gt;</code>：把数据放到堆上</li>
<li><code>Rc&lt;T&gt;</code>：引用计数（单线程）</li>
<li><code>Arc&lt;T&gt;</code>：原子引用计数（多线程）</li>
</ul>
</li>
</ul>
<hr>
<h3 id="d-optiont-与-resultt-e"><a class="header" href="#d-optiont-与-resultt-e">D. <code>Option&lt;T&gt;</code> 与 <code>Result&lt;T, E&gt;</code></a></h3>
<p>Rust 不提供 <code>null</code>，用 <code>Option&lt;T&gt;</code> 表示“可能不存在”。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x: Option&lt;i32&gt; = Some(1);
    let y: Option&lt;i32&gt; = None;
}</code></pre>
<p>错误处理通常用 <code>Result&lt;T, E&gt;</code>：</p>
<pre class="playground"><code class="language-rust editable edition2024">fn parse(s: &amp;str) -&gt; Result&lt;i32, std::num::ParseIntError&gt; {
    s.parse()
}
fn main() {
    let result = parse("123");
    println!("{:?}", result);
}</code></pre>
<hr>
<h3 id="e-never-类型-"><a class="header" href="#e-never-类型-">E. <code>Never</code> 类型 (<code>!</code>)</a></h3>
<p><code>!</code> 表示永远不会返回的类型，常见于 <code>panic!</code>、无限循环等。</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn forever() -&gt; ! {
    loop {}
}
<span class="boring">}</span></code></pre>
<hr>
<h2 id="类型转换注意"><a class="header" href="#类型转换注意">类型转换注意</a></h2>
<p>Rust <strong>不会</strong>进行隐式类型转换。不同整数类型之间的转换必须显式完成。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let a: u8 = 10;
    let b: u32 = a as u32;
}</code></pre>
<p><code>as</code> 转换在整数之间可能发生截断或符号变化。需要“转换失败就返回错误/None”时可用 <code>TryFrom/TryInto</code>。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    use std::convert::TryFrom;

    let x: i32 = 300;
    let y = u8::try_from(x); // Err(...)
}</code></pre>
<hr>
<h2 id="总结表格"><a class="header" href="#总结表格">总结表格</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>类型名</th><th>存储位置</th><th>长度是否可变</th><th>类型是否可混搭</th></tr>
</thead>
<tbody>
<tr><td><strong>Tuple</strong></td><td>栈</td><td>固定</td><td><strong>是</strong></td></tr>
<tr><td><strong>Array</strong></td><td>栈(常见)</td><td>固定</td><td>否</td></tr>
<tr><td><strong>Vec</strong></td><td>堆</td><td><strong>可变</strong></td><td>否</td></tr>
<tr><td><strong>String</strong></td><td>堆</td><td><strong>可变</strong></td><td>否 (UTF-8)</td></tr>
<tr><td><strong>&amp;str</strong></td><td>栈(引用) -&gt; 指向任意区域</td><td>固定</td><td>否</td></tr>
</tbody>
</table>
</div>
<p>接下来可以顺着类型的使用场景继续：一条路线是深入结构体与枚举的表达能力；另一条路线是把这些类型放进函数参数与返回值中，理解所有权与借用如何影响数据传递。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="所有权和借用"><a class="header" href="#所有权和借用">所有权和借用</a></h1>
<p>所有权（Ownership）是 Rust 最为独特且核心的特性。它让 Rust 能够脱离垃圾回收（GC）机制，在编译期即确保内存安全。</p>
<hr>
<h2 id="一-内存管理的三大流派"><a class="header" href="#一-内存管理的三大流派">一、 内存管理的三大流派</a></h2>
<p>在计算机科学中，管理内存通常有三种方式：</p>
<ol>
<li><strong>垃圾回收 (GC)</strong> ：如 Java、Go、Python。程序运行时自动寻找不再使用的内存。优点是开发快，缺点是运行时开销大，可能出现“停顿”。</li>
<li><strong>手动管理</strong> ：如 C/C++。程序员手动调用 <code>malloc/free</code>。优点是极致性能，缺点是极其容易出现 <strong>悬空指针</strong> 、<strong>双重释放</strong>或 <strong>内存泄漏</strong> 。</li>
<li><strong>所有权系统</strong> ：Rust 的路径。通过编译器在编译时根据一套规则检查内存管理。 <strong>零运行时开销</strong> 。</li>
</ol>
<h3 id="预备知识栈-stack-与-堆-heap"><a class="header" href="#预备知识栈-stack-与-堆-heap">预备知识：栈 (Stack) 与 堆 (Heap)</a></h3>
<h4 id="栈"><a class="header" href="#栈">栈</a></h4>
<p>栈按照顺序存储值并以相反顺序取出值，这也被称作 <strong>后进先出</strong> 。想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，再从顶部拿走。不能从中间也不能从底部增加或拿走盘子！</p>
<p>增加数据叫做 <strong>进栈</strong> ，移出数据则叫做 <strong>出栈</strong> 。</p>
<p>因为上述的实现方式，栈中的所有数据都必须占用已知且固定大小的内存空间，假设数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据。</p>
<h4 id="堆"><a class="header" href="#堆">堆</a></h4>
<p>与栈不同，对于大小未知或者可能变化的数据，我们需要将它存储在堆上。</p>
<p>当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 <strong>指针</strong> ，该过程被称为 <strong>在堆上分配内存</strong> ，有时简称为 “分配”(allocating)。</p>
<p>接着，该指针会被推入<strong>栈</strong>中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的 <strong>指针</strong> ，来获取数据在堆上的实际内存位置，进而访问该数据。</p>
<p>由上可知，堆是一种缺乏组织的数据结构。想象一下去餐馆就座吃饭：进入餐馆，告知服务员有几个人，然后服务员找到一个够大的空桌子（堆上分配的内存空间）并领你们过去。如果有人来迟了，他们也可以通过桌号（栈上的指针）来找到你们坐在哪。</p>
<h4 id="性能区别"><a class="header" href="#性能区别">性能区别</a></h4>
<p>在栈上分配内存比在堆上分配内存要快，因为入栈时操作系统无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。 因此，处理器在栈上分配数据会比在堆上分配数据更加高效。</p>
<h4 id="所有权与堆栈"><a class="header" href="#所有权与堆栈">所有权与堆栈</a></h4>
<p>当你的代码调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。</p>
<p>因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收。这就是 Rust 所有权系统为我们提供的强大保障。</p>
<p>对于其他很多编程语言，你确实无需理解堆栈的原理，但是 <strong>在 Rust 中，明白堆栈的原理，对于我们理解所有权的工作原理会有很大的帮助</strong> 。</p>
<hr>
<h2 id="二-所有权"><a class="header" href="#二-所有权">二、 所有权</a></h2>
<ul>
<li><strong>什么是所有权？</strong> ：每个值都有一个“所有者”（owner），负责在值超出作用域时释放它。Rust 使用所有权来管理堆内存，而不依赖垃圾回收器。</li>
<li><strong>为什么重要？</strong> ：防止双重释放（double free）、使用后释放（use after free）和数据竞争。</li>
<li><strong>三条铁律构建</strong> ：</li>
</ul>
<h3 id="每一个值都有一个变量称为它的所有者"><a class="header" href="#每一个值都有一个变量称为它的所有者">每一个值都有一个变量，称为它的“所有者”</a></h3>
<p>在 Rust 中，内存中的数据（值）不能孤立存在，必须绑定到一个变量上。</p>
<pre class="playground"><code class="language-rust edition">fn main() {
    // 这个 String 字符串值在堆上创建
    // 变量 s 成了这个字符串的“所有者”
    let s = String::from("hello"); 

    println!("s 拥有这个值: {}", s);
} // 函数结束，s 超出作用域，值被丢弃</code></pre>
<h3 id="同一时间内一个值只能有一个所有者"><a class="header" href="#同一时间内一个值只能有一个所有者">同一时间内，一个值只能有一个所有者</a></h3>
<p>这是 Rust 安全性的核心。如果一个堆上的值有两个所有者，就会发生“二次释放”内存错误。因此，Rust 强制执行所有权移动（Move）。</p>
<pre class="playground"><code class="language-rust edition">fn main() {
    let s1 = String::from("hello");
    
    // 所有权从 s1 转移到了 s2
    // 此时内存中仍然只有一个 "hello"，但所有者变成了 s2
    let s2 = s1; 

    // println!("{}", s1); 
    // ❌ 编译报错！s1 不再拥有该值，它已经“失效”了。
    
    println!("现在所有权在 s2 手里: {}", s2); 
}</code></pre>
<h3 id="当所有者超出作用域时该值将被丢弃drop"><a class="header" href="#当所有者超出作用域时该值将被丢弃drop">当所有者超出作用域时，该值将被丢弃（<code>drop</code>）</a></h3>
<p>Rust 自动管理内存的秘诀就在这里：通过大括号 {} 定义作用域，一旦走出大括号，变量就会被销毁，内存立即回收。</p>
<pre class="playground"><code class="language-rust edition">fn main() {
    {
        // s 从这里开始有效
        let s = String::from("hello"); 
        println!("作用域内: {}", s);
    } 
    // 💡 执行到这里，作用域结束。
    // Rust 自动调用 `drop` 函数，释放 s 占用的堆内存。

    // println!("{}", s); 
    // ❌ 编译报错！s 已经不在这里了，内存已经还给系统了。
}</code></pre>
<hr>
<h2 id="三-变量交互移动克隆与复制"><a class="header" href="#三-变量交互移动克隆与复制">三、 变量交互：移动、克隆与复制</a></h2>
<h3 id="1-移动-move"><a class="header" href="#1-移动-move">1. 移动 (Move)</a></h3>
<p>对于存储在堆上的复杂类型（如 <code>String</code>），赋值操作默认是“移动”。为了防止 <strong>双重释放</strong> ，Rust 会使原变量失效。</p>
<pre class="playground"><code class="language-rust edition">fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // 所有权移动到了 s2，s1 此时已失效

    // println!("{s1}"); // ❌ 编译错误：使用了已移动的值
    println!("{s2}");    // ✅ 有效
}</code></pre>
<h3 id="2-克隆-clone--深拷贝"><a class="header" href="#2-克隆-clone--深拷贝">2. 克隆 (Clone) —— 深拷贝</a></h3>
<p>如果你确实需要复制堆上的数据，必须显式调用 <code>clone</code>。</p>
<pre class="playground"><code class="language-rust edition">fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone(); // 在堆上产生了一份完整副本

    println!("s1 = {s1}, s2 = {s2}"); // ✅ 两者均有效
}</code></pre>
<h3 id="3-复制-copy--栈数据拷贝"><a class="header" href="#3-复制-copy--栈数据拷贝">3. 复制 (Copy) —— 栈数据拷贝</a></h3>
<p>对于简单、固定大小且完全存储在栈上的类型，Rust 会执行自动拷贝，而不会使原变量失效。常见的 <code>Copy</code> 类型包括：所有的整数、浮点数、布尔值、字符，以及只包含这些类型的元组。</p>
<pre class="playground"><code class="language-rust edition">fn main() {
    let x = 5;
    let y = x; // 栈数据直接拷贝，不涉及所有权转移
    println!("x = {x}, y = {y}"); // ✅ 两者均有效
}</code></pre>
<hr>
<h2 id="四-引用与借用-references--borrowing"><a class="header" href="#四-引用与借用-references--borrowing">四、 引用与借用 (References &amp; Borrowing)</a></h2>
<p>如果你不想转移所有权，但又想使用数据，就需要“借用”。引用（<code>&amp;</code>）就像是现实中的借书：你可以看书，但书不属于你，看完得还。</p>
<h3 id="1-不可变借用-t"><a class="header" href="#1-不可变借用-t">1. 不可变借用 (<code>&amp;T</code>)</a></h3>
<p>你可以同时拥有多个不可变引用，因为“只读”不会引起数据竞争。</p>
<pre class="playground"><code class="language-rust edition">fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
} // s 离开作用域，但因为它只是引用，所以不会发生 drop

fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&amp;s1); // 传入引用
    println!("'{s1}' 的长度是 {len}"); // ✅ s1 依然有效
}</code></pre>
<h3 id="2-可变借用-mut-t"><a class="header" href="#2-可变借用-mut-t">2. 可变借用 (<code>&amp;mut T</code>)</a></h3>
<p>如果你需要修改借用的数据，必须使用可变引用。但它有极强的限制：<strong>在同一作用域内，特定数据只能有一个可变引用。</strong></p>
<pre class="playground"><code class="language-rust edition">fn change(some_string: &amp;mut String) {
    some_string.push_str(", world");
}

fn main() {
    let mut s = String::from("hello");
    change(&amp;mut s);
    println!("{s}");
}</code></pre>
<h3 id="3-借用规则总结"><a class="header" href="#3-借用规则总结">3. 借用规则总结</a></h3>
<p>为了彻底消除 <strong>数据竞争</strong> ，Rust 强制执行以下规则：</p>
<ul>
<li><strong>在任何给定时间，你要么只能有一个可变引用，要么可以有任意数量的不可变引用。</strong></li>
<li><strong>引用必须始终有效（防止悬垂引用）。</strong></li>
</ul>
<hr>
<h2 id="五-nll更智能的借用检查"><a class="header" href="#五-nll更智能的借用检查">五、 NLL：更智能的借用检查</a></h2>
<p>在旧版 Rust 中，引用的作用域持续到大括号结束。现代 Rust 使用了  <strong>NLL (Non-Lexical Lifetimes)</strong> ，引用的作用域在<strong>最后一次使用</strong>处结束。这解决了许多“本该通过但没通过”的编译问题。</p>
<pre class="playground"><code class="language-rust edition">fn main() {
    let mut s = String::from("hello");

    let r1 = &amp;s; 
    let r2 = &amp;s;
    println!("{r1} and {r2}"); 
    // r1 和 r2 在此处之后不再使用，其作用域结束

    let r3 = &amp;mut s; // ✅ 允许，因为之前的不可变借用已失效
    println!("{r3}");
}</code></pre>
<hr>
<h2 id="六-悬垂引用-dangling-references"><a class="header" href="#六-悬垂引用-dangling-references">六、 悬垂引用 (Dangling References)</a></h2>
<p>Rust 会在编译期阻止你返回局部变量的引用，因为局部变量在函数结束时会被释放。</p>
<pre class="playground"><code class="language-rust edition">// ❌ 无法通过编译
// fn dangle() -&gt; &amp;String {
//     let s = String::from("hello");
//     &amp;s // 返回了对局部变量 s 的引用
// } 

// ✅ 正确做法：直接返回 String (移动所有权)
fn no_dangle() -&gt; String {
    let s = String::from("hello");
    s 
}

fn main() {
    let s = no_dangle();
}</code></pre>
<hr>
<h2 id="七-自动释放drop-与-raii"><a class="header" href="#七-自动释放drop-与-raii">七、 自动释放：Drop 与 RAII</a></h2>
<p>Rust 通过 <code>Drop</code> trait 实现  <strong>RAII (资源获取即初始化)</strong> 。当变量超出作用域时，Rust 自动调用 <code>drop</code> 方法释放堆内存。</p>
<pre class="playground"><code class="language-rust edition">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!("正在清理数据: `{}`", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer { data: String::from("my stuff") };
    let d = CustomSmartPointer { data: String::from("other stuff") };
    println!("CustomSmartPointers 已创建。");
} // 此处 d 先被 drop，然后 c 被 drop</code></pre>
<hr>
<h3 id="如何写出符合所有权的代码"><a class="header" href="#如何写出符合所有权的代码">如何写出符合所有权的代码？</a></h3>
<ol>
<li><strong>优先借用</strong> ：除非你确实需要获取数据的所有权（例如要把数据存入结构体中），否则优先使用引用 <code>&amp;T</code>。</li>
<li><strong>减少 Clone</strong> ：如果发现代码里到处是 <code>.clone()</code>，通常说明所有权设计有误。</li>
<li><strong>利用作用域</strong> ：可以通过手动添加 <code>{ }</code> 来缩短变量或引用的生命周期，从而解决借用冲突。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="语句与表达式"><a class="header" href="#语句与表达式">语句与表达式</a></h1>
<p>在 Rust 的设计哲学中，<strong>一切皆表达式</strong>是一个核心概念。理解**语句（Statements）<strong>与</strong>表达式（Expressions）**的区别，是掌握 Rust 函数返回值、控制流赋值以及函数式编程风格的关键。</p>
<hr>
<h2 id="一基本定义"><a class="header" href="#一基本定义">一、基本定义</a></h2>
<h3 id="1-语句-statements"><a class="header" href="#1-语句-statements">1. 语句 (Statements)</a></h3>
<p>语句是<strong>执行某种操作但不返回值</strong>的指令。</p>
<ul>
<li>在 Rust 中，最常见的语句是变量声明 <code>let x = 5;</code>。</li>
<li>语句通常以分号 <code>;</code> 结尾。</li>
<li><strong>注意</strong> ：因为语句不返回值，所以你不能把 <code>let</code> 语句赋值给另一个变量（例如 <code>let x = (let y = 5);</code> 会报错）。</li>
</ul>
<h3 id="2-表达式-expressions"><a class="header" href="#2-表达式-expressions">2. 表达式 (Expressions)</a></h3>
<p>表达式会计算并产生一个 <strong>值</strong> 。</p>
<ul>
<li>数学运算（如 <code>5 + 6</code>）、函数调用、宏调用都是表达式。</li>
<li>甚至大括号包裹的代码块 <code>{}</code> 也是表达式。</li>
<li><strong>核心规则</strong> ：表达式的结尾 <strong>没有分号</strong> 。如果你在表达式末尾加上分号，它就会变成一条语句，返回值会变成单元类型 <code>()</code>。</li>
</ul>
<hr>
<h2 id="二块表达式-block-expressions"><a class="header" href="#二块表达式-block-expressions">二、块表达式 (Block Expressions)</a></h2>
<p>在 Rust 中，我们可以使用 <code>{}</code> 创建一个作用域，这个作用域本身就是一个表达式，它的值是其中<strong>最后一行表达式</strong>的值。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let y = {
        let x = 3;
        x + 1  // 注意：这里没有分号！
    };

    println!("y 的值是: {y}"); // 输出 4
}</code></pre>
<blockquote>
<p>深度解析：</p>
<p>如果你在 x + 1 后面加了分号，变成 x + 1;，那么这个块就不再返回 4，而是返回 ()（unit 类型），编译器会因此报错（如果 y 预期是整数类型的话）。</p>
</blockquote>
<hr>
<h2 id="三函数中的应用隐式返回"><a class="header" href="#三函数中的应用隐式返回">三、函数中的应用：隐式返回</a></h2>
<p>Rust 函数不需要显式写 <code>return</code> 关键字来返回值。只要函数体的最后一行是一个 <strong>表达式</strong> （没有分号），该表达式的值就会自动作为函数的返回值。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn add_one(x: i32) -&gt; i32 {
    x + 1 // 这是一个表达式，隐式返回其结果
}

fn main() {
    let result = add_one(10);
    println!("结果是: {result}");
}</code></pre>
<p><strong>显式 return 与隐式返回的区别：</strong></p>
<ul>
<li><strong>隐式返回</strong> （不带 <code>return</code> 和分号）：Rust 推荐的标准写法，代码更简洁。</li>
<li><strong>显式 return</strong> ：通常用于函数中途提前退出（提前返回）。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn check_number(n: i32) -&gt; String {
    if n &lt; 0 {
        return String::from("错误：负数"); // 提前退出
    }
  
    String::from("正常") // 隐式返回
}
fn main() {
    let result = check_number(-10);
    println!("检查结果: {result}");
}</code></pre>
<hr>
<h2 id="四常见陷阱分号的影响"><a class="header" href="#四常见陷阱分号的影响">四、常见陷阱：分号的影响</a></h2>
<p>分号在 Rust 中不仅仅是结束符，它是 <strong>类型的转换器</strong> 。它将一个“有值”的表达式转换成一个“无值”的语句。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>示例</strong></th><th><strong>类别</strong></th><th><strong>结果/值</strong></th></tr>
</thead>
<tbody>
<tr><td><code>5 + 6</code></td><td>表达式</td><td><code>11</code></td></tr>
<tr><td><code>5 + 6;</code></td><td>语句</td><td><code>()</code>(Unit)</td></tr>
<tr><td><code>let x = 5;</code></td><td>语句</td><td>无值（报错不能被赋值）</td></tr>
<tr><td><code>if true { 1 } else { 0 }</code></td><td>表达式</td><td><code>1</code></td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="五综合示例在一个函数中观察"><a class="header" href="#五综合示例在一个函数中观察">五、综合示例：在一个函数中观察</a></h2>
<p>下面的代码展示了如何在实际逻辑中混合使用语句和表达式：</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 5;

    // 一个复杂的赋值表达式
    let result = if x &gt; 0 {
        let temp = x * 2; // 语句
        temp + 10         // 表达式：整个 if 块的值变为 20
    } else {
        0                 // 表达式
    };

    println!("最终计算结果: {result}");

    // 调用一个只有语句的函数
    print_unit();
}

// 该函数没有返回值，或者说隐式返回 ()
fn print_unit() {
    println!("我执行了一些操作，但我返回的是单元类型 ()");
    // 这里其实隐藏了一个没有分号的 ()
}</code></pre>
<hr>
<h3 id="总结对比"><a class="header" href="#总结对比">总结对比</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>特性</strong></th><th><strong>语句 (Statements)</strong></th><th><strong>表达式 (Expressions)</strong></th></tr>
</thead>
<tbody>
<tr><td><strong>是否有分号</strong></td><td><strong>是</strong> （通常以 <code>;</code>结尾）</td><td><strong>否</strong> （末尾无 <code>;</code>）</td></tr>
<tr><td><strong>是否有返回值</strong></td><td><strong>否</strong> （返回 <code>()</code>）</td><td><strong>是</strong></td></tr>
<tr><td><strong>典型例子</strong></td><td><code>let x = 5;</code></td><td><code>x + 5</code>/<code>my_func()</code></td></tr>
<tr><td><strong>函数末尾</strong></td><td>不会作为返回值</td><td><strong>会自动作为返回值</strong></td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="条件语句"><a class="header" href="#条件语句">条件语句</a></h1>
<p>在 Rust 中，控制流和模式匹配不仅仅是逻辑的分叉口，它们更是安全性的守护者。Rust 编译器通过严格的类型检查和“穷尽性检查”，确保你在处理各种逻辑情况时不会留下漏洞。</p>
<p>以下是整理的 Rust 控制流、循环流与 <code>match</code> 表达式的详细指南。</p>
<hr>
<h2 id="一控制流conditional-control-flow"><a class="header" href="#一控制流conditional-control-flow">一、控制流（Conditional Control Flow）</a></h2>
<p>控制流是程序根据特定条件执行不同代码的能力。Rust 的 <code>if</code> 分支结构非常严谨。</p>
<h3 id="1-if--else-if--else"><a class="header" href="#1-if--else-if--else">1. <code>if / else if / else</code></a></h3>
<p>Rust 要求条件表达式必须是严格的 <code>bool</code> 类型。这意味着你不能像在 C 或 JavaScript 中那样使用数字（如 <code>if (1)</code>）来代表逻辑真。这种设计避免了因隐式类型转换导致的逻辑错误。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 10;

    if x &gt; 0 {
        println!("positive");
    } else if x == 0 {
        println!("zero");
    } else {
        println!("negative");
    }
}</code></pre>
<h3 id="2-if-是表达式可以返回值"><a class="header" href="#2-if-是表达式可以返回值">2. <code>if</code> 是表达式：可以返回值</a></h3>
<p>在 Rust 中，if 是一个表达式而不是语句。这意味着它可以产生一个值，并将其直接赋值给变量。</p>
<p><strong>注意：所有分支返回的数据类型必须完全一致，且分支末尾不要写分号，否则该分支会返回单元类型 ()。</strong></p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 7;
    // if 表达式赋值
    let y = if x % 2 == 0 { 100 } else { 200 };
    // let y = if x % 2 == 0 { 100 } else { 200; };
    println!("y 的值是: {y}"); // 输出 200
}</code></pre>
<h3 id="3-if-let只关心某一种模式"><a class="header" href="#3-if-let只关心某一种模式">3. <code>if let</code>：只关心某一种模式</a></h3>
<p>当你只想处理某一种特定的模式（例如 <code>Option</code> 中的 <code>Some</code>），而对其他情况（如 <code>None</code>）不感兴趣时，<code>if let</code> 是比 <code>match</code> 更简洁的选择。它减少了样板代码的编写。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let v: Option&lt;i32&gt; = Some(10);

    // 只解构 Some，忽略 None
    if let Some(n) = v {
        println!("解构成功，n = {n}");
    } else {
        println!("这里是 None 的情况");
    }
}</code></pre>
<h3 id="4-let-else模式不匹配就提前退出"><a class="header" href="#4-let-else模式不匹配就提前退出">4. <code>let else</code>：模式不匹配就提前退出</a></h3>
<p>这是 Rust 1.65 引入的新语法，非常适合编写“守护语句（Guard Statement）”。如果在解构时失败，必须在 <code>else</code> 块中通过 <code>return</code>、<code>break</code> 或 <code>panic!</code> 强制退出当前作用域。这使得后续代码可以放心地使用解构出来的变量。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn parse_first(v: Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    // 如果无法获取第一个元素，直接返回 None
    let Some(first) = v.get(0) else {
        return None; 
    };
    // 此时 first 已经成功绑定，且作用域在外面
    Some(*first)
}

fn main() {
    let numbers = vec![1, 2, 3];
    if let Some(val) = parse_first(numbers) {
        println!("第一个值是: {val}");
    }
}</code></pre>
<hr>
<h2 id="二循环流looping-control-flow"><a class="header" href="#二循环流looping-control-flow">二、循环流（Looping Control Flow）</a></h2>
<p>Rust 提供了三种循环原语，它们在底层性能上是一致的，但在语义表达上各有侧重。</p>
<h3 id="1-loop无限循环--break-返回值"><a class="header" href="#1-loop无限循环--break-返回值">1. <code>loop</code>：无限循环 + <code>break</code> 返回值</a></h3>
<p><code>loop</code> 常用于需要反复执行直到满足某个条件（如轮询任务或重试逻辑）的场景。由于 <code>loop</code> 保证一定会运行（直到被 break），它也可以作为表达式返回一个值。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut n = 0;

    let result = loop {
        n += 1;
        if n == 5 {
            break n * 2; // 带值跳出循环
        }
    };

    println!("结果是: {result}"); // 10
}</code></pre>
<h3 id="2-while条件循环"><a class="header" href="#2-while条件循环">2. <code>while</code>：条件循环</a></h3>
<p>这是最传统的循环方式，每次迭代开始前都会检查条件。适合处理那些依赖外部状态变化的逻辑。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut n = 3;
    while n &gt; 0 {
        println!("{n}...");
        n -= 1;
    }
    println!("发射！");
}</code></pre>
<h3 id="3-for遍历迭代器最常用"><a class="header" href="#3-for遍历迭代器最常用">3. <code>for</code>：遍历迭代器（最常用）</a></h3>
<p><code>for</code> 循环通过迭代器工作，是 Rust 中最安全的选择，因为它不会出现索引越界（Out of Bounds）的问题。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>使用方法</th><th>等价使用方式</th><th>所有权</th></tr>
</thead>
<tbody>
<tr><td><code>for item in collection</code></td><td><code>for item in IntoIterator::into_iter(collection)</code></td><td>转移所有权</td></tr>
<tr><td><code>for item in &amp;collection</code></td><td><code>for item in collection.iter()</code></td><td>不可变借用</td></tr>
<tr><td><code>for item in &amp;mut collection</code></td><td><code>for item in collection.iter_mut()</code></td><td>可变借用</td></tr>
</tbody>
</table>
</div>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    // 1. 范围遍历
    for i in 0..3 { println!("范围 A: {i}"); }    // 0, 1, 2
    for i in 0..=3 { println!("范围 B: {i}"); }   // 0, 1, 2, 3

    // 2. 遍历集合（借用与移动）
    let v = vec![10, 20, 30];
    for x in &amp;v { println!("借用元素: {x}"); }    // v 依然可用

    // 3. 可变借用遍历
    let mut nums = vec![1, 2, 3];
    for x in &amp;mut nums {
        *x *= 10; // 修改原始数据
    }

    // 4. 带索引遍历
    for (i, val) in nums.iter().enumerate() {
        println!("索引 {i} 的值是 {val}");
    }
}</code></pre>
<h3 id="4-循环控制与标签"><a class="header" href="#4-循环控制与标签">4. 循环控制与标签</a></h3>
<ul>
<li><code>continue</code>：结束当前迭代，立即开始下一次。</li>
<li><code>break</code>：立即退出当前循环。</li>
<li><strong>循环标签</strong> ：在处理多层嵌套循环时，你可以给循环起名字（以单引号开头），以便在内层直接退出外层, <strong>影响可读性</strong>。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    'outer: for i in 0..10 {
        'inner: for j in 0..10 {
            if i + j == 5 {
                println!("找到目标：i={}, j={}", i, j);
                break 'outer; // 跳出最外层循环
            }
        }
    }
}</code></pre>
<hr>
<h2 id="三match-表达式pattern-matching"><a class="header" href="#三match-表达式pattern-matching">三、<code>match</code> 表达式（Pattern Matching）</a></h2>
<p><code>match</code> 是 Rust 的“核心杀手锏”，它非常类似于多分支的 <code>switch</code>，但功能要强大得多。它强制要求 <strong>穷尽性检查</strong> ，即你必须处理所有可能的情况。</p>
<h3 id="1-基本用法与模式"><a class="header" href="#1-基本用法与模式">1. 基本用法与模式</a></h3>
<p><code>match</code> 的每个分支被称为一个“臂（Arm）”。<code>_</code> 是通配符，用于捕获所有未明确列出的情况。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let n = 3;
    match n {
        1 =&gt; println!("一"),
        2 =&gt; println!("二"),
        3 =&gt; println!("三"),
        _ =&gt; println!("其他数字"), // 必须有这一行，除非 n 的所有可能已被覆盖
    }
}</code></pre>
<h3 id="2-范围与多重匹配"><a class="header" href="#2-范围与多重匹配">2. 范围与多重匹配</a></h3>
<p>你可以使用 <code>|</code> 匹配多个值，或使用 <code>..=</code> 匹配一个闭区间。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let score = 85;
    match score {
        0..=59 =&gt; println!("不及格"),
        60..=80 =&gt; println!("合格"),
        81..=100 =&gt; println!("优秀"),
        _ =&gt; println!("无效分数"),
    }

    let day = 6;
    match day {
        1 | 2 | 3 | 4 | 5 =&gt; println!("工作日"),
        6 | 7 =&gt; println!("周末"),
        _ =&gt; println!("火星日?"),
    }
}</code></pre>
<h3 id="3-解构复合类型元组结构体枚举"><a class="header" href="#3-解构复合类型元组结构体枚举">3. 解构复合类型（元组/结构体/枚举）</a></h3>
<p><code>match</code> 最强大的地方在于它可以“拆解”数据结构。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct Point { x: i32, y: i32 }
enum Message { Quit, Write(String) }

fn main() {
    // 1. 解构元组
    let pair = (0, -2);
    match pair {
        (0, y) =&gt; println!("在 Y 轴上: {y}"),
        (x, 0) =&gt; println!("在 X 轴上: {x}"),
        _ =&gt; println!("在象限内"),
    }

    // 2. 解构结构体
    let p = Point { x: 10, y: 0 };
    match p {
        Point { x, y: 0 } =&gt; println!("X 轴上的点，x = {x}"),
        Point { x, y } =&gt; println!("普通点 ({x}, {y})"),
    }

    // 3. 解构枚举
    let msg = Message::Write(String::from("Hello"));
    match msg {
        Message::Quit =&gt; println!("退出"),
        Message::Write(s) =&gt; println!("消息内容: {s}"),
    }
}</code></pre>
<h3 id="4-进阶匹配守卫与--绑定"><a class="header" href="#4-进阶匹配守卫与--绑定">4. 进阶：匹配守卫与 <code>@</code> 绑定</a></h3>
<ul>
<li><strong>匹配守卫 (Match Guard)</strong> ：在模式匹配的基础上增加 <code>if</code> 条件，用于更细粒度的过滤。</li>
<li><strong><code>@</code> 绑定</strong> ：允许你在匹配一个值的同时，将其绑定到一个变量上，方便后续使用。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    // 匹配守卫
    let num = Some(10);
    match num {
        Some(x) if x &gt; 5 =&gt; println!("大于 5 的数字: {x}"),
        Some(x) =&gt; println!("普通数字: {x}"),
        None =&gt; (),
    }

    // @ 绑定
    let age = 7;
    match age {
        v @ 1..=12 =&gt; println!("小孩，年龄是: {v}"),
        v @ 13..=19 =&gt; println!("青少年，年龄是: {v}"),
        _ =&gt; println!("成年人"),
    }
}</code></pre>
<h3 id="5-核心应用option-和-result"><a class="header" href="#5-核心应用option-和-result">5. 核心应用：<code>Option</code> 和 <code>Result</code></a></h3>
<p>这是 <code>match</code> 在 Rust 中最高频的出现场景，用于安全地处理可能为空或可能出错的值。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let res: Result&lt;i32, &amp;str&gt; = Ok(200);
    match res {
        Ok(code) =&gt; println!("请求成功，状态码: {code}"),
        Err(msg) =&gt; println!("请求失败: {msg}"),
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="函数与闭包"><a class="header" href="#函数与闭包">函数与闭包</a></h1>
<h2 id="一-函数-functions"><a class="header" href="#一-函数-functions">一、 函数 (Functions)</a></h2>
<p>函数是 Rust 代码的静态骨架。它们必须在编译时拥有明确的签名。</p>
<h3 id="1-基础语法与显式返回"><a class="header" href="#1-基础语法与显式返回">1. 基础语法与显式返回</a></h3>
<p>Rust 的函数参数必须标注类型，返回类型使用 <code>-&gt;</code> 标注。</p>
<pre class="playground"><code class="language-rust editable edition2024">// 逻辑概括：参数必须显式注明类型，最后一行表达式作为返回值
fn calculate_score(points: i32, multiplier: i32) -&gt; i32 {
    if points &lt; 0 {
        return 0; // 使用 return 提前退出
    }
    points * multiplier // 隐式返回（无分号）
}
fn main() {
    let score = calculate_score(10, 3);
    println!("最终得分: {score}");
}</code></pre>
<h3 id="2-函数指针-fn-类型"><a class="header" href="#2-函数指针-fn-类型">2. 函数指针 (<code>fn</code> 类型)</a></h3>
<p>函数本身可以作为参数传递，也可以存储在变量中。它的类型是小写的 <code>fn</code>。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn add_one(x: i32) -&gt; i32 { x + 1 }

fn do_math(f: fn(i32) -&gt; i32, value: i32) -&gt; i32 {
    f(value)
}

fn main() {
    let result = do_math(add_one, 5);
    println!("函数指针调用结果: {result}"); // 6
}</code></pre>
<hr>
<h2 id="二-闭包-closures"><a class="header" href="#二-闭包-closures">二、 闭包 (Closures)</a></h2>
<p><code>Rust</code> 中的闭包（<code>closures</code>）是一种匿名函数，可以捕获其环境中的变量。闭包类似于其他语言中的 <code>lambda</code> 表达式，但 <code>Rust</code> 的闭包系统与所有权和借用紧密集成，确保内存安全。闭包可以作为函数参数、返回值，或存储在变量中，常用于迭代器、线程和回调。<code>Rust</code> 闭包实现了<code> Fn trait</code> 家族（<code>Fn、FnMut、FnOnce</code>），根据捕获方式决定其行为。最核心的特性是 <strong>捕获环境</strong> 。它们通常比函数更简洁，且支持类型推导。</p>
<h3 id="1-语法与自动推导"><a class="header" href="#1-语法与自动推导">1. 语法与自动推导</a></h3>
<p>闭包不强制写类型，编译器会根据第一次调用的上下文锁定类型。语法：<code>|params| expression</code> 或 <code>{ body }</code>。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    // 闭包标准语法
    let closure_annotated = |x: i32| -&gt; i32 { x + 1 };
  
    // 自动推导简写
    let closure_inferred = |x| x + 1;

    println!("{}", closure_annotated(1));
    println!("{}", closure_inferred(1));
}</code></pre>
<h3 id="2-捕获方式不可变可变移动"><a class="header" href="#2-捕获方式不可变可变移动">2. 捕获方式：不可变、可变、移动</a></h3>
<p>闭包通过三种方式从作用域捕获变量：</p>
<ul>
<li><strong>不可变借用 (<code>&amp;T</code>)</strong> ：默认方式。</li>
<li><strong>可变借用 (<code>&amp;mut T</code>)</strong> ：当闭包内部修改变量时。</li>
<li><strong>移动所有权 (<code>T</code>)</strong> ：使用 <code>move</code> 关键字，常用于异步或多线程。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let x = 4;
    let equal_to_x = |z| z == x;  // 借用 x (&amp;x)
    println!("相等？{}", equal_to_x(4));  // 输出: 相等？true
    println!("x 仍有效: {}", x);  // x 未移动
    //可变借用
    let mut count = 0;
    let mut inc = || {
        count += 1; // 自动推导为 可变借用
        println!("当前计数: {count}");
    };
    inc();
    inc();
    // 强制移动所有权
    let text = String::from("hello");
    let print_text = move || println!("移动后的文本: {text}");
    print_text();
    // println!("{text}"); // ❌ 报错：text 已移动到闭包中
}</code></pre>
<hr>
<h2 id="三-闭包特征-fn-fnmut-fnonce"><a class="header" href="#三-闭包特征-fn-fnmut-fnonce">三、 闭包特征 (Fn, FnMut, FnOnce)</a></h2>
<p>当闭包作为参数传递时，我们需要使用这三个 Trait 来约束它：</p>
<ul>
<li><strong><code>FnOnce</code></strong> ：调用一次，消耗闭包（可能移动捕获）。</li>
<li><strong><code>FnMut</code></strong> ：可多次调用，可修改捕获。</li>
<li><strong><code>Fn</code></strong> ：可多次调用，只读捕获。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn run_once&lt;F&gt;(f: F) where F: FnOnce() {
    f();
}

fn main() {
    let s = String::from("once");
    let consume_s = || drop(s); // 该闭包消费了 s 的所有权
  
    run_once(consume_s);
    // run_once(consume_s); // ❌ 报错：闭包已被消费
}</code></pre>
<hr>
<h2 id="四-高级进阶函数与闭包作为返回值"><a class="header" href="#四-高级进阶函数与闭包作为返回值">四、 高级进阶：函数与闭包作为返回值</a></h2>
<p>这是 Rust 中最具灵活性的部分。由于闭包没有具体的名字，返回它们需要特殊的处理。</p>
<h3 id="1-返回普通函数指针-fn"><a class="header" href="#1-返回普通函数指针-fn">1. 返回普通函数指针 (<code>fn</code>)</a></h3>
<p>适用于逻辑固定、不捕获外部变量的情况。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn apply&lt;F&gt;(f: F, x: i32) -&gt; i32
where
    F: FnOnce(i32) -&gt; i32,  // bound FnOnce
{
    f(x)
}

fn main() {
    let double = |n| n * 2;
    println!("结果: {}", apply(double, 5));  // 输出: 结果: 10
}</code></pre>
<h3 id="2-返回闭包静态分发-impl-trait"><a class="header" href="#2-返回闭包静态分发-impl-trait">2. 返回闭包：静态分发 (<code>impl Trait</code>)</a></h3>
<p>这是返回闭包最常用的方式。它效率高（无堆分配），但要求所有分支返回<strong>同一种</strong>闭包。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn create_multiplier(factor: i32) -&gt; impl Fn(i32) -&gt; i32 {
    // 关键：必须使用 move，将 factor 移入闭包
    // 否则 factor 会在函数结束时释放，导致引用失效
    move |x| x * factor
}

fn main() {
    let double = create_multiplier(2);
    println!("3 的两倍是: {}", double(3));
}</code></pre>
<h3 id="3-返回闭包动态分发-boxdyn-trait"><a class="header" href="#3-返回闭包动态分发-boxdyn-trait">3. 返回闭包：动态分发 (<code>Box&lt;dyn Trait&gt;</code>)</a></h3>
<p>如果你需要根据逻辑返回不同的闭包（比如在 <code>if/else</code> 分支中返回不同的闭包代码块），必须使用 <code>Box</code>。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn get_closure(mode: bool) -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    if mode {
        Box::new(|x| x + 1)
    } else {
        Box::new(|x| x * 2)
    }
}

fn main() {
    let f = get_closure(false);
    println!("执行结果: {}", f(5)); // 10
}</code></pre>
<hr>
<h2 id="总结对比-1"><a class="header" href="#总结对比-1">总结对比</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>特性</strong></th><th><strong>普通函数 (fn)</strong></th><th><strong>impl Trait 闭包</strong></th><th><strong>Box<code>&lt;dyn Trait&gt;</code> 闭包</strong></th></tr>
</thead>
<tbody>
<tr><td><strong>捕获变量</strong></td><td>不支持</td><td>支持 (需用 <code>move</code>)</td><td>支持 (需用 <code>move</code>)</td></tr>
<tr><td><strong>返回类型</strong></td><td><code>fn(A) -&gt; B</code></td><td><code>impl Fn(A) -&gt; B</code></td><td><code>Box&lt;dyn Fn(A) -&gt; B&gt;</code></td></tr>
<tr><td><strong>内存位置</strong></td><td>代码段</td><td>栈</td><td>堆</td></tr>
<tr><td><strong>性能</strong></td><td>极高（静态）</td><td>高（静态）</td><td>略低（动态寻址）</td></tr>
<tr><td><strong>适用场景</strong></td><td>简单、纯粹的逻辑</td><td>性能敏感、单一返回路径</td><td>需要根据条件返回不同闭包</td></tr>
</tbody>
</table>
</div>
<hr>
<h3 id="-核心避坑指南"><a class="header" href="#-核心避坑指南">💡 核心避坑指南</a></h3>
<p>在返回闭包时，<strong>忘记写 <code>move</code></strong> 是新手最常见的错误。</p>
<blockquote>
<p><strong>记住</strong> ：闭包默认会尝试通过“引用”来捕获环境中的变量。但当函数结束时，这些变量会被销毁，所以闭包必须通过 <code>move</code> 把它们“打包带走”，否则你会得到一个“悬垂引用”的报错。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h1>
<p>Rust 的错误处理体系以其<strong>严谨性</strong>著称。它不使用传统的 <code>try-catch</code> 异常机制，而是通过类型系统将错误显式化，强制开发者在编译期就面对可能的失败。</p>
<hr>
<h2 id="一-不可恢复错误panic"><a class="header" href="#一-不可恢复错误panic">一、 不可恢复错误：<code>panic!</code></a></h2>
<p>当程序遇到无法恢复的错误时（如数组越界或断言失败），Rust 使用 panic! 宏来终止执行。这会 unwind 栈（清理资源）或直接 abort（不清理，适合嵌入式系统）。</p>
<h3 id="1-发生什么"><a class="header" href="#1-发生什么">1. 发生什么？</a></h3>
<ol>
<li>程序打印错误信息。</li>
<li><strong>展开（Unwinding）</strong> ：Rust 沿着栈往回走，清理每个函数的数据（释放所有权）。</li>
<li>程序退出。</li>
</ol>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    // 主动触发 panic
    // panic!("这里发生了不可预见的灾难！");

    let v = vec![1, 2, 3];
    v[99]; // ❌ 被动触发 panic：索引越界
}</code></pre>
<p>当你取到了一个不属于你的值，这在很多时候会导致程序上的逻辑 BUG！ 有编程经验的人都知道这种逻辑上的 BUG 是多么难被发现和修复！因此程序直接崩溃，然后告诉我们问题发生的位置，最后我们对此进行修复，这才是最合理的软件开发流程，而不是把问题藏着掖着：</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thread 'main' (12) panicked at src/main.rs:6:6:
index out of bounds: the len is 3 but the index is 99
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
<span class="boring">}</span></code></pre>
<p>好的，现在成功知道问题发生的位置，但是如果我们想知道该问题之前经过了哪些调用环节，该怎么办？那就按照提示使用 <code>RUST_BACKTRACE=1 cargo run</code> 或 <code>$env:RUST_BACKTRACE=1 ; cargo run</code> 来再一次运行程序</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:6:6
stack backtrace:
   0: rust_begin_unwind
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/std/src/panicking.rs:517:5
   1: core::panicking::panic_fmt
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:101:14
   2: core::panicking::panic_bounds_check
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:77:5
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:184:10
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:15:9
   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/alloc/src/vec/mod.rs:2465:9
   6: world_hello::main
             at ./src/main.rs:4:5
   7: core::ops::function::FnOnce::call_once
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/ops/function.rs:227:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
<span class="boring">}</span></code></pre>
<p>上面的代码就是一次栈展开（也称栈回溯），它包含了函数调用的顺序，当然按照逆序排列：最近调用的函数排在列表的最上方。因为咱们的 main 函数基本是最先调用的函数了，所以排在了倒数第二位，还有一个关注点，排在最顶部最后一个调用的函数是 rust_begin_unwind，该函数的目的就是进行栈展开，呈现这些列表信息给我们。</p>
<p>要获取到栈回溯信息，你还需要开启 debug 标志，该标志在使用 cargo run 或者 cargo build 时自动开启（这两个操作默认是 Debug 运行方式）。同时，栈展开信息在不同操作系统或者 Rust 版本上也有所不同。</p>
<h3 id="2-何时使用"><a class="header" href="#2-何时使用">2. 何时使用？</a></h3>
<ul>
<li><strong>示例代码或原型</strong> ：快速展示逻辑。</li>
<li><strong>测试代码</strong> ：断言失败。</li>
<li><strong>逻辑不可达</strong> ：你确信这段代码永远不会运行到，除非有严重的 Bug。</li>
</ul>
<hr>
<h2 id="二-可恢复错误option-与-result"><a class="header" href="#二-可恢复错误option-与-result">二、 可恢复错误：<code>Option</code> 与 <code>Result</code></a></h2>
<p>这是 Rust 错误处理的核心，通过两个枚举来包裹“可能不存在的值”或“可能失败的操作”。Rust 不使用异常，而是返回枚举类型：</p>
<ul>
<li><strong>Option</strong>：表示可能为空的值。<strong>Some(T) 或 None</strong>。</li>
<li><strong>Result&lt;T, E&gt;</strong>：表示成功或失败。<strong>Ok(T) 或 Err(E)</strong>。</li>
</ul>
<h3 id="1-optiont值可能不存在"><a class="header" href="#1-optiont值可能不存在">1. <code>Option&lt;T&gt;</code>：值可能不存在</a></h3>
<p>用于表示一个值要么有（<code>Some(T)</code>），要么没有（<code>None</code>）。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn find_index(target: i32, list: Vec&lt;i32&gt;) -&gt; Option&lt;usize&gt; {
    for (i, &amp;item) in list.iter().enumerate() {
        if item == target { return Some(i); }
    }
    None
}

fn main() {
    let list = vec![10, 20, 30];
    match find_index(20, list) {
        Some(index) =&gt; println!("找到索引: {index}"),
        None =&gt; println!("未找到"),
    }
}</code></pre>
<h3 id="2-resultt-e操作可能失败"><a class="header" href="#2-resultt-e操作可能失败">2. <code>Result&lt;T, E&gt;</code>：操作可能失败</a></h3>
<p>用于表示一个操作要么成功（<code>Ok(T)</code>），要么失败（<code>Err(E)</code>）。</p>
<pre class="playground"><code class="language-rust editable edition2024">use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let _file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!("打开文件失败: {:?}", error),
    };
}</code></pre>
<h3 id="模式匹配和-unwrap"><a class="header" href="#模式匹配和-unwrap">模式匹配和 unwrap</a></h3>
<ul>
<li><strong>match</strong>：最安全的方式。</li>
<li><strong>unwrap()</strong>：如果 Ok 返回值，否则 panic!（不推荐生产环境）。</li>
<li><strong>expect(“消息”)</strong>：类似 unwrap，但自定义 panic 消息。</li>
<li><strong>unwrap_or(default)</strong>：为 Option/Result 提供默认值。</li>
<li><strong>unwrap_or_else(closure)</strong>：懒惰计算默认值。</li>
</ul>
<hr>
<h2 id="三-常用组合器-combinators"><a class="header" href="#三-常用组合器-combinators">三、 常用组合器 (Combinators)</a></h2>
<p>组合器允许你以<strong>函数式</strong>的风格链式处理 <code>Option</code> 和 <code>Result</code>，避免层层嵌套的 <code>match</code>。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>组合器</strong></th><th><strong>作用描述</strong></th><th><strong>示例逻辑</strong></th></tr>
</thead>
<tbody>
<tr><td><strong><code>.map()</code></strong></td><td>仅对成功（<code>Some</code>/<code>Ok</code>）的值进行转换</td><td><code>Ok(2).map()</code></td></tr>
<tr><td><strong><code>.and_then()</code></strong></td><td>类似 <code>map</code>，但闭包也返回一个 <code>Result/Option</code>(平铺嵌套)</td><td>避免出现 <code>Some(Some(x))</code></td></tr>
<tr><td><strong><code>.unwrap_or()</code></strong></td><td>如果是失败/缺失，则返回一个默认值</td><td><code>None.unwrap_or(0)</code>-&gt;<code>0</code></td></tr>
<tr><td><strong><code>.unwrap_or_else()</code></strong></td><td>类似 <code>unwrap_or</code>，但默认值通过闭包计算（延迟求值）</td><td>适合计算默认值开销大的场景</td></tr>
<tr><td><strong><code>.map_err()</code></strong></td><td>仅对 <code>Err</code>进行转换（通常用于转换错误类型）</td><td>`Err(e).map_err(</td></tr>
</tbody>
</table>
</div>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    // --- 1. .map(): 只转换成功的值，忽略失败 ---
    let s = Some("5");
    let n = s.map(|val| val.parse::&lt;i32&gt;().unwrap_or(0)); 
    // n 现在是 Some(5)

    // --- 2. .and_then(): 展平嵌套（类似 flat_map） ---
    // 如果转换函数也返回 Option/Result，用 and_then 防止出现 Option&lt;Option&lt;T&gt;&gt;
    let get_val = |i: i32| if i &gt; 0 { Some(i * 2) } else { None };
    let result = Some(10).and_then(get_val); 
    // result 是 Some(20)，而不是 Some(Some(20))

    // --- 3. .unwrap_or() 与 .unwrap_or_else(): 兜底默认值 ---
    let x: Option&lt;i32&gt; = None;
    let val = x.unwrap_or(0); // 如果是 None，则返回 0
  
    // or_else 接受闭包，适合计算默认值开销较大的场景（延迟求值）
    let val_lazy = x.unwrap_or_else(|| {
        // 执行复杂的计算过程...
        100 
    });

    // --- 4. .map_err(): 只处理错误，不改动成功值 ---
    let res: Result&lt;i32, i32&gt; = Err(404);
    let updated_res = res.map_err(|e| format!("Error code: {}", e));
    // updated_res 是 Err("Error code: 404")

    println!("组合器处理结果: {:?}, {}, {:?}", n, val, updated_res);
}</code></pre>
<hr>
<h2 id="四--操作符错误传播的捷径"><a class="header" href="#四--操作符错误传播的捷径">四、 <code>?</code> 操作符：错误传播的捷径</a></h2>
<p><code>?</code> 操作符是 Rust 错误传播的语法糖。它可以极大地简化代码，让逻辑保持清晰。程序几乎不太可能只有 A-&gt;B 形式的函数调用，一个设计良好的程序，一个功能涉及十几层的函数调用都有可能。而错误处理也往往不是哪里调用出错，就在哪里处理，实际应用中，大概率会把错误层层上传然后交给调用链的上游函数进行处理，错误传播将极为常见</p>
<h3 id="1-工作原理"><a class="header" href="#1-工作原理">1. 工作原理</a></h3>
<p>当你在一个返回 <code>Result</code> 的表达式后面加 <code>?</code> 时：</p>
<ol>
<li>如果结果是 <code>Ok</code>，它会<strong>自动解包</strong>出里面的值，程序继续执行。</li>
<li>如果结果是 <code>Err</code>，它会立即 <strong>提前返回</strong> （Return）整个函数，并将错误传递给调用者。</li>
</ol>
<pre class="playground"><code class="language-rust editable edition2024">use std::fs::File;
use std::io::{self, Read};

fn read_username() -&gt; Result&lt;String, io::Error&gt; {
    // 如果 open 失败，直接返回 Err；如果成功，f 绑定为 File 对象
    let mut f = File::open("name.txt")?; 
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?; // 如果读取失败，直接返回 Err
    Ok(s)
}
fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let username = read_username()?;
    println!("用户名: {}", username);
    Ok(())
}</code></pre>
<ul>
<li>解释：? 等价于</li>
</ul>
<pre><code class="language-txt">let mut file = match File::open(filename) {
    Ok(f) =&gt; f,
    Err(e) =&gt; return Err(e),
};
</code></pre>
<ul>
<li>要求：函数必须返回 <code>Result/Option</code>。</li>
<li>链式使用：支持多个 ?，错误会向上传播。</li>
<li><code>From trait</code>：如果错误类型不同，? 会自动转换（如果实现了 From）。</li>
</ul>
<h3 id="2-使用限制"><a class="header" href="#2-使用限制">2. 使用限制</a></h3>
<ul>
<li><code>?</code> 只能在返回类型与 <code>?</code> 处理的类型<strong>相兼容</strong>的函数中使用（例如在返回 <code>Result</code> 的函数中处理 <code>Result</code>）。</li>
<li>在 <code>main</code> 函数中使用 <code>?</code> 需要将 <code>main</code> 的返回类型改为 <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>。</li>
</ul>
<hr>
<h2 id="五自定义错误类型"><a class="header" href="#五自定义错误类型">五、自定义错误类型</a></h2>
<p>对于复杂应用，定义自己的错误枚举，结合 <code>thiserror</code> 或 <code>anyhow</code> crate 更加方便。</p>
<h2 id="总结概括"><a class="header" href="#总结概括">总结概括</a></h2>
<ol>
<li><strong><code>panic!</code></strong> ：用于 <strong>程序 Bug</strong> 。当你无法预见错误或错误会导致程序状态不可靠时使用。</li>
<li><strong><code>Option</code></strong> ：用于 <strong>可能缺失</strong> 。不代表失败，只是“没有”。</li>
<li><strong><code>Result</code></strong> ：用于 <strong>可能失败</strong> 。明确区分成功数据和错误信息。</li>
<li><strong><code>?</code></strong> ：用于 <strong>传播错误</strong> 。让错误处理像写直线代码一样简单。</li>
<li><strong>组合器</strong> ：用于 <strong>优雅转换</strong> 。让数据在各种状态间流动而不需要嵌套判断。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="结构体"><a class="header" href="#结构体">结构体</a></h1>
<p>在 Rust 中，<strong>结构体Structs</strong>是构建复杂程序的基石。它允许你将相关联的数据组合在一起，创建出更有意义的自定义类型。相比于元组，结构体为每个数据片段命名，因此更加灵活且意图清晰。</p>
<hr>
<h2 id="一-结构体的三种类型"><a class="header" href="#一-结构体的三种类型">一、 结构体的三种类型</a></h2>
<p>Rust 支持三种不同风格的结构体，分别适用于不同的场景。</p>
<h3 id="1-具名结构体-classic-structs"><a class="header" href="#1-具名结构体-classic-structs">1. 具名结构体 (Classic Structs)</a></h3>
<p>最常用的类型，类似于其他语言中的类或对象，每个字段都有明确的名字。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    // 实例化结构体
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someuser123"),
        active: true,
        sign_in_count: 1,
    };

    println!("用户 {} 的邮箱是 {}", user1.username, user1.email);
}</code></pre>
<p><strong>关键点：</strong></p>
<ul>
<li>结构体通常拥有其数据，使用如 String 的拥有类型，以确保数据在结构体存在期间有效。</li>
<li>如果使用引用（如 &amp;str），需要指定生命周期（lifetime），以避免悬垂引用（dangling references）。</li>
<li>字段不能单独标记为可变，整个结构体实例必须是可变的才能修改字段。</li>
</ul>
<h3 id="2-元组结构体-tuple-structs"><a class="header" href="#2-元组结构体-tuple-structs">2. 元组结构体 (Tuple Structs)</a></h3>
<p>当你想给整个元组起个名字，但不需要为内部每个字段命名时使用。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
  
    // 注意：虽然内部类型一样，但 Color 和 Point 是不同的类型！
    println!("第一个颜色分量: {}", black.0);
}</code></pre>
<h3 id="3-单元结构体-unit-like-structs"><a class="header" href="#3-单元结构体-unit-like-structs">3. 单元结构体 (Unit-like Structs)</a></h3>
<p>没有任何字段。常用于需要在某个类型上实现 <code>Trait</code>但不需要存储数据的情况。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct AlwaysEqual;

fn main() {
    let _subject = AlwaysEqual;
}</code></pre>
<hr>
<h2 id="二-实例化"><a class="header" href="#二-实例化">二、 实例化</a></h2>
<h3 id="1-字段初始化简写-field-init-shorthand"><a class="header" href="#1-字段初始化简写-field-init-shorthand">1. 字段初始化简写 (Field Init Shorthand)</a></h3>
<p>当变量名与字段名完全相同时，可以简写。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username, // 等同于 username: username
        email,    // 等同于 email: email
        sign_in_count: 1,
    }
}

fn main() {
    let user1 = build_user(String::from("a@b.com"), String::from("user1"));
    println!("用户 {} 的邮箱是 {}", user1.username, user1.email);
}</code></pre>
<h3 id="2-结构体更新语法-struct-update-syntax"><a class="header" href="#2-结构体更新语法-struct-update-syntax">2. 结构体更新语法 (Struct Update Syntax)</a></h3>
<p>当你想要创建一个新实例，但大部分数据与旧实例相同时，使用 <code>..</code> 语法。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
fn main() {
    let user1 = User {
        email: String::from("a@b.com"),
        username: String::from("user1"),
        active: true,
        sign_in_count: 1,
    };

    // 使用 user1 的部分数据创建 user2
    let user2 = User {
        email: String::from("c@d.com"),
        ..user1 // 剩余字段直接拷贝/移动自 user1
    };
    println!("用户 {} 的邮箱是 {}", user2.username, user2.email);
    // println!("用户 {} 的邮箱是 {}", user1.username, user1.email);
    // 注意：由于 String 发生了所有权转移，user1.username 此时已失效！除非那些字段实现了 Copy trait
}</code></pre>
<h3 id="3-访问和更新字段"><a class="header" href="#3-访问和更新字段">3. 访问和更新字段</a></h3>
<p>使用点号 . 访问字段。要更新，需要可变实例（mut）。</p>
<pre class="playground"><code class="language-rust editable edition2024">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
fn main() {
    let mut user1 = User {
        email: String::from("a@b.com"),
        username: String::from("user1"),
        active: true,
        sign_in_count: 1,
    };
    user1.email = String::from("newemail@example.com");
    println!("用户 {} 的邮箱是 {}", user1.username, user1.email);
}</code></pre>
<hr>
<h2 id="三-结构体方法impl-块"><a class="header" href="#三-结构体方法impl-块">三、 结构体方法：<code>impl</code> 块</a></h2>
<p>在 Rust 中，数据定义（<code>struct</code>）和行为定义（<code>impl</code>）是分开的。</p>
<ul>
<li><strong>方法 (Methods)</strong> ：第一个参数是 <code>self</code>，通过实例调用。</li>
<li><strong>关联函数 (Associated Functions)</strong> ：没有 <code>self</code> 参数，通过 <code>类型名::</code> 调用（类似静态方法）。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">#[derive(Debug)] // 允许通过 {:?} 打印结构体
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // 关联函数：通常用于构造函数
    fn square(size: u32) -&gt; Self {
        Self { width: size, height: size }
    }

    // 方法：计算面积
    // 使用 &amp;self 借用实例，而不是获取所有权
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    // 方法：判断当前矩形是否能容纳另一个矩形
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle::square(10); // 调用关联函数

    println!("矩形面积: {}", rect1.area());
    println!("rect1 能容纳 rect2 吗？ {}", rect1.can_hold(&amp;rect2));
    println!("打印结构体详情: {:?}", rect1);
}</code></pre>
<h3 id="关键差异与-oop"><a class="header" href="#关键差异与-oop">关键差异与 OOP</a></h3>
<ul>
<li>Rust 无自动 getter/setter，需要手动定义。</li>
<li>方法名可与字段名相同（基于语法区分）。</li>
<li>强调借用规则，与 OOP 的封装不同。</li>
<li>Rust 自动处理引用/解引用，无需 -&gt; 操作符。</li>
</ul>
<hr>
<h2 id="四-结构体与所有权"><a class="header" href="#四-结构体与所有权">四、 结构体与所有权</a></h2>
<p>这是新手最容易困惑的地方：</p>
<ol>
<li><strong>字段的所有权</strong> ：如果结构体拥有其字段的所有权（如 <code>String</code>），那么当结构体被销毁时，字段也会被销毁。结构体字段若为拥有类型（如 String），实例移动时会转移所有权。</li>
<li><strong>在结构体中存储引用</strong> ：如果你希望结构体存储一个指向外部数据的引用（如 <code>&amp;str</code>），你需要使用 <strong>生命周期（Lifetimes）</strong> 标注。</li>
</ol>
<blockquote>
<p><em>目前建议先使用拥有所有权的类型（如 <code>String</code> 而不是 <code>&amp;str</code>），直到学习到生命周期章节。</em>
<em>优先使用借用（&amp;）以避免不必要的移动</em></p>
</blockquote>
<hr>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>特性</strong></th><th><strong>具名结构体</strong></th><th><strong>元组结构体</strong></th><th><strong>单元结构体</strong></th></tr>
</thead>
<tbody>
<tr><td><strong>访问方式</strong></td><td><code>s.field_name</code></td><td><code>s.0</code>,<code>s.1</code></td><td>不可访问</td></tr>
<tr><td><strong>语义</strong></td><td>明确的数据对象</td><td>强类型化的元组</td><td>标签或特征实现</td></tr>
<tr><td><strong>典型案例</strong></td><td>用户信息、配置项</td><td>坐标 (x, y)、颜色 (r, g, b)</td><td>状态标记、Trait 对象</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="枚举"><a class="header" href="#枚举">枚举</a></h1>
<p>如果说结构体（Struct）是将多个相关数据“打包”在一起，那么**枚举（Enums）**则是让一个变量在“多种可能”中选择其一。</p>
<p>在 Rust 中，枚举不仅是其他语言中常见的整数常量列表，它还是功能极其强大的 <strong>代数数据类型（Algebraic Data Types）</strong> 。</p>
<hr>
<h2 id="一-基础枚举简单的分类"><a class="header" href="#一-基础枚举简单的分类">一、 基础枚举：简单的分类</a></h2>
<p>这是枚举最基础的用法，用于定义一组离散的选项。</p>
<pre class="playground"><code class="language-rust editable edition2024">enum IpAddrKind {
    V4,
    V6,
}

fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;

    // 枚举可以作为函数参数
    route(four);
    route(six);
}

fn route(ip_kind: IpAddrKind) {}</code></pre>
<p><strong>关键点：</strong></p>
<ul>
<li>枚举变体（如 V4、V6）是枚举类型的成员。</li>
<li>枚举可以作为参数传递给函数，也可以在函数中返回。</li>
<li>你可以在 <code>match</code> 表达式中匹配枚举的每个变体，处理不同的情况。</li>
</ul>
<hr>
<h2 id="二-枚举的真威力携带数据"><a class="header" href="#二-枚举的真威力携带数据">二、 枚举的真威力：携带数据</a></h2>
<p>在 Rust 中，每个枚举变体（Variant）都可以关联不同类型、不同数量的数据。这让你可以用一个类型表达多种结构完全不同的信息。</p>
<pre class="playground"><code class="language-rust editable edition2024">enum Message {
    Quit,                       // 无数据
    Move { x: i32, y: i32 },    // 匿名结构体
    Write(String),              // 单个 String
    ChangeColor(i32, i32, i32), // 元组
}

impl Message {
    fn call(&amp;self) {
        // 你也可以为枚举定义方法！
    }
}

fn main() {
    let m = Message::Write(String::from("hello"));
    m.call();
}</code></pre>
<p>为什么这比结构体好用？</p>
<p>如果你用结构体来实现上面的功能，你可能需要定义 4 个不同的结构体(Rust 是一种强静态类型语言，函数在编译时必须明确知道它接收的参数是什么类型，以及该类型占用的空间大小。)。而使用枚举，它们都属于 Message 类型，方便在函数间统一传递。</p>
<hr>
<h2 id="三-核心中的核心option-枚举"><a class="header" href="#三-核心中的核心option-枚举">三、 核心中的核心：<code>Option</code> 枚举</a></h2>
<p>Rust  <strong>没有空值（Null）</strong> 。为了表达“一个值可能不存在”，Rust 使用了标准库中定义的 <code>Option&lt;T&gt;</code> 枚举：</p>
<pre class="playground"><code class="language-rust editable edition2024">enum Option&lt;T&gt; {
    None,
    Some(T),
}</code></pre>
<ul>
<li><strong><code>Some(T)</code></strong> ：代表有值，值为 <code>T</code> 类型。</li>
<li><strong><code>None</code></strong> ：代表没有值。</li>
</ul>
<p>意义何在？</p>
<p>在有 Null 的语言中，你随时可能忘记检查空指针而导致崩溃。在 Rust 中，如果你有一个 Option <code>&lt;i32&gt;</code>，你必须处理 None 的情况，否则代码编译不通过。这从根本上杜绝了空指针异常。</p>
<hr>
<h2 id="四-模式匹配枚举的完美搭档"><a class="header" href="#四-模式匹配枚举的完美搭档">四、 模式匹配：枚举的完美搭档</a></h2>
<p>要获取枚举内部的数据，最常用的工具就是 <code>match</code> 表达式。</p>
<h3 id="1-match穷尽式检查"><a class="header" href="#1-match穷尽式检查">1. <code>match</code>：穷尽式检查</a></h3>
<p><code>match</code> 强制你处理枚举的每一个变体。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!("来自 {:?} 州的 25 美分", state);
            25
        },
    }
}
fn main() {
    let coin = Coin::Quarter(UsState::Alaska);
    let cents = value_in_cents(coin);
    println!("{} 美分", cents);
}</code></pre>
<h3 id="2-if-let更简洁的匹配"><a class="header" href="#2-if-let更简洁的匹配">2. <code>if let</code>：更简洁的匹配</a></h3>
<p>如果你只关心其中的一种情况，<code>if let</code> 是比 <code>match</code> 更优雅的选择。</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let some_u8_value = Some(3u8);

    // 仅在值为 Some 时处理
    if let Some(value) = some_u8_value {
        println!("找到了{}！", value);
    }else{
        println!("没有找到值！");
    }
}</code></pre>
<hr>
<h2 id="五-枚举的内存布局进阶"><a class="header" href="#五-枚举的内存布局进阶">五、 枚举的内存布局（进阶）</a></h2>
<p>枚举在内存中是如何存储的？</p>
<p>Rust 会为枚举分配足够的空间来容纳最大的那个变体，此外还需要一个小的<strong>标签Tag</strong>来记录当前存的是哪一个变体。</p>
<p>对于一个枚举 $E$，其占用内存大小大致为：</p>
<p>$$
Size(E) = Size(Tag) + \max(Size(Variant_1), Size(Variant_2), \dots)
$$</p>
<blockquote>
<p>小技巧：</p>
<p>对于 Option&lt;&amp;T&gt;，因为引用（指针）永远不会为 0，Rust 会非常聪明地用 0 来表示 None。这意味着 Option&lt;&amp;T&gt; 和 &amp;T 占用的空间是一样大的！</p>
</blockquote>
<hr>
<h2 id="总结结构体-vs-枚举"><a class="header" href="#总结结构体-vs-枚举">总结：结构体 vs 枚举</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th><strong>特性</strong></th><th><strong>结构体 (Struct)</strong></th><th><strong>枚举 (Enum)</strong></th></tr>
</thead>
<tbody>
<tr><td><strong>逻辑关系</strong></td><td><strong>“和” (And)</strong> ：包含 A 且包含 B</td><td><strong>“或” (Or)</strong> ：要么是 A 要么是 B</td></tr>
<tr><td><strong>数据访问</strong></td><td>通过 <code>.</code>直接访问字段</td><td>必须通过 <code>match</code>或 <code>if let</code>解构</td></tr>
<tr><td><strong>主要用途</strong></td><td>定义具体的数据实体</td><td>定义状态机、分类、错误处理</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="切片"><a class="header" href="#切片">切片</a></h1>
<p>Rust 中的 slice（切片）是一种引用集合中连续元素的视图，而不拥有这些元素。它类似于数组或向量的子视图，使用 <code>&amp;[T]</code> 表示不可变切片，<code>&amp;mut [T]</code> 表示可变切片。Slice 是借用的一部分，遵守借用规则，确保内存安全。Slice 常用于字符串、数组和向量，帮助避免不必要的拷贝，提高效率。</p>
<h2 id="1-slice-简介"><a class="header" href="#1-slice-简介">1. Slice 简介</a></h2>
<ul>
<li><strong>什么是 slice？</strong> ：Slice 是对数据序列的引用视图，指向连续内存块。不拥有数据，只借用。长度在运行时确定。</li>
<li><strong>语法</strong> ：<code>&amp;[T]</code>（不可变）、<code>&amp;mut [T]</code>（可变）。T 是元素类型。</li>
<li><strong>优势</strong> ：零拷贝访问子集；函数参数通用（如接受 &amp;[i32] 而非 Vec 或 [i32; N]）。</li>
<li><strong>与数组/向量的关系</strong> ：数组是固定大小，向量是动态。Slice 可以从两者创建。</li>
<li><strong>字符串 slice</strong> ：<code>&amp;str</code> 是 &amp;[u8] 的特殊形式，处理 UTF-8。</li>
</ul>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let s = String::from("hello world");
    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
    println!("{}", hello);  // 输出: hello
    println!("{}", world);  // 输出: world
}</code></pre>
<ul>
<li><strong>解释</strong> ：<code>[start..end]</code> 是半开区间（包括 start，不包括 end）。<code>&amp;arr[..]</code> 是全切片。Slice 借用 arr，借用规则适用。</li>
</ul>
<p>对于字符串而言，切片就是对 String 类型中某一部分的引用，它看起来像这样：</p>
<img src="images/切片.jpg" alt="切片" class="center-img" width="50%" />
<h3 id="胖指针fat-pointer"><a class="header" href="#胖指针fat-pointer">胖指针(Fat Pointer)</a></h3>
<ul>
<li>数据结构：对比普通引用（1个字长指针）与切片引用（2个字长）。</li>
<li>组成部分：
<ul>
<li>Pointer：指向数据的起始位置。</li>
<li>Length：切片包含的元素个数。</li>
</ul>
</li>
<li>内存视图：在栈上存储元数据，在堆/静态区查看数据。</li>
</ul>
<h2 id="2-创建-slice"><a class="header" href="#2-创建-slice">2. 创建 Slice</a></h2>
<p>Slice 通过借用和范围运算符创建。</p>
<ul>
<li><strong>范围语法</strong> ：
<ul>
<li><code>[start..end]</code>：从 start 到 end-1。</li>
<li><code>[..end]</code>：从 0 到 end-1。</li>
<li><code>[start..]</code>：从 start 到结束。</li>
<li><code>[..]</code> ：整个集合。</li>
</ul>
</li>
<li><strong>从向量/数组</strong> ：直接 &amp;vec[start..end]。</li>
<li><strong>边界检查</strong> ：运行时检查，如果越界 panic!（安全）。</li>
</ul>
<h3 id="示例各种创建方式"><a class="header" href="#示例各种创建方式">示例：各种创建方式</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let vec = vec![10, 20, 30, 40, 50];
  
    let full = &amp;vec[..];      // 全切片: [10, 20, 30, 40, 50]
    let first_three = &amp;vec[0..3];  // [10, 20, 30]
    let last_two = &amp;vec[3..];     // [40, 50]
  
    println!("{:?}", first_three);
}</code></pre>
<ul>
<li><strong>解释</strong> ：Vec 和数组都支持。Slice 的 len() 返回元素数，get(i) 返回 Option&lt;&amp;T&gt;（安全访问）。</li>
</ul>
<h3 id="可变-slice"><a class="header" href="#可变-slice">可变 slice</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let mut vec = vec![1, 2, 3];
    let slice = &amp;mut vec[1..3];  // 可变借用
  
    slice[0] = 20;  // 修改 vec[1]
    println!("{:?}", vec);  // 输出: [1, 20, 3]
}</code></pre>
<ul>
<li><strong>解释</strong> ：可变 slice 允许修改元素，但遵守独占借用规则。</li>
</ul>
<h2 id="3-字符串-slice-str"><a class="header" href="#3-字符串-slice-str">3. 字符串 Slice (&amp;str)</a></h2>
<p>字符串 slice 是常见的，处理 String 或 str。</p>
<h3 id="示例字符串-slice"><a class="header" href="#示例字符串-slice">示例：字符串 slice</a></h3>
<pre class="playground"><code class="language-rust editable edition2024">fn first_word(s: &amp;str) -&gt; &amp;str {  // 既能接受 String 的切片，也能接受字符串字面量
    let bytes = s.as_bytes();
    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }
    &amp;s[..]
}

fn main() {
    let s = String::from("hello world");
    let word = first_word(&amp;s);  // &amp;String 隐式转为 &amp;str
    
    println!("{}", word);  // 输出: hello
    
    // s.clear();  // 错误！word 借用期间不能修改 s
}</code></pre>
<ul>
<li><strong>解释</strong> ：<code>&amp;str</code> 是 UTF-8 安全的。as_bytes() 转为 &amp;[u8]。切片索引必须在字符边界（否则 panic!）。用 chars() 或 bytes() 迭代以避免。</li>
</ul>
<h2 id="4-多维-slice"><a class="header" href="#4-多维-slice">4. 多维 Slice</a></h2>
<p>Slice 可以是多维的，如 <code>&amp;[[T]]</code>。</p>
<p>示例：矩阵 slice</p>
<pre class="playground"><code class="language-rust editable edition2024">fn main() {
    let matrix = vec![vec![1, 2], vec![3, 4]];
    let row = &amp;matrix[0][..];  // &amp;[i32]: [1, 2]
    
    println!("{:?}", row);
}</code></pre>
<ul>
<li>解释：嵌套借用。复杂时考虑扁平化或专用 crate。</li>
</ul>
<blockquote>
<p>注意事项：
索引越界：如果你请求的范围超出了集合边界（如 &amp;s[0..100]），Rust 会在运行时 panic。
UTF-8 字符：对于字符串切片，索引必须落在字符边界上。如果在多字节字符（如中文）中间切片，程序会崩溃。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="泛型"><a class="header" href="#泛型">泛型</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="trait"><a class="header" href="#trait">trait</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="生命周期"><a class="header" href="#生命周期">生命周期</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="迭代器"><a class="header" href="#迭代器">迭代器</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="宏"><a class="header" href="#宏">宏</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="项目组织及依赖管理"><a class="header" href="#项目组织及依赖管理">项目组织及依赖管理</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="项目结构"><a class="header" href="#项目结构">项目结构</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cargotoml"><a class="header" href="#cargotoml">Cargo.Toml</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cargo"><a class="header" href="#cargo">Cargo</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cargo-命令"><a class="header" href="#cargo-命令">Cargo 命令</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cargo-工具链"><a class="header" href="#cargo-工具链">Cargo 工具链</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="三方库"><a class="header" href="#三方库">三方库</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="serde"><a class="header" href="#serde">serde</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="leetcode"><a class="header" href="#leetcode">LeetCode</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="定长滑动窗口"><a class="header" href="#定长滑动窗口">定长滑动窗口</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="定长滑动窗口-1"><a class="header" href="#定长滑动窗口-1">定长滑动窗口</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace-2a3cd908.js"></script>
        <script src="mode-rust-2c9d5c9a.js"></script>
        <script src="editor-16ca416c.js"></script>
        <script src="theme-dawn-4493f9c8.js"></script>
        <script src="theme-tomorrow_night-9dbe62a9.js"></script>

        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
