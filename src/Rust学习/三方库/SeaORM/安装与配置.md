# 安装与配置

**PostgreSQL + SeaORM** 的标准化安装与配置流程。按照这个顺序操作，你可以快速搭建起开发环境。

---

## 第一步：配置 `Cargo.toml` (依赖安装)首先，在你的 Rust 项目中引入 SeaORM。既然你使用 **PostgreSQL**，请务必开启 `sqlx-postgres` 驱动

```toml
[dependencies]
# SeaORM 核心配置
sea-orm = { version = "1.1.0", features = [ 
    "sqlx-postgres",          # 必选：PostgreSQL 驱动
    "runtime-tokio-rustls",   # 必选：异步运行时
    "macros",                 # 必选：用于自动生成代码
    "debug-print",            # 建议：开发时查看 SQL 日志
    "with-chrono",            # 建议：处理数据库的时间类型
] }
# 日志捕获（用于配合 debug-print）
tracing = "0.1"
tracing-subscriber = "0.3"
# 异步库
tokio = { version = "1.0", features = ["full"] }
```

### Extra features

* **debug-print** - 将每个 SQL 语句打印到记录器
* **mock** - 用于单元测试的模拟接口
* **macros** - 过程宏，例如 DeriveEntityModel
* **rbac** - 基于角色的访问控制
* **seaography** - 启用 GraphQL 支持
* **schema-sync** - 启用 SchemaBuilder 中的同步功能

* **with-chrono** - 支持 chrono 类型
* **with-time** - 支持 time 类型
* **with-json** - 支持 serde-json 类型
* **with-rust_decimal** - 支持 rust_decimal 类型
* **with-bigdecimal** - 支持 bigdecimal 类型
* **with-uuid** - 支持 uuid 类型
* **with-ipnetwork** - 支持 Postgres ipnetwork
* **postgres-vector** - 支持 Postgres pgvector
* **postgres-array** - 支持 Postgres 数组类型，默认开启

* **sqlite-use-returning-for-3_35** - 为 SQLite 3.35+ 版本使用 RETURNING 语句，默认开启
* **mariadb-use-returning** - 为 MariaDB 使用 RETURNING 语句，默认开启

---

## 第二步：配置连接选项 (Database Connection)

在代码中通过 `ConnectOptions` 建立与 PostgreSQL 的连接。你可以设置连接池的大小和超时时间。
**用法说明：**

```rust,ignore
usesea_orm::{ConnectOptions, Database, DatabaseConnection};
usestd::time::Duration;
pubasyncfnsetup_db() ->Result<DatabaseConnection, sea_orm::DbErr> {
    // PostgreSQL 连接字符串格式
    letdb_url="postgres://username:password@localhost:5432/database_name";
    letmutopt=ConnectOptions::new(db_url);
    opt.max_connections(20)           // 最大连接数
       .min_connections(5)            // 最小连接数
       .connect_timeout(Duration::from_secs(8)) // 连接超时
       .sqlx_logging(false);          // 关闭 SQLx 原生日志，改用 SeaORM 的 debug-print
    // 返回连接对象 (DatabaseConnection)
    Database::connect(opt).await
}
```

---

## 第三步：开启调试日志 (Logging)

为了在控制台看到 SeaORM 生成的 SQL 语句，你需要在 `main` 函数开头初始化日志订阅者。

**用法说明：**

```rust
#[tokio::main]
async fn main() {
    // 初始化日志系统，这样才能看到 debug-print 输出的 SQL
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::DEBUG)
        .init();
    letdb=setup_db().await.expect("数据库连接失败");
    // ... 开始你的业务逻辑
}
```

---

## 第四步：理解操作逻辑 (CRUD 模式)

配置完成后，你在编写业务逻辑时只需记住这套“三位一体”的操作流：

1.**定义阶段 (Entity)**：写一个结构体代表 PostgreSQL 的表。

2.**读取阶段 (Model)**：使用 `Entity::find()` 查询，结果存入 `Model`（只读）。

3.**写入阶段 (ActiveModel)**：

* 要把 `Model` 转成 `ActiveModel` 才能修改。
* 直接创建 `ActiveModel` 用于插入新数据。

4.**手动传递连接**：把第二步生成的 `db` (DatabaseConnection) 对象传给查询函数。

---
