# 介绍

## 了解 SeaORM 的核心工作流

### 请记住这三个核心角色之间的转换关系

* Entity (实体): 对应数据库里的“表”。它定义了结构、关联关系和主键。
* Model (模型): 这是一个纯粹的 Rust 结构体，代表了数据库中的一行数据。它是只读的，通常用于查询结果。
* ActiveModel (活跃模型): 这是用于修改数据的结构体。当你需要 INSERT 或 UPDATE 时，你会把 Model 转换为ActiveModel，设置好字段后再存入数据库。

### SeaORM 的核心逻辑

#### 1. 读写分离（Model vs ActiveModel）

SeaORM 把“数据”分成了两种状态，这是它最特别的地方：

***Model (只读卡片)：** 你从数据库里查出来的数据。它就像一张 **照片** ，你可以看，但不能直接在上面改。

***ActiveModel (可写表单)：** 当你要新增或改动数据时，必须把照片变成“表单”。它会记录哪个字段改了，哪个没改，最后再保存回数据库。

#### 2. Entity 是“地图”

***Entity** 就是数据库表的 **定义（Schema）** 。

* 它告诉程序：表名是什么、有哪些列、主键是谁、表与表之间怎么关联。

#### 3. 连接要“亲手传递”

* SeaORM  **没有全局变量** （不像某些框架可以直接调用 `DB::save()`）。
* 你必须自己拿着“数据库连接对象”（`DatabaseConnection`），把它传给需要操作数据库的函数。这样做虽然麻烦一点点，但代码更安全、更易于测试。

---

**总结成一句话：**

> **Entity** 定义表，**Model** 用来读，**ActiveModel** 用来写，**Connection** 手动传。
>
