# 错误处理库

了解整个生态，能帮你明白为什么 `anyhow` 会成为现在的“国民级”选择。

在 Rust 的世界里，错误处理库主要分为 **“应用派”** 和 **“库派”**，它们共同构建了一个互补的生态系统。

---

## 1、生态基石：`std::error::Error`

所有的错误处理库，本质上都是在围绕标准库的 `std::error::Error` trait 做文章。

* **过去**：你需要手动为每个错误实现 `Display`、`Debug` 和 `Error` 三个 trait。代码极其冗长。
* **现在**：生态库通过 **过程宏 (Macros)** 帮你自动生成这些样板代码，让你只需关注错误本身。

---

## 2、四大主流错误处理库

### ① `anyhow`（应用级首选）

* **定位**：应用程序的“垃圾桶”和“粘合剂”。
* **特点**：简单、好上手。它把所有错误都看作一个动态的 trait 对象（`Box<dyn Error>` 的加强版）。
* **适用场景**：你不在乎具体的错误类型，只想要好用的上下文（Context）和快速的错误传播（`?`）。

### ② `thiserror`（库级标准）

* **定位**：结构化错误的“模具”。
* **特点**：通过宏自动实现标准 trait，保持了错误的**强类型**。
* **适用场景**：你正在写一个给别人用的库。你需要定义 `enum MyError { ... }`，让你的用户可以用 `match` 匹配不同的错误情况。

### ③ `eyre`（anyhow 的华丽升级版）

* **定位**：极度注重“颜值”和“可定制化”的应用错误处理。
* **特点**：它是 `anyhow` 的分支。配合 `color-eyre`，它可以打印出极其漂亮的、带颜色的、带代码片段提示的错误报告。
* **适用场景**：你正在写一个对最终用户（User-facing）非常友好的 CLI 工具或复杂应用。

### ④ `miette`（极致的报错诊断）

* **定位**：像 Rust 编译器报错一样的极致体验。
* **特点**：它可以高亮代码行、指出具体的字符位置、甚至给出“修复建议”。
* **适用场景**：开发解析器（Parser）、编译器或对错误诊断要求极高的工具。

---

## 3、生态库对比一览表

| 库名称 | 解决的核心问题 | 性能开销 | 主要优势 |
| --- | --- | --- | --- |
| **`anyhow`** | 统一管理、快速报错 | 略高（涉及堆分配） | 开发效率极高，API 极简。 |
| **`thiserror`** | 自动实现繁琐的 Trait | 极低（零开销） | 保持强类型，对下游用户友好。 |
| **`eyre`** | 更美观的错误报告 | 略高 | 报告更详细（类似编译器的输出）。 |
| **`miette`** | 完美的报错诊断 | 较高 | 能够精准指出代码中的错误位置。 |

---

## 4、协作法则：库用 thiserror，应用用 anyhow/eyre

在 Rust 生态中，最健康的结构如下：

1. **基础库 (Base Libs)**：底层不依赖任何库，或只用 `thiserror` 定义精准的 `enum`。
2. **中间件 (Middleware)**：转发底层错误，使用 `thiserror` 的 `[from]` 宏自动转换。
3. **最终应用 (Application)**：通过 `anyhow` 或 `eyre` 将所有库的错误汇聚在一起，加上 `.context()`，形成一棵完整的错误树。
