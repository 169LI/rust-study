# 上下文管理

进入最体现 `anyhow` 灵魂的部分：**上下文（Context）管理**。

在 Rust 开发中，最让人头疼的莫过于看到一个孤零零的 `Os { code: 2, kind: NotFound, message: "No such file or directory" }`。你根本不知道是哪个模块、哪个文件找不到了。`anyhow` 的 `Context` 就是为了解决这个问题。

---

## 1、什么是上下文（Context）

简单来说，上下文就是**给底层错误套上一层“人话”解释**。它不会改变原始错误，而是像套娃一样，在原始错误外面包一层说明，告诉调试者：这个操作是在哪一步崩掉的。

要使用这个功能，你需要引入 `use anyhow::Context;`（注意这是一个 trait，引入后才能在 `Result` 上调用相关方法）。

---

## 2、`.context()`：简单直接的静态说明

如果你只需要添加一段固定的字符串，直接用 `.context()`。

```rust,ignore
use anyhow::{Context, Result};
use std::fs;
fn read_config() -> Result<String> {
    // 如果文件不存在，原本只报 "No such file..."
    // 现在会报 "无法读取系统配置文件" 并带上底层原因
    fs::read_to_string("config.toml")
        .context("无法读取系统配置文件")
}
```

---

## 3、`.with_context()`：支持动态信息的“懒加载”

有时候我们需要在错误信息里加入变量（比如报错的文件名）。这时候要用 `.with_context()`，它接收一个**闭包**。

**为什么要用闭包？** 因为只有在**确实发生错误**时，闭包里的代码（如字符串拼接）才会执行，这样在程序正常运行阶段不会有性能损耗。

```rust,ignore
fn load_user_data(user_id: u32) -> Result<String> {
    let path = format!("users/{}.json", user_id);
    
    fs::read_to_string(&path)
        .with_context(|| format!("加载用户 {} 的数据失败，路径: {}", user_id, path))?
    
    Ok("data".to_string())
}

```

---

## 4、多层上下文与错误链

`anyhow` 允许你在调用栈里一层层往上加 context。当最终打印错误时，你会看到一个清晰的“因果链条”。

```rust,ignore
fn main() -> Result<()> {
    // 第三层：顶层业务逻辑说明
    do_heavy_work().context("任务执行失败，程序即将退出")?;
    Ok(())
}

fn do_heavy_work() -> Result<()> {
    // 第二层：具体模块逻辑说明
    connect_database().context("初始化数据库连接时出错")?;
    Ok(())
}

fn connect_database() -> Result<()> {
    // 第一层：最底层 IO 错误
    std::fs::read_to_string("db_config.toml")?;
    Ok(())
}

```

**运行后的报错效果（使用 `{:?}` 打印）：**

```rust,ignore
Error: 任务执行失败，程序即将退出

Caused by:
    0: 初始化数据库连接时出错
    1: No such file or directory (os error 2)

```

---

## 5、小结：`.context()` 还是 `.with_context()`？

| 方法 | 参数类型 | 使用场景 |
| --- | --- | --- |
| **`.context("...")`** | 字符串/固定信息 | 简单的、不包含动态变量的说明。 |
| **`.with_context( |  | ...)`** |

> **避坑指南：** > 很多新手会写成 `.context(format!("..."))`，这虽然能跑通，但由于 `format!` 在成功或失败时都会被执行，会白白浪费 CPU 性能。记住：**有变量，用 `with_context`。**
