# è¿­ä»£å™¨

Rust çš„è¿­ä»£å™¨ï¼ˆ`iterators`ï¼‰æ˜¯å¤„ç†åºåˆ—æ•°æ®çš„å¼ºå¤§å·¥å…·ï¼Œå…è®¸ä½ ä»¥æ‡’æƒ°ï¼ˆlazyï¼‰æ–¹å¼éå†é›†åˆï¼Œè€Œä¸ç«‹å³è®¡ç®—æ‰€æœ‰å…ƒç´ ã€‚è¿™æé«˜äº†æ•ˆç‡ï¼Œå°¤å…¶åœ¨é“¾å¼æ“ä½œä¸­ã€‚è¿­ä»£å™¨å®ç°äº† `Iterator trait`ï¼Œæä¾› next() æ–¹æ³•è¿”å› `Option<Item>`ã€‚Rust æ ‡å‡†åº“ä¸­çš„è®¸å¤šç±»å‹å¦‚ `Vecã€HashMapã€Range` ç­‰éƒ½æ”¯æŒè¿­ä»£å™¨ã€‚è¿­ä»£å™¨æ˜¯é›¶æˆæœ¬æŠ½è±¡ï¼Œç¼–è¯‘æ—¶ä¼˜åŒ–ã€‚


## ä¸€ã€ æ ¸å¿ƒæ¦‚å¿µ

### 1. è¿­ä»£å™¨çš„æœ¬è´¨ï¼šå»¶è¿Ÿè®¡ç®—ï¼ˆLazy Evaluationï¼‰

åœ¨ Rust ä¸­ï¼Œåˆ›å»ºä¸€ä¸ªè¿­ä»£å™¨å¹¶**ä¸ä¼š**ç«‹åˆ»æ‰§è¡Œä»»ä½•è®¡ç®—ã€‚å®ƒæ›´åƒæ˜¯ä¸€ä¸ªâ€œå¤„æ–¹â€æˆ–â€œè®¡åˆ’ä¹¦â€ã€‚åªæœ‰å½“ä½ çœŸæ­£å¼€å§‹å‘è¿­ä»£å™¨â€œè¦ä¸œè¥¿â€æ—¶ï¼Œå®ƒæ‰ä¼šå¼€å§‹å·¥ä½œã€‚

#### ä¸ºä»€ä¹ˆæˆ‘çš„ä»£ç æ²¡è¿è¡Œï¼Ÿ

å¾ˆå¤šåˆå­¦è€…å†™äº† `map` å´å‘ç°æ²¡æœ‰ä»»ä½•è¾“å‡ºï¼Œè¿™å°±æ˜¯å› ä¸ºæ²¡æœ‰è§¦å‘â€œæ¶ˆè´¹â€ã€‚è¿™å°±æ˜¯ `Lazy`ï¼šå…ˆå»ºç®¡é“ï¼Œåæ‰§è¡Œã€‚

```rust,editable
fn main() {
    let v = vec![1, 2, 3];
    // è¿™ä¸€è¡Œä»£ç å‡ ä¹ä¸æ¶ˆè€—æ—¶é—´ï¼Œä¹Ÿä¸ä¼šæ‰“å°ä»»ä½•ä¸œè¥¿
    // å®ƒåªæ˜¯åˆ›å»ºäº†ä¸€ä¸ªâ€œè®¡åˆ’â€ï¼šæŠŠæ¯ä¸ªå…ƒç´ åŠ  1
    let v_iter = v.iter().map(|x| {
        println!("æ­£åœ¨è®¡ç®—: {}", x);
        x + 1
    });
    println!("è¿­ä»£å™¨å·²åˆ›å»ºï¼Œå‡†å¤‡å¼€å§‹...");
    // åªæœ‰åˆ°äº†è¿™ä¸€æ­¥ï¼Œæˆ–è€…ä½¿ç”¨ for å¾ªç¯ï¼Œè®¡ç®—æ‰ä¼šçœŸæ­£å‘ç”Ÿ
    let result: Vec<_> = v_iter.collect(); 
    println!("æœ€ç»ˆç»“æœ: {:?}", result);
}
```

### 2. è¿­ä»£å™¨ä¸ `for` å¾ªç¯çš„å…³ç³»

**æ ¸å¿ƒé€»è¾‘**ï¼šRust çš„ `for` å¾ªç¯å…¶å®æ˜¯**è¯­æ³•ç³–**ã€‚å½“ä½ å†™ `for x in items` æ—¶ï¼Œç¼–è¯‘å™¨åœ¨åº•å±‚ä¼šè‡ªåŠ¨å°†å…¶è½¬æ¢ä¸ºè¿­ä»£å™¨è°ƒç”¨ã€‚

#### ç¼–è¯‘å™¨åšäº†ä»€ä¹ˆï¼Ÿ

å½“ä½ å†™ä¸‹è¿™æ®µä»£ç ï¼š

```rust
for x in vec![1, 2, 3] {
    println!("{}", x);
}
```

ç¼–è¯‘å™¨å®é™…ä¸Šå°†å…¶â€œå±•å¼€â€ä¸ºç±»ä¼¼è¿™æ ·çš„é€»è¾‘ï¼š

```rust
let mut iter = vec![1, 2, 3].into_iter(); // è½¬æ¢ä¸ºè¿­ä»£å™¨
while let Some(x) = iter.next() {         // ä¸æ–­è°ƒç”¨ next()
    println!("{}", x);
}
```

* **æ³¨æ„**ï¼šè¿­ä»£å™¨å†…éƒ¨ç»´æŠ¤äº†ä¸€ä¸ªçŠ¶æ€ï¼ˆé€šå¸¸æ˜¯ä¸€ä¸ªæŒ‡é’ˆæˆ–ç´¢å¼•ï¼‰ï¼Œæ¯æ¬¡è°ƒç”¨ `next()`ï¼ŒçŠ¶æ€å°±ä¼šå‘åç§»åŠ¨ã€‚

### 3. æ¶ˆè´¹ç«¯ï¼ˆConsumersï¼‰ä¸é€‚é…å™¨ï¼ˆAdaptersï¼‰

è¿­ä»£å™¨çš„æ“ä½œå¯ä»¥åˆ†ä¸ºä¸¤ç±»ï¼Œç†è§£å®ƒä»¬çš„åŒºåˆ«æ˜¯æŒæ¡æ•°æ®æµçš„å…³é”®ã€‚

| ç±»åˆ« | ä½œç”¨ | ç‰¹ç‚¹ | ä¾‹å­ |
| --- | --- | --- | --- |
| **é€‚é…å™¨ (Adapters)** | å°†ä¸€ä¸ªè¿­ä»£å™¨è½¬å˜ä¸ºå¦ä¸€ä¸ªè¿­ä»£å™¨ | **æƒ°æ€§**ã€‚ä¸è§¦å‘è®¡ç®—ï¼Œåªå®šä¹‰å˜æ¢é€»è¾‘ã€‚ | `map`, `filter`, `zip`, `take` |
| **æ¶ˆè´¹ç«¯ (Consumers)** | å¯åŠ¨è¿­ä»£è¿‡ç¨‹ï¼Œäº§ç”Ÿæœ€ç»ˆç»“æœ | **ä¸»åŠ¨**ã€‚ä¼šè°ƒç”¨ `next()`ï¼Œè§¦å‘æ•´ä¸ªé“¾æ¡çš„è¿è¡Œã€‚ | `collect`, `sum`, `fold`, `count` |

#### ç»„åˆçš„å¨åŠ›

ä½ å¯ä»¥é€šè¿‡é€‚é…å™¨æ„å»ºä¸€æ¡å¤æ‚çš„â€œæµæ°´çº¿â€ï¼Œæœ€åç”¨ä¸€ä¸ªæ¶ˆè´¹ç«¯æ”¶å°¾ã€‚

```rust,editable
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6];
    // æµæ°´çº¿è®¾è®¡ï¼š
    let sum: i32 = numbers.iter()
        .filter(|&&x| x % 2 == 0) // é€‚é…å™¨ï¼šåªè¦å¶æ•°
        .map(|&x| x * x)          // é€‚é…å™¨ï¼šå¹³æ–¹
        .take(2)                  // é€‚é…å™¨ï¼šåªè¦å‰ä¸¤ä¸ª
        .sum();                   // æ¶ˆè´¹ç«¯ï¼šè§¦å‘æ‰€æœ‰è®¡ç®—å¹¶æ±‚å’Œ
    println!("å‰ä¸¤ä¸ªå¶æ•°çš„å¹³æ–¹å’Œ: {}", sum); // (2*2) + (4*4) = 20
}
```

---

## äºŒã€ä¸‰å¤§æ ¸å¿ƒ Trait

* `Iterator Trait`ï¼šæ ¸å¿ƒæ¥å£ï¼Œç†è§£ `next()` æ–¹æ³•ä¸ `Item` å…³è”ç±»å‹
* `IntoIterator Trait`ï¼šå¦‚ä½•å°†é›†åˆï¼ˆå¦‚ `Vec, HashMap`ï¼‰è½¬æ¢ä¸ºè¿­ä»£å™¨
* `FromIterator Traitï¼šcollect()` æ–¹æ³•èƒŒåçš„åŸç†ï¼ˆå¦‚ä½•å°†è¿­ä»£å™¨è½¬å›é›†åˆï¼‰

åœ¨ Rust ä¸­ï¼Œè¿­ä»£å™¨ä¸æ˜¯æŸç§ç‰¹æ®Šçš„è¯­è¨€æ„é€ ï¼Œè€Œæ˜¯é€šè¿‡ä¸‰ä¸ªæ ¸å¿ƒ Trait æ„å»ºçš„ä½“ç³»ã€‚ç†è§£äº†è¿™ä¸‰ä¸ª Traitï¼Œä½ å°±ç†è§£äº†æ•°æ®å¦‚ä½•åœ¨â€œé›†åˆâ€ä¸â€œæµæ°´çº¿â€ä¹‹é—´æµè½¬ã€‚
è¿™ä¸€éƒ¨åˆ†ä½ åªè¦æŠ“ä½ä¸€æ¡ä¸»çº¿å°±å¤Ÿäº†ï¼š

> for è´Ÿè´£æŠŠä¸œè¥¿å˜æˆè¿­ä»£å™¨ï¼ˆIntoIteratorï¼‰ â†’
> è¿­ä»£å™¨ç”¨ next() åå…ƒç´ ï¼ˆIteratorï¼‰ â†’
> collect() æŠŠå…ƒç´ â€œè£…å›å»â€ï¼ˆFromIteratorï¼‰

å¯ä»¥æŠŠå®ƒæƒ³æˆä¸€æ¡æµæ°´çº¿ï¼š

é›†åˆ/è‡ªå®šä¹‰ç±»å‹ â”€â”€(`IntoIterator`)â”€â”€> è¿­ä»£å™¨ â”€â”€(`Iterator::next`)â”€â”€> å…ƒç´ åºåˆ— â”€â”€(`FromIterator/collect`)â”€â”€> æ–°é›†åˆ

### 1. `Iterator` Traitï¼šè¿­ä»£å™¨çš„åŸºçŸ³

è¿™æ˜¯æœ€æ ¸å¿ƒçš„ Traitã€‚åªè¦ä¸€ä¸ªç±»å‹å®ç°äº†å®ƒï¼Œå®ƒå°±æ˜¯ä¸€ä¸ªè¿­ä»£å™¨ã€‚

#### æœ€æ ¸å¿ƒçš„ä¸¤ä¸ªä¸œè¥¿ï¼šItem + next()

Iterator çš„æœ¬è´¨å°±æ˜¯ä¸€ä¸ªçŠ¶æ€æœºï¼šæ¯æ¬¡è°ƒç”¨ next()ï¼Œè¿­ä»£å™¨æ¨è¿›å†…éƒ¨çŠ¶æ€å¹¶å°è¯•äº§å‡ºä¸€ä¸ªå…ƒç´ ã€‚

> next() çš„ç­¾åå¿…é¡»æ˜¯ `&mut self`ï¼šå› ä¸ºæ¯æ¬¡è¿­ä»£éƒ½ä¼šæ”¹å˜â€œæˆ‘è¿­åˆ°å“ªäº†â€çš„å†…éƒ¨çŠ¶æ€ã€‚

å…¸å‹å½¢æ€ï¼ˆè¦è®°ä½ç»“æ„ï¼‰ï¼š

```rust,ignore
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}
```

* **`type Item`**ï¼šå…³è”ç±»å‹ï¼Œå®šä¹‰äº†è¿­ä»£å™¨æ¯æ¬¡äº§å‡ºä»€ä¹ˆã€‚
* **`fn next(&mut self) -> Option<Self::Item>`**ï¼šè¿™æ˜¯å”¯ä¸€éœ€è¦æ‰‹åŠ¨å®ç°çš„æ–¹æ³•ã€‚

##### æ‰‹åŠ¨å®ç°ä¸€ä¸ªâ€œæ­¥è¿›å™¨â€

é€šè¿‡æ‰‹åŠ¨å®ç°ï¼Œä½ ä¼šå‘ç°è¿­ä»£å™¨åªæ˜¯ä¸€ä¸ª**è®°å½•äº†å½“å‰çŠ¶æ€**çš„ç»“æ„ä½“ã€‚

```rust,editable
struct Counter {
    count: u32,
    max: u32,
}
impl Counter {
    fn new(max: u32) -> Counter {
        Counter { count: 0, max }
    }
}
// æ‰‹åŠ¨å®ç° Iterator
impl Iterator for Counter {
    type Item = u32; // å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œæˆ‘ä»¬äº§å‡ºçš„æ˜¯ u32
    fn next(&mut self) -> Option<Self::Item> {
        if self.count < self.max {
            self.count += 1;
            Some(self.count)
        } else {
            None // è¿”å› None ä»£è¡¨è¿­ä»£ç»“æŸ
        }
    }
}
fn main() {
    let mut counter = Counter::new(3);
    // æˆ‘ä»¬å¯ä»¥æ‰‹åŠ¨è°ƒç”¨ next
    assert_eq!(counter.next(), Some(1));
    assert_eq!(counter.next(), Some(2));
    assert_eq!(counter.next(), Some(3));
    assert_eq!(counter.next(), None);
}
```

##### æ‰‹åŠ¨è°ƒç”¨ next()ï¼šæœ€ç›´è§‚ç†è§£è¿­ä»£å™¨

```rust,editable
fn main() {
    let v = vec![10, 20, 30];
    // Vec<T> çš„ into_iter() ç”Ÿæˆä¸€ä¸ªâ€œæ‹¿èµ°æ‰€æœ‰æƒâ€çš„è¿­ä»£å™¨
    let mut it = v.into_iter();
    println!("{:?}", it.next()); // Some(10)
    println!("{:?}", it.next()); // Some(20)
    println!("{:?}", it.next()); // Some(30)
    println!("{:?}", it.next()); // None
    println!("{:?}", it.next()); // ä¾ç„¶ Noneï¼ˆå¾ˆå¤šè¿­ä»£å™¨æ˜¯ fused çš„ï¼Œä½†ä¸æ˜¯ trait å¼ºåˆ¶ï¼‰
}
```

ä½ çœ‹åˆ°çš„å°±æ˜¯ï¼š**è¿­ä»£å™¨æ¯æ¬¡åä¸€ä¸ªå…ƒç´ ï¼Œåå®Œå°± None**ã€‚

#### Iterator çš„â€œå¾ˆå¤šæ–¹æ³•â€ä»å“ªæ¥çš„ï¼Ÿ

map/filter/take/fold/sum/... è¿™äº›å‡ ä¹éƒ½æ˜¯ Iterator trait ä¸Šçš„é»˜è®¤æ–¹æ³•ï¼ŒåŸºäº next() ç»„åˆå‡ºæ¥çš„ã€‚ä½ åªè¦å®ç° next()ï¼ŒRust æ ‡å‡†åº“å°±é€ä½ ä¸€æ•´å¥—â€œå‡½æ•°å¼ç®¡é“å·¥å…·â€ã€‚

```rust,editable
fn main() {
    let sum: i32 = (1..=10)
        .map(|x| x * 2)      // é€‚é…å™¨ï¼šç”Ÿæˆæ–°è¿­ä»£å™¨
        .filter(|x| x % 3 == 0)
        .sum();              // æ¶ˆè€—å™¨ï¼šè§¦å‘æ‰§è¡Œ
    println!("{sum}");
}
```

### 2. `IntoIterator` Traitï¼šé›†åˆå¦‚ä½•å˜æˆè¿­ä»£å™¨ï¼ˆfor å¾ªç¯èƒŒåï¼‰

**æ ¸å¿ƒé€»è¾‘**ï¼šè¿™ä¸ª Trait å®šä¹‰äº†å¦‚ä½•å°†ä¸€ä¸ªéè¿­ä»£å™¨ç±»å‹ï¼ˆå¦‚ `Vec`ï¼‰è½¬æ¢ä¸ºè¿­ä»£å™¨ã€‚è¿™ä¹Ÿæ˜¯ `for` å¾ªç¯èƒ½å¤Ÿå·¥ä½œçš„æ ¹æœ¬åŸå› ã€‚


#### for å¾ªç¯åˆ°åº•åšäº†ä»€ä¹ˆï¼Ÿ

`for x in something` åšçš„ç¬¬ä¸€ä»¶äº‹æ˜¯ï¼š

> è°ƒç”¨ `something.into_iter()`ï¼ˆå‡†ç¡®åœ°è¯´æ˜¯ `IntoIterator::into_iter(something)`ï¼‰

ç„¶åä¸æ–­ next()ã€‚

ç­‰ä»·ç†è§£ï¼ˆä¼ªå±•å¼€ï¼‰ï¼š

```rust,ignore
let mut iter = something.into_iter();
while let Some(x) = iter.next() {
    // ...
}

### `IntoIterator`çš„å®šä¹‰

```rust,ignore
trait IntoIterator {
    type Item;
    type IntoIter: Iterator<Item = Self::Item>;
    fn into_iter(self) -> Self::IntoIter;
}
```

è¿™é‡Œçš„å…³é”®æ˜¯ï¼š

* `IntoIterator` è´Ÿè´£â€œæ€ä¹ˆç”Ÿæˆè¿­ä»£å™¨â€
* ç”Ÿæˆçš„è¿­ä»£å™¨å¿…é¡»å®ç° `Iterator`
* `Item` å†³å®šäº†ä½ åœ¨ `for x in ...` é‡Œæ‹¿åˆ°çš„ `x` æ˜¯ä»€ä¹ˆç±»å‹


#### åŒä¸€ä¸ªå®¹å™¨æœ‰ 3 ç§å¸¸è§ IntoIterator å®ç°

ä»¥ `Vec<T>` ä¸ºä¾‹ï¼š

* `Vec<T>`ï¼ˆæŒ‰å€¼ï¼‰â†’ `into_iter()` äº§å‡º `T`ï¼ˆ**æ¶ˆè€—åŸé›†åˆ**ï¼‰
* `&Vec<T>`ï¼ˆå…±äº«å€Ÿç”¨ï¼‰â†’ `into_iter()` äº§å‡º `&T`
* `&mut Vec<T>`ï¼ˆå¯å˜å€Ÿç”¨ï¼‰â†’ `into_iter()` äº§å‡º `&mut T`

```rust,editable
fn main() {
    let v = vec![String::from("a"), String::from("b")];
    // 1) å€Ÿç”¨éå†ï¼šæ‹¿åˆ° &String
    for s in &v {
        println!("borrowed: {s}");
    }
    println!("still have v: {:?}", v);
    // 2) æ‰€æœ‰æƒéå†ï¼šæ‹¿åˆ° Stringï¼ˆv è¢« move èµ°ï¼‰
    for s in v {
        println!("owned: {s}");
    }
    // println!("{:?}", v); // âŒ v å·²ç»è¢«æ¶ˆè€—
}
```

#### è‡ªå®šä¹‰ç±»å‹å®ç° `IntoIterator`ï¼šè®©å®ƒèƒ½ç›´æ¥ `for .. in ..`

æ¯”å¦‚è‡ªå®šä¹‰ä¸€ä¸ªèŒƒå›´ç±»å‹ï¼š

```rust,editable
struct MyRange {
    start: i32,
    end: i32,
}
struct MyRangeIter {
    cur: i32,
    end: i32,
}
impl Iterator for MyRangeIter {
    type Item = i32;
    fn next(&mut self) -> Option<i32> {
        if self.cur >= self.end {
            None
        } else {
            let v = self.cur;
            self.cur += 1;
            Some(v)
        }
    }
}
impl IntoIterator for MyRange {
    type Item = i32;
    type IntoIter = MyRangeIter;
    fn into_iter(self) -> MyRangeIter {
        MyRangeIter { cur: self.start, end: self.end }
    }
}
fn main() {
    for x in MyRange { start: 0, end: 3 } {
        println!("{x}");
    }
}
```

---

### 3. `FromIterator` Traitï¼šæµæ°´çº¿çš„ç»ˆç‚¹ (`collect`)

**æ ¸å¿ƒé€»è¾‘**ï¼šè¿™æ˜¯ `collect()` æ–¹æ³•èƒŒåçš„è‹±é›„ã€‚å®ƒå®šä¹‰äº†å¦‚ä½•å°†è¿­ä»£å™¨ä¸­çš„å…ƒç´ â€œæ”¶é›†â€å›ä¸€ä¸ªæ–°çš„é›†åˆã€‚

#### `collect()` ä¸æ˜¯é­”æ³•ï¼Œå®ƒé  `FromIterator`

ä½ å¯ä»¥æŠŠ collect() ç†è§£æˆï¼š

> â€œè¯·æŠŠè¿™ä¸ªè¿­ä»£å™¨çš„å…ƒç´ ï¼ŒæŒ‰ç›®æ ‡ç±»å‹çš„è§„åˆ™è£…èµ·æ¥â€

è£…çš„è§„åˆ™æ¥è‡ªï¼š

```rust,ignore
trait FromIterator<A> {
    fn from_iter<T: IntoIterator<Item = A>>(iter: T) -> Self;
}
```

èƒ½ collect æˆä»€ä¹ˆç±»å‹ï¼Œå–å†³äºé‚£ä¸ªç±»å‹å®ç°æ²¡å®ç° FromIteratorã€‚

#### `collect()` ä¸ºä»€ä¹ˆç»å¸¸éœ€è¦ä½ æ ‡æ³¨ç±»å‹ï¼Ÿ

å› ä¸ºå…‰çœ‹è¿­ä»£å™¨å…ƒç´ ï¼Œç¼–è¯‘å™¨ä¸çŸ¥é“ä½ è¦è£…è¿› Vec è¿˜æ˜¯ HashSet è¿˜æ˜¯åˆ«çš„ã€‚

ä¸¤ç§å¸¸è§å†™æ³•ï¼š

```rust,editable
fn main() {
    let v = vec![1, 2, 3];
    // å†™æ³• 1ï¼šå˜é‡ç±»å‹æ ‡æ³¨
    let a: Vec<i32> = v.iter().map(|x| x * 10).collect();
    println!("{a:?}");
    // å†™æ³• 2ï¼šturbofish
    // let a = v.iter().map(|x| x * 10).collect::<Vec<i32>>();
    // println!("{a:?}");
}
```

#### å¸¸è§ `collect` ç›®æ ‡ï¼š`Vec / HashMap / String`

**collect åˆ° Vecï¼š**

```rust,editable
fn main() {
    let out: Vec<i32> = (0..5).map(|x| x * 2).collect();
    println!("{out:?}");
}
```

**collect åˆ° HashMapï¼š**

```rust,editable
use std::collections::HashMap;
fn main() {
    let pairs = vec![("a", 1), ("b", 2)];
    let map: HashMap<&str, i32> = pairs.into_iter().collect();
    println!("{map:?}");
}
```

**collect åˆ° Stringï¼ˆä» char åºåˆ—ï¼‰ï¼š**

```rust,editable
fn main() {
    let s: String = ['R', 'u', 's', 't'].into_iter().collect();
    println!("{s}");
}
```

#### `collect::<Result<Vec<_>, _>>()`ï¼š`FromIterator` çš„â€œé«˜çº§çˆ½ç‚¹â€

`Result`ï¼ˆä»¥åŠ `Option`ï¼‰ä¹Ÿå®ç°äº†éå¸¸å¼ºå¤§çš„ `FromIterator`ï¼š

* åªè¦æ‰€æœ‰å…ƒç´ éƒ½æ˜¯ `Ok(x)`ï¼Œå°± `collect` æˆ `Ok(Vec<x>)`
* åªè¦é‡åˆ°ä¸€ä¸ª `Err(e)`ï¼Œå°±ç«‹åˆ»è¿”å› `Err(e)`ï¼ˆçŸ­è·¯ï¼‰

```rust,editable
fn main() {
    let inputs = vec!["10", "20", "nope", "40"];
    let parsed: Result<Vec<i32>, _> = inputs
        .into_iter()
        .map(|s| s.parse::<i32>())
        .collect();
    println!("{parsed:?}"); // Err(...)
}
```

è¿™åœ¨è§£æã€æ ¡éªŒã€æ‰¹å¤„ç†é‡Œéå¸¸å¸¸ç”¨ï¼š**æŠŠé”™è¯¯å¤„ç†â€œè‡ªåŠ¨ç»‡å…¥â€ `collect`**ã€‚

#### è‡ªå®šä¹‰ `FromIterator`ï¼šè®©åˆ«äººèƒ½ `collect::<ä½ çš„ç±»å‹>()`

æˆ‘ä»¬å®ç°ä¸€ä¸ª EvenVecï¼šåªæ”¶é›†å¶æ•°ï¼ˆæ¼”ç¤ºâ€œè‡ªå®šä¹‰æ”¶é›†è§„åˆ™â€ï¼‰ã€‚

```rust,editable
#[derive(Debug)]
struct EvenVec(Vec<i32>);
impl FromIterator<i32> for EvenVec {
    fn from_iter<T: IntoIterator<Item = i32>>(iter: T) -> Self {
        let mut out = Vec::new();
        for x in iter {
            if x % 2 == 0 {
                out.push(x);
            }
        }
        EvenVec(out)
    }
}
fn main() {
    let evens: EvenVec = (0..10).collect();
    println!("{evens:?}"); // EvenVec([0,2,4,6,8])
}
```

---

## ä¸‰ã€è¿­ä»£å™¨çš„ä¸‰ç§æ¨¡å¼

**æ ¸å¿ƒé€»è¾‘**ï¼šåœ¨ Rust ä¸­ï¼Œè¿­ä»£å™¨ä¸ä»…å†³å®šå¦‚ä½•å¤„ç†æ•°æ®ï¼Œè¿˜å†³å®šäº†ä½ æ˜¯**æ‹¥æœ‰**è¿™äº›æ•°æ®ï¼Œè¿˜æ˜¯ä»…ä»…**å€Ÿç”¨**è¿™äº›æ•°æ®ã€‚è¿™ç›´æ¥å…³ç³»åˆ°å€Ÿç”¨æ£€æŸ¥å™¨ï¼ˆBorrow Checkerï¼‰æ˜¯å¦ä¼šæŠ¥é”™ã€‚

å‡ ä¹æ‰€æœ‰çš„é›†åˆï¼ˆå¦‚ `Vec`, `HashMap`, `BTreeMap`ï¼‰éƒ½æä¾›äº†è¿™ä¸‰ç§æ–¹æ³•ã€‚

è¿™ä¸‰è€…çš„æ ¸å¿ƒå·®å¼‚åªæœ‰ä¸€ä»¶äº‹ï¼š**è¿­ä»£æ—¶â€œå…ƒç´ çš„æ‰€æœ‰æƒ/å€Ÿç”¨â€**åˆ°åº•å½’è°ã€‚

* `iter()`ï¼šå…±äº«å€Ÿç”¨ï¼ˆ`read-only`ï¼‰ï¼Œäº§å‡º `&T`
* `iter_mut()`ï¼šå¯å˜å€Ÿç”¨ï¼ˆ`read-write`ï¼‰ï¼Œäº§å‡º `&mut T`
* `into_iter()`ï¼šæ‹¿èµ°æ‰€æœ‰æƒï¼ˆ`move`ï¼‰ï¼Œäº§å‡º Tï¼ˆé€šå¸¸ä¼šæ¶ˆè€—åŸé›†åˆï¼‰

> iter å€Ÿåªè¯»ï¼Œiter_mut å€Ÿå¯å†™ï¼Œinto_iter æ‹¿èµ°ä¸è¿˜ã€‚

### 1. `iter()`ï¼šä¸å¯å˜å€Ÿç”¨æ¨¡å¼ï¼ˆ`&T`ï¼‰

* **äº§ç”Ÿç±»å‹**ï¼šäº§ç”Ÿå…ƒç´ çš„ä¸å¯å˜å¼•ç”¨ `&T`ã€‚
* **ä½¿ç”¨åœºæ™¯**ï¼šä½ åªæƒ³è¯»å–é›†åˆä¸­çš„æ•°æ®ï¼Œè€Œä¸æ”¹å˜æ•°æ®ï¼Œä¹Ÿä¸æƒ³é”€æ¯é›†åˆã€‚
* **çŸ¥è¯†ç‚¹**ï¼šä¸ç§»åŠ¨é›†åˆå…ƒç´ ï¼Œåªæ˜¯â€œå€Ÿæ¥çœ‹çœ‹â€ã€‚è¿­ä»£ç»“æœç±»å‹ï¼š&Tã€‚åŸé›†åˆä»å¯ç»§ç»­ä½¿ç”¨ï¼ˆåªè¦å€Ÿç”¨æœŸç»“æŸï¼‰ã€‚


#### ä»£ç æ¼”ç¤ºï¼šè¯»å–ä½†ä¸ä¿®æ”¹

```rust,editable
fn main() {
    let v = vec![1, 2, 3];
    // iter() äº§ç”Ÿ &i32
    let mut v_iter = v.iter();
    assert_eq!(v_iter.next(), Some(&1));
    assert_eq!(v_iter.next(), Some(&2));
    assert_eq!(v_iter.next(), Some(&3));
    // é‡ç‚¹ï¼šé›†åˆ v åœ¨è¿­ä»£åä¾ç„¶å¯ä»¥ç»§ç»­ä½¿ç”¨
    println!("v ä¾ç„¶å­˜åœ¨: {:?}", v);
}
```

#### ä»£ç æ¼”ç¤ºï¼š`map` æ—¶æ³¨æ„è§£å¼•ç”¨

```rust,editable
fn main() {
    let v = vec![1, 2, 3];
    // iter() äº§ç”Ÿ &i32ï¼Œå› æ­¤ map çš„å‚æ•°æ˜¯ &i32
    let doubled: Vec<i32> = v.iter().map(|x| x * 2).collect();
    // è¿™é‡Œ x æ˜¯ &i32ï¼Œä½† * è¿ç®—ç¬¦å¯¹ &i32 ä¼šè‡ªåŠ¨è§£å¼•ç”¨ï¼ˆDeref coercion / Copyï¼‰
    println!("{:?}", doubled);
}
```

### 2. `iter_mut()`ï¼šå¯å˜å€Ÿç”¨æ¨¡å¼ï¼ˆ`&mut T`ï¼‰

* **äº§ç”Ÿç±»å‹**ï¼šäº§ç”Ÿå…ƒç´ çš„å¯å˜å¼•ç”¨ `&mut T`ã€‚
* **ä½¿ç”¨åœºæ™¯**ï¼šä½ éœ€è¦åŸåœ°ä¿®æ”¹é›†åˆä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ ã€‚
* **çŸ¥è¯†ç‚¹**:å…è®¸ä¿®æ”¹å…ƒç´ å†…å®¹ï¼Œä½†ä»ä¸æ‹¿èµ°æ‰€æœ‰æƒã€‚è¿­ä»£ç»“æœç±»å‹ï¼š`&mut T`ã€‚è¿­ä»£æœŸé—´ï¼Œé›†åˆè¢«â€œç‹¬å å¯å˜å€Ÿç”¨â€ï¼Œä¸èƒ½åŒæ—¶è¢«å…¶ä»–å€Ÿç”¨ä½¿ç”¨ã€‚

#### ä»£ç æ¼”ç¤ºï¼šåŸåœ°ä¿®æ”¹å…ƒç´ 

```rust,editable
fn main() {
    let mut v = vec![1, 2, 3];
    // iter_mut() äº§ç”Ÿ &mut i32
    // æ³¨æ„ï¼šå¿…é¡»è¦æ±‚ v æœ¬èº«æ˜¯ mut çš„
    for x in v.iter_mut() {
        *x *= 2; // é€šè¿‡è§£å¼•ç”¨ä¿®æ”¹åŸå§‹å€¼
    }
    println!("v å·²è¢«åŸåœ°ä¿®æ”¹: {:?}", v); // [2, 4, 6]
}
```

#### ä»£ç æ¼”ç¤ºï¼šé…åˆ `enumerate` åšä½ç½®ç›¸å…³ä¿®æ”¹

```rust,editable
fn main() {
    let mut v = vec![5, 5, 5, 5];
    for (i, x) in v.iter_mut().enumerate() {
        *x += i as i32;
    }
    println!("{:?}", v); // [5, 6, 7, 8]
}
```

### 3. `into_iter()`ï¼šæ‰€æœ‰æƒæ¨¡å¼ï¼ˆ`T`ï¼‰

* **äº§ç”Ÿç±»å‹**ï¼šäº§ç”Ÿå…ƒç´ æœ¬èº« `T`ã€‚
* **ä½¿ç”¨åœºæ™¯**ï¼šä½ éœ€è¦è·å–å…ƒç´ çš„æ‰€æœ‰æƒï¼ˆä¾‹å¦‚ç§»åŠ¨åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ï¼Œæˆ–è€…è½¬æ¢ç±»å‹ï¼‰ï¼Œå¹¶ä¸”**ä¸å†éœ€è¦**åŸå§‹é›†åˆã€‚
* **çŸ¥è¯†ç‚¹**:
  * æ¶ˆè€—åŸé›†åˆï¼ˆé€šå¸¸ moveï¼‰ï¼ŒæŠŠå…ƒç´ ä¸€ä¸ªä¸ªâ€œæ¬èµ°â€ã€‚
  * è¿­ä»£ç»“æœç±»å‹ï¼šT
  * åŸé›†åˆä¹‹åä¸€èˆ¬ä¸èƒ½å†ç”¨ï¼ˆå·²ç» movedï¼‰ã€‚

> é‡è¦ï¼šinto_iter() çš„å…·ä½“è¡Œä¸ºå’Œè¿”å›ç±»å‹ï¼Œå–å†³äºä½ å¯¹è°è°ƒç”¨ï¼š

* å¯¹ `Vec<T>` è°ƒç”¨ï¼šé€šå¸¸äº§å‡º Tï¼ˆæ‹¿èµ°å…ƒç´ ï¼‰
* å¯¹ `&Vec<T>` è°ƒç”¨ï¼šç›¸å½“äº iter()ï¼Œäº§å‡º `&T`
* å¯¹ `&mut Vec<T>` è°ƒç”¨ï¼šç›¸å½“äº iter_mut()ï¼Œäº§å‡º `&mut T`

#### ä»£ç æ¼”ç¤ºï¼šæ¶ˆè´¹é›†åˆï¼Œæ‹¿åˆ°å…ƒç´ æ‰€æœ‰æƒ

```rust,editable
fn main() {
    let v = vec![String::from("a"), String::from("b")];
    // into_iter() äº§ç”Ÿ Stringï¼ˆæ‰€æœ‰æƒï¼‰
    let upper: Vec<String> = v.into_iter()
        .map(|s| s.to_uppercase())
        .collect();
    println!("{:?}", upper);
    // println!("{:?}", v); // âŒ v å·²è¢« moveï¼ˆè¢« into_iter æ¶ˆè€—ï¼‰
}
```

#### ä»£ç æ¼”ç¤ºï¼šå¯¹å¼•ç”¨è°ƒç”¨ into_iterï¼ˆç±»å‹ä¸åŒï¼‰

```rust,editable
fn main() {
    let v = vec![1, 2, 3];
    let a: Vec<i32> = (&v).into_iter().copied().collect(); // &Vec -> &i32
    let b: Vec<i32> = v.into_iter().collect();            // Vec -> i32 (move)
    println!("{:?}", a);
    println!("{:?}", b);
}
```

### ä¸‰ç§æ¨¡å¼æ·±åº¦å¯¹æ¯”è¡¨

| æ–¹æ³• | äº§ç”Ÿçš„ Item | èƒŒå Trait å®ç° | é›†åˆä¹‹åæ˜¯å¦å¯ç”¨ï¼Ÿ | æ ¸å¿ƒæ€§è´¨ |
| --- | --- | --- | --- | --- |
| **`iter()`** | `&T` | `impl IntoIterator for &Vec<T>` | **æ˜¯** | åªè¯»è§‚å¯Ÿ |
| **`iter_mut()`** | `&mut T` | `impl IntoIterator for &mut Vec<T>` | **æ˜¯** | åŸåœ°æ‰‹æœ¯ |
| **`into_iter()`** | `T` | `impl IntoIterator for Vec<T>` | **å¦** | å½»åº•æ¶ˆè€— |

```rust,ignore
fn main() {
    let mut v = vec![1, 2, 3];
    let it1 = v.iter();      // Iterator<Item = &i32>
    let it2 = v.iter_mut();  // Iterator<Item = &mut i32>
    let it3 = v.into_iter(); // Iterator<Item = i32>  (v è¢« move)
}
```

### for å¾ªç¯åˆ°åº•ç”¨çš„æ˜¯è°?

`for x in something {}` æœ¬è´¨ä¸Šä¼šè°ƒç”¨ `IntoIterator`

* `for x in v` â†’ `v.into_iter()`ï¼ˆå¯èƒ½æ¶ˆè€— `v`ï¼‰
* `for x in &v` â†’ `(&v).into_iter()`ï¼ˆç­‰ä»· `iter`ï¼‰
* `for x in &mut v` â†’ `(&mut v).into_iter()`ï¼ˆç­‰ä»· `iter_mut`ï¼‰

#### ä»£ç æ¼”ç¤ºï¼šä¸‰ç§ for å†™æ³•

```rust,editable
fn main() {
    let mut v = vec![10, 20, 30];
    for x in &v {
        // x: &i32
        println!("read {x}");
    }
    for x in &mut v {
        // x: &mut i32
        *x += 1;
    }
    for x in v {
        // x: i32ï¼Œv è¢«æ¶ˆè´¹
        println!("owned {x}");
    }
    // println!("{:?}", v); // âŒ v å·²è¢«æ¶ˆè´¹
}
```

### é€‰å‹å»ºè®®ï¼šä»€ä¹ˆæ—¶å€™ç”¨å“ªä¸ªï¼Ÿ

* åªè¯»éå†ï¼šç”¨ `iter()` / `for x in &v`
* åŸåœ°æ”¹å…ƒç´ ï¼šç”¨ `iter_mut()` / `for x in &mut v`
* éœ€è¦æ‹¿åˆ°å…ƒç´ æ‰€æœ‰æƒï¼ˆå¦‚ String æ‹¼æ¥/è½¬ç§»/çº¿ç¨‹ä¼ é€’ï¼‰ï¼šç”¨ `into_iter()` / `for x in v`
* æƒ³ä¿ç•™åŸé›†åˆï¼Œä½†åˆæƒ³å¾—åˆ°â€œæ‹¥æœ‰çš„å€¼â€ï¼š
  * `iter().cloned()`ï¼ˆé’ˆå¯¹ `Clone`ï¼‰
  * `iter().copied()`ï¼ˆé’ˆå¯¹ `Copy`ï¼‰

```rust,editable
fn main() {
    let v = vec![1, 2, 3];
    let owned1: Vec<i32> = v.iter().copied().collect(); // ä¸æ¶ˆè€— v
    let owned2: Vec<i32> = v.clone().into_iter().collect(); // é€šè¿‡ clone å†æ¶ˆè´¹
    println!("{:?}", owned1);
    println!("{:?}", owned2);
    println!("{:?}", v);
}
```

---

## å››ã€å¸¸ç”¨è¿­ä»£å™¨é€‚é…å™¨

**æ ¸å¿ƒé€»è¾‘**ï¼šé€‚é…å™¨ï¼ˆAdaptersï¼‰æ˜¯è¿­ä»£å™¨çš„â€œåŠ å·¥è½¦é—´â€ã€‚å®ƒä»¬æ¥æ”¶ä¸€ä¸ªè¿­ä»£å™¨ï¼Œç»è¿‡æŸç§å˜æ¢ï¼Œè¾“å‡ºä¸€ä¸ªæ–°çš„è¿­ä»£å™¨ã€‚æœ€é‡è¦çš„ä¸€ç‚¹æ˜¯ï¼š**å®ƒä»¬æ˜¯æƒ°æ€§çš„ï¼ˆLazyï¼‰**ï¼Œé™¤éæœ€åçš„â€œæ¶ˆè´¹ç«¯â€ï¼ˆå¦‚ `collect`ï¼‰å‘å‡ºæŒ‡ä»¤ï¼Œå¦åˆ™è¿™äº›åŠ å·¥è½¦é—´æ ¹æœ¬ä¸ä¼šå¼€å·¥ã€‚

### 1. åŸºç¡€è½¬æ¢ï¼š`map` ä¸ `filter`

è¿™æ˜¯æœ€å¸¸ç”¨çš„ç»„åˆï¼Œç±»ä¼¼äº SQL ä¸­çš„ `SELECT` å’Œ `WHERE`ã€‚

* **`map`**ï¼šå¯¹æ¯ä¸ªå…ƒç´ æ‰§è¡Œè½¬æ¢ã€‚
* **`filter`**ï¼šæ ¹æ®å¸ƒå°”å€¼å†³å®šæ˜¯å¦ä¿ç•™å…ƒç´ ã€‚

#### mapï¼šé€å…ƒç´ å˜æ¢

* ç”¨é€”ï¼šæŠŠ Item å˜æˆå¦ä¸€ä¸ªä¸œè¥¿ã€‚
* ç­¾åç›´è§‰ï¼š`Iterator<Item=A> -> Iterator<Item=B>`

##### ç¤ºä¾‹ï¼š&i32 / i32 çš„å·®å¼‚ï¼ˆæœ€å¸¸è§å‘ï¼‰

```rust,editable
fn main() {
    let v = vec![1, 2, 3];
    // v.iter() äº§å‡º &i32ï¼Œæ‰€ä»¥é—­åŒ…å‚æ•°æ˜¯ &i32
    let a: Vec<i32> = v.iter().map(|&x| x * 10).collect();// å†™æ³• Aï¼šå‚æ•°é‡Œè§£æ„, æŠŠ &i32 è§£å¼•ç”¨ä¸€å±‚ï¼Œç»‘å®šåˆ° x: i32
    //å†™æ³• Bï¼šé—­åŒ…ä½“é‡Œè§£å¼•ç”¨:
    // let b: Vec<i32> = v.iter().map(|x| *x * 10).collect();
    // æˆ–è€…ï¼šmap(|x| x * 10) ä¹Ÿèƒ½è¿‡ï¼ˆå¾ˆå¤šè¿ç®—ä¼šè‡ªåŠ¨è§£å¼•ç”¨ï¼‰ï¼Œä½†å»ºè®®æ˜¾å¼ |&x| å…»æˆä¹ æƒ¯
    // v.into_iter() äº§å‡º i32ï¼Œé—­åŒ…å‚æ•°æ˜¯ i32
    let b: Vec<i32> = v.into_iter().map(|x| x * 10).collect();
    println!("{a:?} {b:?}");
}
```

#### filterï¼šç­›é€‰ï¼ˆ0/1 å¯¹ 1ï¼‰

* ç”¨é€”ï¼šæŒ‰æ¡ä»¶ä¿ç•™å…ƒç´ ã€‚
* å…³é”®ç‚¹ï¼šé—­åŒ…æ‹¿åˆ°çš„æ˜¯ å¼•ç”¨çš„å¼•ç”¨ æ—¶è¦è§£ä¸¤æ¬¡ï¼ˆæ¯”å¦‚ v.iter()ï¼‰

##### ç¤ºä¾‹ï¼šè¿‡æ»¤å¶æ•°ï¼ˆæ³¨æ„ |&&x|ï¼‰

```rust,editable
fn main() {
    let v = vec![1, 2, 3, 4, 5];
    let evens: Vec<i32> = v.iter()
        .filter(|&&x| x % 2 == 0) // è¿™é‡Œ x: &&i32
        .copied()
        .collect();
    println!("{evens:?}"); // [2, 4]
}
```

##### å¸¸ç”¨æ›¿ä»£ï¼šfilter_mapï¼ˆè¿‡æ»¤ + æ˜ å°„ï¼Œä¸€æ­¥åˆ°ä½ï¼‰

è¿™åœ¨å®é™…é¡¹ç›®é‡Œéå¸¸é«˜é¢‘ï¼ˆè§£æã€å®¹é”™ã€è·³è¿‡éæ³•æ•°æ®ï¼‰

```rust,editable
fn main() {
    let v = vec!["1", "oops", "3", "-7"];
    let nums: Vec<i32> = v.into_iter()
        .filter_map(|s| s.parse::<i32>().ok())
        .collect();
    println!("{nums:?}"); // [1, 3, -7]
}
```

### 2. ç»“æ„æ“ä½œï¼š`zip` ä¸ `chain`

* **`zip`**ï¼šå°†ä¸¤ä¸ªè¿­ä»£å™¨â€œæ‹‰â€åœ¨ä¸€èµ·ï¼Œåƒæ‹‰é“¾ä¸€æ ·äº§ç”Ÿä¸€å¯¹å¯¹çš„å…ƒç»„ `(a, b)`ã€‚å¦‚æœé•¿åº¦ä¸ç­‰ï¼Œä»¥çŸ­çš„ä¸ºå‡†ã€‚
* **`chain`**ï¼šå°†ä¸¤ä¸ªè¿­ä»£å™¨â€œæ¥â€åœ¨ä¸€èµ·ï¼Œä¸€ä¸ªå®Œäº†æ¥å¦ä¸€ä¸ªã€‚

#### zipï¼šå¹¶è¡Œé…å¯¹ï¼ˆçŸ­çš„ç»“æŸå°±ç»“æŸï¼‰

* ç”¨é€”ï¼šå°†ä¸¤ä¸ªè¿­ä»£å™¨â€œæ‹‰â€åœ¨ä¸€èµ·ï¼Œå¹¶è¡Œäº§å‡ºå…ƒç»„ `(a, b)`ã€‚
* è¾“å‡ºç±»å‹ï¼š`Iterator<Item=(A, B)>`
 
```rust,editable
fn main() {
    let names = vec!["alice", "bob", "cindy"];
    let ages  = vec![20, 30];
    // åªä¼šäº§å‡º 2 ç»„ï¼šå› ä¸º ages æ›´çŸ­
    let out: Vec<_> = names.iter()
        .zip(ages.iter())
        .map(|(&n, &a)| (n, a))
        .collect();

    println!("{out:?}"); // [("alice",20), ("bob",30)]
}
```

#### chainï¼šæ‹¼æ¥ä¸¤ä¸ªè¿­ä»£å™¨ï¼ˆç±»å‹è¦ä¸€è‡´ï¼‰

* ç”¨é€”ï¼šå°†ä¸¤ä¸ªè¿­ä»£å™¨â€œæ¥â€åœ¨ä¸€èµ·ï¼Œä¸€ä¸ªå®Œäº†æ¥å¦ä¸€ä¸ªã€‚
* è¾“å‡ºç±»å‹ï¼š`Iterator<Item=A>`ï¼ˆæˆ– `Iterator<Item=B>`ï¼Œå–å†³äºè¾“å…¥ï¼‰

```rust,editable
fn main() {
    let a = vec![1, 2];
    let b = vec![3, 4];
    let out: Vec<i32> = a.into_iter().chain(b.into_iter()).collect();
    println!("{out:?}"); // [1,2,3,4]
}
```

### 3. å¤„ç†åµŒå¥—ï¼š`flatten` ä¸ `flat_map`

**å®è·µåœºæ™¯**ï¼šå½“ä½ æœ‰ä¸€ä¸ª `Vec<Vec<T>>` æˆ–è€…è¿­ä»£å™¨äº§ç”Ÿçš„å…ƒç´ æœ¬èº«åˆæ˜¯ `Option` æˆ– `Result` æ—¶ã€‚

* **`flatten`**ï¼šæŠŠåµŒå¥—ç»“æ„â€œæ‹å¹³â€ä¸€å±‚ã€‚
* **`flat_map`**ï¼šå…ˆ `map` å† `flatten`ã€‚

#### flattenï¼šæ‹å¹³ä¸€å±‚ï¼ˆå…ƒç´ æœ¬èº«æ˜¯ iterableï¼‰

* ç”¨é€”ï¼šæŠŠ `Vec<Vec<T>>` æ‹å¹³æˆ `Vec<T>`ã€‚
* è¾“å‡ºç±»å‹ï¼š`Iterator<Item=T>`

##### å…¸å‹ï¼š`Vec<Vec<T>>ã€Vec<Option<T>>ã€Iterator<Item=Result<T,E>>`ï¼ˆé…åˆæŠ€å·§ï¼‰

```rust,editable
fn main() {
    let v = vec![vec![1, 2], vec![3], vec![4, 5]];
    let out: Vec<i32> = v.into_iter().flatten().collect();
    println!("{out:?}"); // [1,2,3,4,5]
}
```

##### ç»å…¸æŠ€å·§ï¼šOption çš„ flatten = â€œæŠŠ Some ç•™ä¸‹ï¼ŒæŠŠ None ä¸¢æ‰â€

```rust,editable
fn main() {
    let v = vec![Some(1), None, Some(3)];

    let out: Vec<i32> = v.into_iter().flatten().collect();
    println!("{out:?}"); // [1,3]
}
```

#### flat_mapï¼šmap + flattenï¼ˆå¸¸ç”¨äºæ‹†åˆ†/å±•å¼€ï¼‰

* ç”¨é€”ï¼šå…ˆ `map` å† `flatten`ï¼Œå¸¸ç”¨äºæ‹†åˆ†/å±•å¼€ã€‚
* è¾“å‡ºç±»å‹ï¼š`Iterator<Item=T>`

##### ç¤ºä¾‹ï¼šæ‹†åˆ†å­—ç¬¦ä¸²ï¼ˆæŒ‰ç©ºæ ¼ï¼‰

```rust,editable
fn main() {
    let lines = vec!["hello world", "rust iter"];
    let words: Vec<&str> = lines.into_iter()
        .flat_map(|line| line.split_whitespace())
        .collect();
    println!("{words:?}"); // ["hello","world","rust","iter"]
}
```



### 4. å¼•ç”¨å¤„ç†ï¼š`cloned` ä¸ `copied`

å½“ä½ åœ¨ä½¿ç”¨ `iter()`ï¼ˆäº§ç”Ÿ `&T`ï¼‰ä½†åç»­æ“ä½œéœ€è¦ `T` æ—¶ï¼Œè¿™ä¸¤ä¸ªé€‚é…å™¨éå¸¸æœ‰ç”¨ã€‚

* **`cloned()`**ï¼šè°ƒç”¨ `clone()` äº§ç”Ÿæ‹¥æœ‰æ‰€æœ‰æƒçš„å€¼ï¼ˆé€‚ç”¨äº `String` ç­‰ï¼‰ã€‚
* **`copied()`**ï¼šè°ƒç”¨æŒ‰ä½æ‹·è´ï¼ˆé€‚ç”¨äº `i32` ç­‰å®ç°äº† `Copy` çš„ç±»å‹ï¼‰ã€‚

* copied()ï¼š&T -> Tï¼Œè¦æ±‚ T: Copyï¼ˆå¦‚ i32ã€boolã€charï¼‰
* cloned()ï¼š&T -> Tï¼Œè¦æ±‚ T: Cloneï¼ˆå¦‚ Stringã€Vecã€Arc ç­‰ï¼‰

```rust,editable
fn main() {
    let a = vec![1, 2, 3];
    let x: Vec<i32> = a.iter().copied().collect();
    let b = vec!["hi".to_string(), "rust".to_string()];
    let y: Vec<String> = b.iter().cloned().collect();
    println!("{x:?}");
    println!("{y:?}");
}
```

### 5. æˆªå–ä¸è·³è¿‡ï¼štake, skip, take_while, skip_while

* **`take(n)`**ï¼šåªå–å‰ `n` ä¸ªå…ƒç´ ã€‚
* **`skip(n)`**ï¼šè·³è¿‡å‰ `n` ä¸ªå…ƒç´ ã€‚
* **`take_while(pred)`**ï¼šå–å…ƒç´ ç›´åˆ° `pred` ä¸º `false`ã€‚
* **`skip_while(pred)`**ï¼šè·³è¿‡å…ƒç´ ç›´åˆ° `pred` ä¸º `false`ã€‚

#### take(n) / skip(n)ï¼šæŒ‰æ•°é‡åˆ‡

```rust,editable
fn main() {
    let v = vec![1, 2, 3, 4, 5];
    let a: Vec<i32> = v.iter().take(3).copied().collect(); // [1,2,3]
    let b: Vec<i32> = v.iter().skip(3).copied().collect(); // [4,5]
    println!("{a:?} {b:?}");
}
```

#### take_while / skip_whileï¼šæŒ‰æ¡ä»¶åˆ‡ï¼ˆé‡åˆ°ä¸æ»¡è¶³å°±åœæ­¢/å¼€å§‹ï¼‰

```rust,editable
fn main() {
    let v = vec![1, 2, 3, 4, 3, 2];
    let a: Vec<i32> = v.iter().take_while(|&&x| x < 4).copied().collect();
    let b: Vec<i32> = v.iter().skip_while(|&&x| x < 4).copied().collect();
    println!("{a:?}"); // [1,2,3]
    println!("{b:?}"); // [4,3,2]  æ³¨æ„ï¼šä»ç¬¬ä¸€ä¸ªä¸æ»¡è¶³å¼€å§‹ï¼Œåé¢ä¸å†æ£€æŸ¥æ¡ä»¶
}
```

skip_while ä¸æ˜¯â€œè¿‡æ»¤â€ï¼Œå®ƒåªåœ¨å¼€å¤´è¿ç»­è·³è¿‡ï¼›ä¸€æ—¦å¼€å§‹äº§å‡ºï¼Œåç»­ä¸ä¼šå†è·³ã€‚



### 6. è¾…åŠ©å·¥å…·ï¼š`enumerate` ä¸ `inspect`

* **`enumerate`**ï¼šåœ¨è¿­ä»£æ—¶é¡ºä¾¿äº§å‡ºç´¢å¼• `(index, value)`ã€‚
* **`inspect`**ï¼šä¸ä¿®æ”¹å…ƒç´ ï¼Œåªæ˜¯æŸ¥çœ‹ï¼ˆå¸¸ç”¨äºè°ƒè¯•ï¼Œçœ‹çœ‹æµæ°´çº¿ä¸­é—´çš„çŠ¶æ€ï¼‰ã€‚

#### enumerateï¼šç»™å…ƒç´ é™„ä¸Šç´¢å¼•

* ç”¨é€”ï¼šåšâ€œä½ç½®ç›¸å…³â€çš„é€»è¾‘ï¼ˆæ¯”å¦‚ç»™æ¯ä¸ªå…ƒç´ ç¼–å·ï¼‰ã€‚
* è¾“å‡ºç±»å‹ï¼š`(usize, Item)`

```rust,editable
fn main() {
    let v = vec!["a", "b", "c"];
    let pairs: Vec<(usize, &str)> = v.iter()
        .enumerate()
        .map(|(i, &s)| (i, s))
        .collect();
    println!("{pairs:?}"); // [(0,"a"), (1,"b"), (2,"c")]
}
```

#### è°ƒè¯•è¾…åŠ©ï¼šinspect

* ç”¨é€”ï¼šåœ¨é“¾æ¡ä¸­é—´æ‰“å°/åŸ‹ç‚¹ï¼Œä¸æ”¹å˜å…ƒç´ ã€‚
* æ³¨æ„ï¼šä»ç„¶ lazyï¼Œåªæœ‰ç»ˆç»“å™¨è§¦å‘æ‰ä¼šæ‰“å°ã€‚

```rust,editable
fn main() {
    let out: Vec<i32> = (1..=5)
        .inspect(|x| println!("before map: {x}"))
        .map(|x| x * 10)
        .inspect(|x| println!("after  map: {x}"))
        .filter(|x| x >= &30)
        .collect();
    println!("{out:?}");
}
```

### é€‚é…å™¨é€‰å‹

ä¸‹é¢æ˜¯æåˆ°çš„è¿™äº›**è¿­ä»£å™¨é€‚é…å™¨ï¼ˆä¸­é—´æ“ä½œï¼‰**çš„æ±‡æ€»è¡¨

| åˆ†ç±»    | é€‚é…å™¨          | ä½œç”¨                          |
| ----- | ------------ | -------------------------------- |
| åŸºç¡€è½¬æ¢  | `map`        | å¯¹æ¯ä¸ªå…ƒç´ åšæ˜ å°„å˜æ¢ï¼ˆ1â†’1ï¼‰ï¼Œç”Ÿæˆæ–°è¿­ä»£å™¨           |
| åŸºç¡€è½¬æ¢  | `filter`     | æŒ‰æ¡ä»¶è¿‡æ»¤å…ƒç´ ï¼ˆä¿ç•™æ»¡è¶³æ¡ä»¶çš„ï¼‰                 |
| åŸºç¡€è½¬æ¢  | `enumerate`  | ç»™æ¯ä¸ªå…ƒç´ é™„å¸¦ç´¢å¼• `(usize, item)`        |
| ç»“æ„æ“ä½œ  | `zip`        | æŠŠä¸¤ä¸ªè¿­ä»£å™¨æŒ‰ä½ç½®é…å¯¹æˆ `(a, b)`ï¼Œä»¥è¾ƒçŸ­è€…ç»“æŸ     |
| ç»“æ„æ“ä½œ  | `chain`      | æŠŠä¸¤ä¸ªè¿­ä»£å™¨é¦–å°¾æ‹¼æ¥æˆä¸€ä¸ªè¿ç»­è¿­ä»£å™¨               |
| ç»“æ„æ“ä½œ  | `flatten`    | æ‹å¹³ä¸€å±‚ï¼šæŠŠâ€œå…ƒç´ æœ¬èº«å¯è¿­ä»£â€çš„è¿­ä»£å™¨å±•å¼€ä¸€å±‚          |
| ç»“æ„æ“ä½œ  | `flat_map`   | `map` åå† `flatten`ï¼šæ¯ä¸ªå…ƒç´ æ˜ å°„ä¸ºè¿­ä»£å™¨å¹¶å±•å¼€ |
| æˆªå–/è·³è¿‡ | `take`       | åªå–å‰ `n` ä¸ªå…ƒç´                       |
| æˆªå–/è·³è¿‡ | `skip`       | è·³è¿‡å‰ `n` ä¸ªå…ƒç´                       |
| æˆªå–/è·³è¿‡ | `take_while` | ä»å¤´å¼€å§‹å–ï¼Œç›´åˆ°æ¡ä»¶é¦–æ¬¡ä¸æ»¡è¶³å°±åœæ­¢               |
| æˆªå–/è·³è¿‡ | `skip_while` | ä»å¤´å¼€å§‹è·³è¿‡ï¼Œç›´åˆ°æ¡ä»¶é¦–æ¬¡ä¸æ»¡è¶³å°±å¼€å§‹äº§å‡ºï¼ˆä¹‹åä¸å†æ£€æŸ¥æ¡ä»¶ï¼‰  |
| è°ƒè¯•è¾…åŠ©  | `inspect`    | åœ¨è¿­ä»£é“¾ä¸­æ’å…¥è§‚å¯Ÿ/æ‰“å°ï¼Œä¸æ”¹å˜å…ƒç´ ï¼ˆä»æ˜¯ lazyï¼‰      |
| å¼•ç”¨å¤„ç†  | `cloned`     | æŠŠ `&T` å˜æˆ `T`ï¼ˆè¦æ±‚ `T: Clone`ï¼‰     |
| å¼•ç”¨å¤„ç†  | `copied`     | æŠŠ `&T` å˜æˆ `T`ï¼ˆè¦æ±‚ `T: Copy`ï¼‰      |

---


## äº”ã€ å¸¸ç”¨æ¶ˆè€—å™¨ï¼ˆç»ˆç»“æ“ä½œï¼‰

**æ ¸å¿ƒé€»è¾‘**ï¼šæ¶ˆè€—å™¨ï¼ˆConsumersï¼‰æ˜¯æµæ°´çº¿çš„â€œå‡ºå£â€ã€‚å¦‚æœæ²¡æœ‰æ¶ˆè€—å™¨ï¼Œå‰é¢çš„é€‚é…å™¨ï¼ˆå¦‚ `map`, `filter`ï¼‰æ°¸è¿œä¸ä¼šæ‰§è¡Œã€‚æ¶ˆè€—å™¨ä¼šé€šè¿‡å¾ªç¯ä¸æ–­è°ƒç”¨è¿­ä»£å™¨çš„ `next()` æ–¹æ³•ï¼Œç›´åˆ°è¿”å› `None` ä¸ºæ­¢ã€‚**ä¸€æ—¦è°ƒç”¨äº†æ¶ˆè€—å™¨ï¼Œè¯¥è¿­ä»£å™¨å°±è¢«æ¶ˆè€—æ‰äº†ï¼Œä¸èƒ½å†æ¬¡ä½¿ç”¨ã€‚**

### ç»ˆæé›†åˆå™¨ï¼š`collect`

è¿™æ˜¯æœ€å¸¸è§çš„æ¶ˆè€—å™¨ï¼Œæˆ‘ä»¬åœ¨å‰å‡ èŠ‚å·²ç»å¤šæ¬¡ç”¨åˆ°ã€‚å®ƒå°†è¿­ä»£å™¨ä¸­çš„å…ƒç´ æ”¶é›†åˆ°æŸç§é›†åˆä¸­ï¼ˆå¦‚ `Vec`, `HashMap`, `String` ç­‰ï¼‰ã€‚

* **ç‰¹ç‚¹**ï¼šé«˜åº¦æ³›å‹ï¼Œé€šå¸¸éœ€è¦ç±»å‹æš—ç¤ºã€‚
* **æŠ€å·§**ï¼šå®ƒå¯ä»¥å°† `Option<T>` çš„è¿­ä»£å™¨æ”¶é›†æˆ `Option<Vec<T>>`ã€‚

#### å…³é”®ç‚¹ï¼šç±»å‹æ¨æ–­

ç¼–è¯‘å™¨ä¸çŸ¥é“ä½ è¦æ”¶é›†æˆä»€ä¹ˆå°±ä¼šæŠ¥é”™ï¼Œæ‰€ä»¥å¸¸è§å†™æ³•ï¼š

```rust,editable
fn main() {
    let v = vec![1, 2, 3];
    let a = v.iter().map(|&x| x * 10).collect::<Vec<i32>>();
    let b: Vec<i32> = v.iter().map(|&x| x * 10).collect();
    println!("{a:?} {b:?}");
}
```

#### æ”¶é›†æˆ HashMap

```rust,editable
fn main() {
    let v = vec![1, 2, 3];
    // collect è§¦å‘äº†è¿­ä»£
    let doubled: Vec<_> = v.iter().map(|x| x * 2).collect();
    // è¿›é˜¶ï¼šå¤„ç† Optionã€‚å¦‚æœå…¶ä¸­æœ‰ä¸€ä¸ª Noneï¼Œæœ€ç»ˆç»“æœå°±æ˜¯ None
    let maybe_numbers = vec![Some(1), Some(2), None];
    let result: Option<Vec<i32>> = maybe_numbers.into_iter().collect();
    println!("{:?}", result); // None
}
```

### åŸºç¡€èšåˆï¼š`sum`, `product`, `count`

è¿™äº›æ“ä½œéå¸¸ç›´è§‚ï¼Œç”¨äºæ•°å€¼è®¡ç®—æˆ–ç»Ÿè®¡æ•°é‡ã€‚

#### count() è¿”å›å…ƒç´ ä¸ªæ•°ï¼ˆusizeï¼‰

```rust,editable
fn main() {
    let c = (1..=10).filter(|x| x % 2 == 0).count();
    println!("{c}"); // 5
}
```

#### sum() / product() : è¿”å›å…ƒç´ æ€»å’Œ / ä¹˜ç§¯

```rust,editable
fn main() {
    let v = vec![1, 2, 3, 4];
    let s: i32 = v.iter().sum();
    let p: i32 = v.iter().product();
    println!("{s} {p}"); // 10 24
}
```

### æŸ¥æ‰¾ä¸åŒ¹é…: find, position, any, all, nth

**æ ¸å¿ƒä¼˜åŠ¿**ï¼šè¿™äº›æ–¹æ³•å…·æœ‰**çŸ­è·¯ï¼ˆShort-circuitingï¼‰**ç‰¹æ€§ã€‚ä¾‹å¦‚ï¼Œ`any` åªè¦æ‰¾åˆ°ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„å…ƒç´ ï¼Œå°±ä¼šç«‹å³åœæ­¢è¿­ä»£ï¼Œä¸å†å¤„ç†åç»­æ•°æ®ã€‚è¿™å¯¹äºæ€§èƒ½ä¼˜åŒ–è‡³å…³é‡è¦ã€‚

* **`any`**ï¼šåªè¦æœ‰ä¸€ä¸ªç¬¦åˆæ¡ä»¶å°±è¿”å› `true`ã€‚
* **`all`**ï¼šå¿…é¡»å…¨éƒ¨ç¬¦åˆæ¡ä»¶æ‰è¿”å› `true`ã€‚
* **`find`**ï¼šè¿”å›ç¬¬ä¸€ä¸ªç¬¦åˆæ¡ä»¶çš„å…ƒç´ çš„å¼•ç”¨ï¼ˆåŒ…è£¹åœ¨ `Option` ä¸­ï¼‰ã€‚
* **`position`**ï¼šè¿”å›ç¬¬ä¸€ä¸ªç¬¦åˆæ¡ä»¶çš„å…ƒç´ çš„ç´¢å¼•ï¼ˆ`Option<usize>`ï¼‰ã€‚

#### find æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„å…ƒç´ ï¼ˆè¿”å› `Option<Item>`ï¼‰

```rust,editable
fn main() {
    let v = vec![10, 20, 30, 40];
    let f = v.iter().find(|&&x| x >= 25);
    println!("{f:?}"); // Some(&30)
}
```

#### position æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„ç´¢å¼•ï¼ˆè¿”å› `Option<usize>`ï¼‰

```rust,editable
fn main() {
    let v = vec![10, 20, 30, 40];
    let p = v.iter().position(|&x| x == 30);
    println!("{p:?}"); // Some(2)
}
```

#### any / all

* **`any`**ï¼šåªè¦æœ‰ä¸€ä¸ªç¬¦åˆæ¡ä»¶å°±è¿”å› `true`ã€‚
* **`all`**ï¼šå¿…é¡»å…¨éƒ¨ç¬¦åˆæ¡ä»¶æ‰è¿”å› `true`ã€‚

```rust,editable
fn main() {
    let v = vec![2, 4, 6, 7];
    println!("{}", v.iter().any(|&x| x % 2 == 1)); // true
    println!("{}", v.iter().all(|&x| x % 2 == 0)); // false
}
```

#### nth(k): å–ç¬¬ k ä¸ªå…ƒç´ ï¼Œä½†ä¼šæ¶ˆè€—æ‰å‰ k ä¸ªï¼ˆä¸æ˜¯éšæœºè®¿é—®ï¼‰

```rust,editable
fn main() {
    let mut it = (10..=20);
    println!("{:?}", it.nth(3)); // Some(13) æ¶ˆè€— 10,11,12,13
    println!("{:?}", it.next()); // Some(14) è¿­ä»£å™¨çŠ¶æ€å·²ç»æ¨è¿›
}
```

### æŠ˜å ä¸å½’çº¦ï¼šfold, reduce, scan

è¿™ä¸‰ä¸ªæ˜¯â€œæœ€åƒç®—æ³•â€çš„æ¶ˆè€—å™¨/åŠæ¶ˆè€—å™¨ã€‚

#### fold(init, f)ï¼šä½ æä¾›åˆå§‹å€¼

* æ€»æ˜¯è¿”å›ä¸€ä¸ªå€¼ï¼ˆä¸ä¼šæ˜¯ Optionï¼‰
* é€‚åˆï¼šç´¯è®¡ã€æ„å»ºå­—ç¬¦ä¸²ã€æ„å»º mapã€ç»Ÿè®¡ç­‰

```rust,editable
fn main() {
    let v = vec![1, 2, 3];
    let r = v.iter().fold(100, |acc, &x| acc + x);
    println!("{r}"); // 106
}
```

##### å…¸å‹ï¼šfold æ‹¼å­—ç¬¦ä¸²

```rust,editable
fn main() {
    let words = vec!["hello", "rust", "iter"];
    let s = words.iter().fold(String::new(), |mut acc, &w| {
        if !acc.is_empty() { acc.push(' '); }
        acc.push_str(w);
        acc
    });
    println!("{s}");
}
```


#### reduce(f)ï¼šç”¨ç¬¬ä¸€ä¸ªå…ƒç´ å½“åˆå§‹å€¼ï¼ˆè¿”å› Optionï¼‰

* ç©ºè¿­ä»£å™¨ä¼šè¿”å› None
* é€‚åˆï¼šæœ€å¤§å€¼ã€æ±‚å’Œç­‰â€œæœ‰è‡ªç„¶å•ä½å…ƒä½†ä¸æƒ³å†™ initâ€çš„åœºæ™¯

```rust,editable
fn main() {
    let v = vec![1, 2, 3];
    let r = v.into_iter().reduce(|acc, x| acc + x);
    println!("{r:?}"); // Some(6)
}
```

#### scan(state, f)ï¼šå®ƒæ˜¯é€‚é…å™¨ï¼ˆä½†éå¸¸åƒ foldï¼‰

* scan ä¼šäº§ç”Ÿä¸€ä¸ªæ–°è¿­ä»£å™¨ï¼ŒæŠŠâ€œä¸­é—´çŠ¶æ€â€ä¹Ÿä½œä¸ºè¾“å‡º
* é€‚åˆï¼šå‰ç¼€å’Œã€çŠ¶æ€æœºã€è§£ææµ

```rust,editable
fn main() {
    let v = vec![1, 2, 3, 4];
    // å‰ç¼€å’Œï¼š1,3,6,10
    let prefix: Vec<i32> = v.into_iter()
        .scan(0, |state, x| {
            *state += x;
            Some(*state)
        })
        .collect();
    println!("{prefix:?}");
}
```

### æå€¼å¤„ç†ï¼š`max`,`min`,`max_by`,`min_by`

è¿”å›è¿­ä»£å™¨ä¸­çš„æœ€å¤§å€¼æˆ–æœ€å°å€¼ã€‚æ³¨æ„å®ƒä»¬è¿”å›çš„æ˜¯ `Option`ï¼Œå› ä¸ºè¿­ä»£å™¨å¯èƒ½æ²¡æœ‰å…ƒç´ ã€‚

* å¯¹äºå¤æ‚ç»“æ„ï¼Œå¯ä»¥ä½¿ç”¨ `max_by` æˆ– `max_by_key`ã€‚

#### max/min

```rust,editable
fn main() {
    let v = vec![3, 10, 7];
    println!("{:?}", v.iter().max()); // Some(&10)
    println!("{:?}", v.iter().min()); // Some(&3)
}
```

#### è‡ªå®šä¹‰æ¯”è¾ƒï¼šmax_by / min_by

æ¯”å¦‚æŒ‰å­—ç¬¦ä¸²é•¿åº¦æ‰¾æœ€é•¿ï¼š

```rust,editable
fn main() {
    let v = vec!["aa", "bbbb", "ccc"];
    let best = v.iter().max_by(|a, b| a.len().cmp(&b.len()));
    println!("{best:?}"); // Some("bbbb")
}
```

### æœ¬èŠ‚â€œé€‰æ‹©å™¨â€ï¼šæˆ‘åˆ°åº•è¯¥ç”¨è°ï¼Ÿ

| ç±»åˆ«    | åå­—         | ä½œç”¨                                   | è¿”å›/ç‰¹ç‚¹                                 |
| ----- | ---------- | ------------------------------------ | ------------------------------------- |
| é›†åˆè½¬æ¢  | `collect`  | æŠŠè¿­ä»£å™¨æ”¶é›†æˆé›†åˆï¼ˆ`Vec/HashMap/HashSet/...`ï¼‰ | è¿”å›ç›®æ ‡é›†åˆç±»å‹ï¼›å¸¸éœ€æ ‡æ³¨ `collect::<Vec<_>>()`   |
| åŸºç¡€èšåˆ  | `count`    | ç»Ÿè®¡å…ƒç´ ä¸ªæ•°                               | `usize`                               |
| åŸºç¡€èšåˆ  | `sum`      | æ±‚å’Œ                                   | è¿”å›æ•°å€¼ç±»å‹ï¼ˆéœ€è¦å¯æ¨æ–­ï¼‰                         |
| åŸºç¡€èšåˆ  | `product`  | è¿ä¹˜                                   | è¿”å›æ•°å€¼ç±»å‹ï¼ˆéœ€è¦å¯æ¨æ–­ï¼‰                         |
| æŠ˜å /å½’çº¦ | `fold`     | è‡ªå®šä¹‰ç´¯è®¡ï¼ˆä½ æä¾›åˆå§‹å€¼ï¼‰                        | è¿”å›ç´¯è®¡ç»“æœï¼ˆä¸ä¼šæ˜¯ `Option`ï¼‰                  |
| æŠ˜å /å½’çº¦ | `reduce`   | ç”¨ç¬¬ä¸€ä¸ªå…ƒç´ åšåˆå§‹å€¼çš„å½’çº¦                        | `Option<Item>`ï¼Œç©ºè¿­ä»£å™¨ä¸º `None`           |
| æŠ˜å /å½’çº¦ | `scan`     | å¸¦çŠ¶æ€åœ°äº§ç”Ÿâ€œä¸­é—´ç»“æœåºåˆ—â€ï¼ˆå‰ç¼€å’Œ/çŠ¶æ€æœºï¼‰              | **æ³¨æ„ï¼šå®ƒæ˜¯é€‚é…å™¨**ï¼Œè¿”å›æ–°è¿­ä»£å™¨ï¼›é€šå¸¸å† `collect()`   |
| æŸ¥æ‰¾/åŒ¹é… | `find`     | æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„å…ƒç´                          | `Option<Item>`ï¼ˆå€Ÿç”¨è¿­ä»£å™¨é€šå¸¸æ˜¯ `Option<&T>`ï¼‰ |
| æŸ¥æ‰¾/åŒ¹é… | `position` | æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„ç´¢å¼•                         | `Option<usize>`                       |
| æŸ¥æ‰¾/åŒ¹é… | `any`      | æ˜¯å¦å­˜åœ¨ä»»æ„å…ƒç´ æ»¡è¶³æ¡ä»¶ï¼ˆçŸ­è·¯ï¼‰                     | `bool`                                |
| æŸ¥æ‰¾/åŒ¹é… | `all`      | æ˜¯å¦æ‰€æœ‰å…ƒç´ éƒ½æ»¡è¶³æ¡ä»¶ï¼ˆçŸ­è·¯ï¼‰                      | `bool`                                |
| æŸ¥æ‰¾/åŒ¹é… | `nth`      | å–ç¬¬ `n` ä¸ªå…ƒç´ ï¼ˆä» 0 å¼€å§‹ï¼‰                   | `Option<Item>`ï¼›ä¼šæ¶ˆè€—æ‰å‰ `n` ä¸ª            |
| æå€¼å¤„ç†  | `max`      | å–æœ€å¤§å…ƒç´                                 | `Option<Item>`ï¼ˆå€Ÿç”¨è¿­ä»£å™¨å¸¸ä¸º `Option<&T>`ï¼‰  |
| æå€¼å¤„ç†  | `min`      | å–æœ€å°å…ƒç´                                 | `Option<Item>`                        |
| æå€¼å¤„ç†  | `max_by`   | è‡ªå®šä¹‰æ¯”è¾ƒè§„åˆ™å–æœ€å¤§                           | `Option<Item>`ï¼Œæ¯”è¾ƒç”±é—­åŒ…å†³å®š                |
| æå€¼å¤„ç†  | `min_by`   | è‡ªå®šä¹‰æ¯”è¾ƒè§„åˆ™å–æœ€å°                           | `Option<Item>`ï¼Œæ¯”è¾ƒç”±é—­åŒ…å†³å®š                |

---

## å…­ã€è‡ªå®šä¹‰è¿­ä»£å™¨

**æ ¸å¿ƒé€»è¾‘**ï¼šåœ¨ Rust ä¸­ï¼Œè¦è®©ä¸€ä¸ªç»“æ„ä½“å˜æˆè¿­ä»£å™¨ï¼Œä½ ä¸éœ€è¦ç»§æ‰¿ä»»ä½•å¤æ‚çš„ç±»ï¼Œåªéœ€è¦å®ç° `Iterator` è¿™ä¸ª Traitã€‚ä½ å”¯ä¸€éœ€è¦åšçš„ï¼Œå°±æ˜¯å‘Šè¯‰ç¼–è¯‘å™¨**å¦‚ä½•äº§å‡ºä¸‹ä¸€ä¸ªå…ƒç´ **ï¼ˆ`next` æ–¹æ³•ï¼‰ä»¥åŠ**äº§å‡ºä»€ä¹ˆ**ï¼ˆ`Item` ç±»å‹ï¼‰ã€‚


### 1. å®ç° `Iterator` Trait çš„ä¸¤è¦ç´ 

è¦å®ç°è‡ªå®šä¹‰è¿­ä»£å™¨ï¼Œä½ çš„ç»“æ„ä½“å¿…é¡»å…·å¤‡ä¸¤ç‚¹ï¼š

1. **çŠ¶æ€ç»´æŠ¤**ï¼šç»“æ„ä½“é‡Œéœ€è¦æœ‰å­—æ®µè®°å½•å½“å‰è¿­ä»£åˆ°äº†å“ªé‡Œã€‚
2. **`next` æ–¹æ³•**ï¼šæ¯æ¬¡è°ƒç”¨æ—¶æ›´æ–°çŠ¶æ€ï¼Œå¹¶è¿”å› `Some(value)` æˆ– `None`ã€‚

#### æ–æ³¢é‚£å¥‘æ•°åˆ—è¿­ä»£å™¨

æ–æ³¢é‚£å¥‘æ•°åˆ—æ˜¯ä¸€ä¸ªå®Œç¾çš„è‡ªå®šä¹‰è¿­ä»£å™¨ä¾‹å­ï¼Œå› ä¸ºå®ƒå…·æœ‰æ¸…æ™°çš„å†…éƒ¨çŠ¶æ€è½¬ç§»ã€‚

```rust,editable
struct Fibonacci {
    curr: u32,
    next: u32,
}
impl Fibonacci {
    fn new() -> Fibonacci {
        Fibonacci { curr: 0, next: 1 }
    }
}
// ä¸º Fibonacci å®ç° Iterator
impl Iterator for Fibonacci {
    type Item = u32; // äº§å‡º u32 ç±»å‹
    fn next(&mut self) -> Option<Self::Item> {
        let current = self.curr;
        // è®¡ç®—ä¸‹ä¸€é¡¹å¹¶æ›´æ–°çŠ¶æ€
        self.curr = self.next;
        self.next = current + self.next;
        // æ–æ³¢é‚£å¥‘æ•°åˆ—é€šå¸¸æ˜¯æ— é™çš„ï¼Œä½†åœ¨ Rust ä¸­æˆ‘ä»¬éœ€è¦è®¾ç½®ä¸€ä¸ªè¾¹ç•Œ
        // è¿™é‡Œå‡è®¾è¶…è¿‡ 1000 å°±åœæ­¢
        if current > 1000 {
            None
        } else {
            Some(current)
        }
    }
}
fn main() {
    let fib = Fibonacci::new();
    // ä¸€æ—¦å®ç°äº† Iteratorï¼Œä½ å°±å¯ä»¥ä½¿ç”¨ map, filter ç­‰æ‰€æœ‰é€‚é…å™¨ï¼
    for num in fib.take(10) {
        println!("{}", num);
    }
}
```

### 2. ä¸ºé›†åˆå®ç° `IntoIterator`

å¦‚æœä½ åˆ›å»ºäº†ä¸€ä¸ªè‡ªå®šä¹‰é›†åˆï¼ˆæ¯”å¦‚ `MyList`ï¼‰ï¼Œä½ å¯èƒ½å¸Œæœ›ç›´æ¥å†™ `for x in my_list`ã€‚è¿™æ—¶ä½ éœ€è¦å®ç° `IntoIterator`ã€‚

**æ ¸å¿ƒé€»è¾‘**ï¼š`IntoIterator` çš„ä½œç”¨æ˜¯å®šä¹‰â€œå¦‚ä½•ä»ä½ çš„é›†åˆäº§ç”Ÿä¸€ä¸ªè¿­ä»£å™¨â€ã€‚

```rust,editable
struct MyCollection {
    items: Vec<i32>,
}
impl IntoIterator for MyCollection {
    type Item = i32;
    type IntoIter = std::vec::IntoIter<i32>; // ç›´æ¥å¤ç”¨ Vec çš„è¿­ä»£å™¨ç±»å‹
    fn into_iter(self) -> Self::IntoIter {
        self.items.into_iter()
    }
}
fn main() {
    let coll = MyCollection { items: vec![1, 2, 3] };
    // ç°åœ¨å¯ä»¥ç›´æ¥åœ¨ for å¾ªç¯ä¸­ä½¿ç”¨
    for x in coll {
        println!("{}", x);
    }
}
```

### 3. è‡ªå®šä¹‰è¿­ä»£å™¨çš„ä¼˜åŠ¿ï¼šèŠ‚çœå†…å­˜

è‡ªå®šä¹‰è¿­ä»£å™¨æœ€å¤§çš„é­…åŠ›åœ¨äºï¼š**å®ƒæ˜¯æŒ‰éœ€ç”Ÿæˆçš„ã€‚**

æƒ³è±¡ä¸€ä¸‹ä½ éœ€è¦å¤„ç† 100 ä¸‡ä¸ªæ•°æ®ï¼Œå¦‚æœä½ å…ˆæŠŠå®ƒä»¬å…¨éƒ¨å­˜åœ¨ `Vec` é‡Œï¼Œä¼šå ç”¨å¤§é‡å†…å­˜ã€‚ä½†å¦‚æœä½ å†™ä¸€ä¸ªè‡ªå®šä¹‰è¿­ä»£å™¨ï¼Œå®ƒåªéœ€è¦è®°å½•â€œå½“å‰åœ¨å“ªâ€ï¼Œå†…å­˜å ç”¨å‡ ä¹ä¸ºé›¶ï¼Œæ— è®ºä½ è¦å¤„ç†å¤šå°‘æ•°æ®ã€‚

#### ğŸ› ï¸ è¿›é˜¶ï¼šå¸¦çŠ¶æ€çš„è¿‡æ»¤è¿­ä»£å™¨

ä½ å¯ä»¥åˆ›å»ºä¸€ä¸ªåŒ…è£…å¦ä¸€ä¸ªè¿­ä»£å™¨çš„è‡ªå®šä¹‰è¿­ä»£å™¨ã€‚

```rust
struct SkipNone<I> {
    inner: I,
}
impl<I, T> Iterator for SkipNone<I>
where
    I: Iterator<Item = Option<T>>, // è¦æ±‚å†…éƒ¨è¿­ä»£å™¨äº§å‡º Option
{
    type Item = T;

    fn next(&mut self) -> Option<Self::Item> {
        // å¾ªç¯è°ƒç”¨å†…éƒ¨è¿­ä»£å™¨ï¼Œç›´åˆ°æ‰¾åˆ°ä¸€ä¸ª Some æˆ–è€…ç»“æŸ
        while let Some(opt) = self.inner.next() {
            if let Some(val) = opt {
                return Some(val);
            }
        }
        None
    }
}
```

### æ ¸å¿ƒæ€»ç»“ï¼šè‡ªå®šä¹‰ä¸‰éƒ¨æ›²

1. **å®šä¹‰ç»“æ„ä½“**ï¼šç¡®å®šä½ éœ€è¦å“ªäº›å­—æ®µæ¥è®°ä½è¿­ä»£è¿›åº¦ï¼ˆæ¯”å¦‚ç´¢å¼•ã€å½“å‰æ•°å€¼ç­‰ï¼‰ã€‚
2. **å£°æ˜ `Item` ç±»å‹**ï¼šå‘Šè¯‰ Rust è¿­ä»£å™¨äº§å‡ºä»€ä¹ˆï¼ˆå¼•ç”¨ `&T` è¿˜æ˜¯å€¼ `T`ï¼‰ã€‚
3. **ç¼–å†™ `next` é€»è¾‘**

* å¦‚æœæœ‰æ•°æ®ï¼šæ›´æ–°çŠ¶æ€ï¼Œè¿”å› `Some(value)`ã€‚
* å¦‚æœæ²¡æ•°æ®ï¼šè¿”å› `None`ã€‚

---

## ä¸ƒã€ é«˜çº§ä¸ç‰¹æ®Šè¿­ä»£å™¨

* DoubleEndedIteratorï¼šåŒç«¯è¿­ä»£å™¨ï¼Œæ”¯æŒä»åå¾€å‰è¿­ä»£ï¼ˆrev()ï¼‰
* ExactSizeIteratorï¼šå·²çŸ¥ç²¾ç¡®é•¿åº¦çš„è¿­ä»£å™¨ï¼ˆlen()ï¼‰
* FusedIteratorï¼šèåˆè¿­ä»£å™¨ï¼Œä¿è¯ None ä¹‹åæ°¸è¿œè¿”å› None
* Peekableï¼šæ”¯æŒâ€œé¢„è§ˆâ€ä¸‹ä¸€ä¸ªå…ƒç´ è€Œä¸æ¶ˆè€—å®ƒ

---

## å…«ã€ æ€§èƒ½ä¸åº•å±‚åŸç†

* è¿­ä»£å™¨çš„å†…éƒ¨è¿­ä»£ vs å¤–éƒ¨è¿­ä»£
* ç¼–è¯‘å™¨ä¼˜åŒ–ï¼šå¾ªç¯å±•å¼€ï¼ˆLoop Unrollingï¼‰ä¸å†…è”
* è¿­ä»£å™¨åœ¨å†…å­˜å®‰å…¨ä¸Šçš„ä¿éšœï¼šé¿å…ç´¢å¼•è¶Šç•Œ
* itertools åº“ï¼šäº†è§£ç¤¾åŒºæ ‡å‡†æ‰©å±•åŒ…

---

## ä¹ã€ è¿­ä»£å™¨ä¸ç”Ÿå‘½å‘¨æœŸçš„äº¤é›†

* è¿­ä»£å™¨äº§ç”Ÿçš„å¼•ç”¨å¯¿å‘½çº¦æŸ
* åœ¨ç»“æ„ä½“ä¸­å­˜å‚¨è¿­ä»£å™¨ï¼ˆæ¶‰åŠç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼‰
* é—­åŒ…æ•è·ç¯å¢ƒå¯¹è¿­ä»£å™¨ç”Ÿå‘½å‘¨æœŸçš„å½±å“

---
