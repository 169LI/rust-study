# 变量

在 Rust 中，变量的处理方式与其他编程语言（如 Python 或 Java）有很大不同。其核心设计理念是**安全性**和**内存管理**。

以下是关于 Rust 变量的核心知识点：

## 1. 不可变性

在 Rust 中，变量**默认是不可变的**。一旦你为一个变量绑定了值，就不能再修改它。

```rust,editable
fn main() {
    let x = 5;
    x = 6; // ❌ 编译错误！不能对不可变变量二次赋值
}
```

**为什么要这样做？**
通过默认不可变，Rust 保证了数据的安全性。在多线程环境下，你可以确信一个变量的值不会在你不注意的时候被其他代码修改。

---

## 2. 可变变量

如果你需要修改某个变量，必须显式地加上 `mut` 关键字。

```rust,editable
fn main() {
    let mut x = 5;
    println!("x 的值是: {}", x);
    x = 6; // ✅ 允许修改
    println!("现在 x 的值是: {}", x);
}
```

---

## 3. 变量遮蔽

Rust 允许你声明一个与现有变量同名的新变量。这被称为“遮蔽”。

```rust,editable
fn main() {
    let x = 5;
    let x = x + 1; // 遮蔽了之前的 x
    
    {
        let x = x * 2; // 在当前作用域内再次遮蔽
        println!("内部作用域中 x 的值: {}", x); // 12
    }

    println!("外部作用域中 x 的值: {}", x); // 6
}

```

**遮蔽与 `mut` 的区别：**

1. **类型转换**：使用 `let` 遮蔽时，你可以改变变量的类型（例如从字符串变为数字），而 `mut` 变量的类型是固定的。
2. **重新锁定**：遮蔽后，新变量如果没有 `mut`，它依然是不可变的。

---

## 4. 常量

常量类似于不可变变量，但有严格的区别：

* 使用 `const` 关键字。
* **必须**显式注明类型（例如 `i32`）。
* 可以在任何作用域声明（包括全局）。
* 只能赋值为“常量表达式”，不能是函数调用的结果或运行时计算的值。

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;

```

---

## 5. 数据类型概览

Rust 是**静态类型**语言，在编译时必须知道所有变量的类型。通常编译器能自动推导类型，但有时需要你手动标注。

| 分类 | 类型示例 |
| --- | --- |
| **标量 (Scalar)** | 整数 (`i32`, `u64`), 浮点数 (`f64`), 布尔值 (`bool`), 字符 (`char`) |
| **复合 (Compound)** | 元组 (`tuple`), 数组 (`array`) |

---

## 6. 作用域

变量在 Rust 中是“块级作用域”的。变量在声明的大括号 `{}` 内有效，超出范围后，变量会被**释放 (Drop)**。

```rust
fn main() {
    let s = "hello"; // s 进入作用域
    {
        let x = 10; // x 进入作用域
    } // x 在这里失效并释放
} // s 在这里失效并释放

```

---

### 总结对比

| 特性 | `let` | `let mut` | `const` |
| --- | --- | --- | --- |
| **默认状态** | 不可变 | 可变 | 永久不可变 |
| **类型标注** | 可选 | 可选 | **必须** |
| **重新赋值** | 只能通过遮蔽 | 允许 | 不允许 |
| **运行期计算** | 支持 | 支持 | 不支持 |

您是刚开始学习 Rust 吗？如果是的话，**您想了解一下 Rust 最独特的“所有权 (Ownership)”概念，还是想先看看具体的数据类型？**
