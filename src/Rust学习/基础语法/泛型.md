# 泛型

泛型是 Rust 实现 零开销抽象（Zero-cost Abstractions） 的核心，它允许你编写不依赖于具体类型的通用代码。


## 1. **泛型基础(Generics Basics)**

### 泛型类型参数

Rust 中的泛型允许我们在编写函数或结构体时不指定具体类型，从而让代码更具通用性。例如：

```rust,editable
fn swap<T>(x: T, y: T) -> (T, T) {
    (y, x)
}

fn main() {
    let (a, b) = swap(1, 2);
    println!("Swapped values: {}, {}", a, b);

    let (x, y) = swap("Hello", "World");
    println!("Swapped strings: {}, {}", x, y);
}
```

swap 函数接受两个相同类型的参数 x 和 y，并返回它们的交换值。T 在调用时会被具体类型替换，确保返回的元组类型与输入类型一致。

### 泛型约束

有时我们希望泛型类型参数满足特定的条件，例如只允许实现了某个特征（`trait`）的类型。可以使用 `T: Trait` 来为泛型添加约束。

```rust,editable
fn print_debug<T: std::fmt::Debug>(val: T) {
    println!("{:?}", val);
}
fn main() {
    print_debug(42);          // 传递整数，符合 Debug 特征
    // print_debug("Hello");  // 编译错误，因为字符串没有 Debug 特征
}
```

### 泛型方法

方法与函数类似，但它们是定义在**结构体、枚举、trait 等类型**上的。在定义方法时，你可以在**impl块中**使用泛型类型参数。

```rust,editable
struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    // 泛型方法，接受一个泛型参数并返回其和
    fn new(x: T, y: T) -> Self {
        Pair { x, y }
    }
    fn get_x(&self) -> &T {
        &self.x
    }
    fn get_y(&self) -> &T {
        &self.y
    }
}
fn main() {
    let pair = Pair::new(1, 2);  // T = i32
    println!("Pair: {} and {}", pair.get_x(), pair.get_y());
    let pair_str = Pair::new("Hello", "World");  // T = &str
    println!("Pair: {} and {}", pair_str.get_x(), pair_str.get_y());
}
```

在这个例子中，Pair 是一个泛型结构体，new 方法和 get_x、get_y 方法都是泛型方法。它们可以处理任何类型 T，确保类型一致性。

## 2. **结构体和枚举中的泛型**

### 泛型结构体

结构体也可以使用泛型类型，字段类型由泛型决定,以便存储不同类型的数据。

```rust,editable
struct Pair<T, U> {
    x: T,
    y: U,
}

fn main() {
    let int_float = Pair { x: 42, y: 3.14 };
    let string_int = Pair { x: "Hello", y: 100 };
    println!("int_float: ({}, {})", int_float.x, int_float.y);
    println!("string_int: ({}, {})", string_int.x, string_int.y);
}
```

在这个示例中，`Pair` 结构体有两个泛型参数 `T` 和 `U`，它们可以代表不同的类型。

### 泛型枚举

枚举类型也可以使用泛型，允许它们处理不同类型的数据。例如，标准库中的 `Option<T>` 和 `Result<T, E>` 就是泛型枚举。

```rust,editable
// 定义一个泛型枚举
enum MyOption<T> {
    Some(T),
    None,
}

fn main() {
    let some_int = MyOption::Some(42);
    let none: MyOption<i32> = MyOption::None;
  
    match some_int {
        MyOption::Some(value) => println!("Some: {}", value),
        MyOption::None => println!("None"),
    }
}
```

## 3. **特征（Trait）与泛型**

### 泛型与特征结合

特征（trait，具体看下一节介绍)）可以与泛型结合使用，限制泛型类型必须实现特定的特征。例如：

```rust,editable
// 定义一个 trait
trait Printable {
    fn print(&self);
}
// 为 `i32` 实现 `Printable` 特征
impl Printable for i32 {
    fn print(&self) {
        println!("Printing i32: {}", self);
    }
}
// 泛型函数，只有实现了 `Printable` 特征的类型才能使用
fn print_value<T: Printable>(val: T) {
    val.print();
}
fn main() {
    let x = 42;
    print_value(x);  // 可以，因为 i32 实现了 Printable 特征
}
```

## 4. **生命周期（Lifetime）与泛型**

有时，生命周期和泛型约束会结合使用，以确保泛型类型满足特定条件。在某些情况下，泛型类型可能是引用类型，因此需要生命周期标注。（其他复杂情况见生命周期小节）

```rust,editable
// 一个泛型函数，它的类型 T 必须是引用类型，并且带有生命周期标注
fn first_word<'a, T>(s: &'a T) -> &'a str
where
    T: AsRef<str>,  // 泛型类型 T 必须实现 AsRef<str> 特征
{
    let str_ref: &str = s.as_ref(); // 将 T 转换为 &str
    let bytes = str_ref.as_bytes();
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &str_ref[0..i];
        }
    }
    &str_ref[..]
}
fn main() {
    let string = String::from("Hello world");
    let word = first_word(&string);
    println!("The first word is: {}", word);
}
```

## 5. **关联类型（Associated Types）**

Rust 允许在 trait 中定义“关联类型”，这些类型在 trait 的实现中被具体化。这样可以简化泛型的使用。

```rust,editable
// 定义一个 trait，带有关联类型
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}
// 为 Vec 实现 Iterator 特征
impl<T> Iterator for Vec<T> {
    type Item = T;
    fn next(&mut self) -> Option<Self::Item> {
        self.pop()
    }
}
fn main() {
    let mut vec = vec![1, 2, 3];
    let mut iter = vec.into_iter();
    println!("{:?}", iter.next());  // 输出 Some(3)
}
```

## 6. **泛型与性能考虑**

在 `Rust `中，泛型是非常强大的工具，它允许编写类型安全且灵活的代码。然而，许多人担心使用泛型是否会影响程序的性能。幸运的是，`Rust `的设计非常注重性能，尤其是与泛型相关的部分。让我们深入探讨泛型如何影响性能，以及如何最大程度地避免性能损失。

`Rust `使用一种称为 单态化`（Monomorphization）` 的机制来处理泛型。单态化是指编译器在编译时将泛型类型的代码转换为具体类型的实现。这意味着泛型代码在编译期间被实例化为不同类型的具体代码，因此没有运行时的性能开销。

这种机制确保了泛型代码的 零成本抽象`（Zero-cost Abstraction）`。也就是说，使用泛型不会导致额外的运行时开销。

尽管泛型本身不会带来运行时的性能损失，但它们可能会影响 **内存布局** 和 **大小**，特别是当涉及到**动态分发**时。泛型类型的大小由编译器在单态化时决定。如果泛型类型的大小变化较大，可能会导致更多的内存分配或数据拷贝。编译器会为每种具体类型生成不同的内存布局，从而避免了不必要的浪费。


## 7. **与标准库的泛型交互**

标准库中的许多类型，如 `Vec<T>`、`Option<T>`、`Result<T, E>` 都使用泛型。你可以通过这些泛型类型来简化代码。

Rust 标准库几乎处处是泛型。

* **常见容器**：`Vec<T>`（动态数组）、`HashMap<K, V>`（键值对）。
* **错误处理**：`Result<T, E> `是编写健壮代码的核心。
* **迭代器与闭包**：它们利用泛型接口实现高度灵活的数据处理流。

## 8. **高级泛型使用**

### 高阶类型（HKT）的模拟

* **`HKT (Higher Kinded Types)`** 模拟：通过 `type alias` 和 `Trait` 模拟对“容器的抽象”。
* **并发/异步**：使用 `Send `和 `Sync` 特征约束确保泛型数据在多线程间安全传递。
* **宏与泛型**：结合使用以生成复杂的泛型 `boilerplate` 代码。

